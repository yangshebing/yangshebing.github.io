<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[杨社兵的技术博客]]></title>
  <link href="http://yangshebing.github.io/atom.xml" rel="self"/>
  <link href="http://yangshebing.github.io/"/>
  <updated>2016-01-04T21:27:24+08:00</updated>
  <id>http://yangshebing.github.io/</id>
  <author>
    <name><![CDATA[杨社兵]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift中UITableView的用法(自定义UITableView和UITableViewCell)]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/04/swiftzhong-uitableviewde-yong-fa-zi-ding-yi-uitableviewhe-uitableviewcell/"/>
    <updated>2016-01-04T21:23:33+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/04/swiftzhong-uitableviewde-yong-fa-zi-ding-yi-uitableviewhe-uitableviewcell</id>
    <content type="html"><![CDATA[<p>一、自定义表视图（UITableView）</p>

<!--more-->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>import UIKit
</span><span class='line'>class HomeTableView: UITableView, UITableViewDataSource, UITableViewDelegate {
</span><span class='line'>//表视图的数据源：dataList
</span><span class='line'>    var dataList = [AnyObject]()
</span><span class='line'>//单元格的标识符：homeCellId
</span><span class='line'>    let identify = "homeCellId"
</span><span class='line'>    //重写表视图初始化方法
</span><span class='line'>    override init(frame: CGRect, style: UITableViewStyle) {
</span><span class='line'>        super.init(frame:frame, style:style)
</span><span class='line'>        //调用初始化子视图方法
</span><span class='line'>        initSubviews()
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    required init?(coder aDecoder: NSCoder) {
</span><span class='line'>        fatalError("init(coder:) has not been implemented")
</span><span class='line'>    }
</span><span class='line'>    //初始化表视图的子视图方法
</span><span class='line'>    func initSubviews () {
</span><span class='line'>    //设置数据源代理
</span><span class='line'>        dataSource = self;
</span><span class='line'>   //设置表视图代理
</span><span class='line'>        delegate = self;
</span><span class='line'>        //注册单元格class方式
</span><span class='line'>        registerClass(HomeCell.self, forCellReuseIdentifier: identify)
</span><span class='line'>       //设置表视图的分割线显示风格
</span><span class='line'>        separatorStyle = .None;
</span><span class='line'>        //注册单元格xib方式
</span><span class='line'>        //registerNib(UINib(nibName: "HomeCell", bundle: nil), forCellReuseIdentifier:identify)
</span><span class='line'>    }
</span><span class='line'>   //实现表视图返回组数代理方法：不实现默认为1
</span><span class='line'>    func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int {
</span><span class='line'>        return 1;
</span><span class='line'>    }
</span><span class='line'>//实现表视图返回行数代理方法
</span><span class='line'>    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
</span><span class='line'>        return dataList.count;
</span><span class='line'>    }
</span><span class='line'>    //实现表视图返回单元格代理方法
</span><span class='line'>    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
</span><span class='line'>    //取单元格
</span><span class='line'>        let cell = tableView.dequeueReusableCellWithIdentifier(identify) as! HomeCell
</span><span class='line'>        //设置单元格的选中风格
</span><span class='line'>        cell.selectionStyle = .None;
</span><span class='line'>        cell.titleStr = dataList[indexPath.row] as? String
</span><span class='line'>        return cell
</span><span class='line'>    }
</span><span class='line'>    //选中单元格的代理方法
</span><span class='line'>    func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
</span><span class='line'>        print("the indexpath row is \(indexPath.row)")
</span><span class='line'>    }
</span><span class='line'>    //返回单元格高度的代理方法
</span><span class='line'>    func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat {
</span><span class='line'>        return 80;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>二、自定义单元格（UITableViewCell）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import UIKit
</span><span class='line'>
</span><span class='line'>class HomeCell: UITableViewCell {
</span><span class='line'>//定义子视图变量
</span><span class='line'>    var imgView: UIImageView!
</span><span class='line'>    var titleLabel: UILabel!
</span><span class='line'>    var button: UIButton!
</span><span class='line'>    var titleStr: String?
</span><span class='line'>    // 重写单元格初始化方法
</span><span class='line'>    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {
</span><span class='line'>        super.init(style: style, reuseIdentifier: reuseIdentifier);
</span><span class='line'>        //调用单元格初始化方法
</span><span class='line'>        initSubviews()
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    required init?(coder aDecoder: NSCoder) {
</span><span class='line'>        fatalError("init(coder:)has not been implemented")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    override func awakeFromNib() {
</span><span class='line'>        super.awakeFromNib()
</span><span class='line'>        // Initialization code
</span><span class='line'>    }
</span><span class='line'>    //单元格子视图初始化方法
</span><span class='line'>    func initSubviews () {
</span><span class='line'>        imgView = UIImageView(frame: CGRectMake(0, 0, 30, 30))
</span><span class='line'>        imgView.image = UIImage(named: "exam.png")
</span><span class='line'>        contentView.addSubview(imgView);
</span><span class='line'>        
</span><span class='line'>        titleLabel = UILabel(frame: CGRectMake(0, 0, frame.size.width, frame.size.height))
</span><span class='line'>        titleLabel.textAlignment = .Left;
</span><span class='line'>        titleLabel.textColor = UIColor.lightGrayColor();
</span><span class='line'>        titleLabel.font = UIFont.systemFontOfSize(15);
</span><span class='line'>        titleLabel.text = "心灵鸡汤，每天一起干"
</span><span class='line'>        contentView.addSubview(titleLabel)
</span><span class='line'>        
</span><span class='line'>        button = UIButton(type: .Custom)
</span><span class='line'>        button.frame = CGRectMake(0, 0, frame.size.width, frame.size.height)
</span><span class='line'>        button.setTitle("关注", forState: .Normal)
</span><span class='line'>        button.setTitleColor(UIColor.whiteColor(), forState: .Normal)
</span><span class='line'>        button.backgroundColor = UIColor.grayColor()
</span><span class='line'>        contentView.addSubview(button)
</span><span class='line'>    }
</span><span class='line'>    //重写单元格布局子视图方法
</span><span class='line'>    override func layoutSubviews() {
</span><span class='line'>        super.layoutSubviews()
</span><span class='line'>        titleLabel.text = titleStr
</span><span class='line'>      //...
</span><span class='line'>      //布局单元格子视图
</span><span class='line'>      //...
</span><span class='line'>    override func setSelected(selected: Bool, animated: Bool) {
</span><span class='line'>        super.setSelected(selected, animated: animated)
</span><span class='line'>        // Configure the view for the selected state
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之基础控件（Swift版）]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/02/ioskai-fa-zhi-ji-chu-kong-jian-(swiftban-)/"/>
    <updated>2016-01-02T11:08:19+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/02/ioskai-fa-zhi-ji-chu-kong-jian-(swiftban-)</id>
    <content type="html"><![CDATA[<p>  1、文本（UILabel）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  let titleLabel = UILabel(frame: CGRectMake(0, 0, view.frame.size.width, view.frame.size.height))
</span><span class='line'>        //设置titleLabel的文本对齐方式：左：.Left, 中:.Center, 右:.Right
</span><span class='line'>        titleLabel.textAlignment = .Center
</span><span class='line'>        //设置titleLabel的文本颜色
</span><span class='line'>        titleLabel.textColor = UIColor.lightGrayColor()
</span><span class='line'>        //设置titleLabel文字的字体为系统字体，大小为15
</span><span class='line'>        titleLabel.font = UIFont.systemFontOfSize(15)
</span><span class='line'>        //设置titleLabel文字的字体为"Helvetica", 大小为15
</span><span class='line'>        titleLabel.font = UIFont(name: "Helvetica", size: 15)
</span><span class='line'>        titleLabel.text = "心灵鸡汤，每天一起干"
</span><span class='line'>        //titleLabel字体大小自适应宽度，根据指定宽度titleLabel自动调整字体显示大小
</span><span class='line'>        titleLabel.adjustsFontSizeToFitWidth = true
</span><span class='line'>        //指定titleLabel的显示行数，0代表自动折行
</span><span class='line'>        titleLabel.numberOfLines = 1
</span><span class='line'>        //获取系统所有字体名称
</span><span class='line'>        let fontFamily = UIFont.familyNames()
</span><span class='line'>        print(fontFamily)
</span><span class='line'>        view.addSubview(titleLabel)</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>2、按钮（UIButton）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//按钮类型：常见的两种如下
</span><span class='line'>         /**
</span><span class='line'>         *.Custom:自定义类型
</span><span class='line'>         *.System:系统类型（iOS7.0）
</span><span class='line'>         **/
</span><span class='line'>        let followButton = UIButton(type: .Custom)
</span><span class='line'>        followButton.frame = CGRectMake(100, 100, 100, 50)
</span><span class='line'>        //设置按钮在特定状态下的文本显示，常见的有：
</span><span class='line'>        /**
</span><span class='line'>         *.Normal:按钮常规显示状态
</span><span class='line'>         *.Selected:按钮选中显示状态
</span><span class='line'>         *.Highlighted:按钮高亮显示状态
</span><span class='line'>         *.Disabled:按钮关闭状态显示
</span><span class='line'>        **/
</span><span class='line'>        followButton.setTitle("关注", forState: .Normal)
</span><span class='line'>        //设置按钮在特定状态下的文本色值显示
</span><span class='line'>        followButton.setTitleColor(UIColor.whiteColor(), forState: .Normal)
</span><span class='line'>        //设置按钮在特定状态下的图片显示
</span><span class='line'>        followButton.setImage(UIImage(named: "back"), forState: .Normal)
</span><span class='line'>        followButton.setImage(UIImage(named: "select"), forState: .Disabled)
</span><span class='line'>        //设置按钮显示文本的字体大小
</span><span class='line'>        followButton.titleLabel?.font = UIFont.systemFontOfSize(15)
</span><span class='line'>        //设置按钮选中状态
</span><span class='line'>        followButton.selected = true
</span><span class='line'>        //设置按钮是否打开状态
</span><span class='line'>        followButton.enabled = true
</span><span class='line'>        //设置是否响应用户touch事件
</span><span class='line'>        followButton.userInteractionEnabled = true
</span><span class='line'>        //设置按钮的背景颜色
</span><span class='line'>        followButton.backgroundColor = UIColor.grayColor()
</span><span class='line'>        //关闭按钮处于高亮状态图片变暗显示状态
</span><span class='line'>        followButton.adjustsImageWhenHighlighted = false
</span><span class='line'>        //设置按钮图片的内部填充
</span><span class='line'>        followButton.imageEdgeInsets = UIEdgeInsetsMake(10, 10, 10, 10)
</span><span class='line'>        //设置按钮文本的内部填充
</span><span class='line'>        followButton.titleEdgeInsets = UIEdgeInsetsMake(10, 10, 10, 10)
</span><span class='line'>        //为按钮添加点击事件
</span><span class='line'>        followButton.addTarget(self, action: "followAction", forControlEvents: .TouchUpInside)
</span><span class='line'>        view.addSubview(followButton)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>按钮点击事件响应方法：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func followAction(sender: UIButton) {
</span><span class='line'>    print("关注")
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>3、图片展示视图（UIImageView）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let imgView = UIImageView(frame: CGRectMake(0, 0, view.frame.size.width, view.frame.size.height))
</span><span class='line'>        //设置图片视图显示图片
</span><span class='line'>        imgView.image = UIImage(named: "exam.png")
</span><span class='line'>        //设置图片视图高亮状态显示图片
</span><span class='line'>        imgView.highlightedImage = UIImage(named: "exam1.png")
</span><span class='line'>        //设置图片视图内容展示模式：常见的几种内容展示模式
</span><span class='line'>        /**
</span><span class='line'>        *.ScaleToFill:缩放图片填满整个图片视图
</span><span class='line'>        *.ScaleAspectFit:缩放内容以适应原图尺寸，没有铺满的地方保持透明
</span><span class='line'>        *.ScaleAspectFill:按钮高亮显示状态
</span><span class='line'>        **/
</span><span class='line'>        imgView.contentMode = .ScaleAspectFit
</span><span class='line'>        //设置图片视图是否高亮显示
</span><span class='line'>        imgView.highlighted = true
</span><span class='line'>        //设置是否响应用户touch事件,默认为false
</span><span class='line'>        imgView.userInteractionEnabled = true
</span><span class='line'>        //播放一组图片
</span><span class='line'>        let img1 = UIImage(named: "play1.png")!
</span><span class='line'>        let img2 = UIImage(named: "play2.png")!
</span><span class='line'>        let img3 = UIImage(named: "play3.png")!
</span><span class='line'>        let images = [img1, img2, img3]
</span><span class='line'>        //设置需要播放的一组图片
</span><span class='line'>        imgView.animationImages = images
</span><span class='line'>        //设置播放持续时间
</span><span class='line'>        imgView.animationDuration = 1
</span><span class='line'>        //设置播放重复次数
</span><span class='line'>        imgView.animationRepeatCount = 20
</span><span class='line'>        //开始播放
</span><span class='line'>        imgView.startAnimating()
</span><span class='line'>        //停止播放
</span><span class='line'>        imgView.stopAnimating()
</span><span class='line'>        
</span><span class='line'>        view.addSubview(imgView);</span></code></pre></td></tr></table></div></figure>


<p>4、文字输入框（UITextField）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let textField = UITextField(frame: CGRectMake(20, 100, 100,30))
</span><span class='line'>        //设置文本编辑框显示文字
</span><span class='line'>        textField.text = "将编程进行到底"
</span><span class='line'>        //设置文本编辑框占位文字
</span><span class='line'>        textField.placeholder = "客官，你想不想要？"
</span><span class='line'>        //设置文本编辑框的边框显示类型
</span><span class='line'>        textField.borderStyle = .RoundedRect
</span><span class='line'>        //设置文本编辑框的文字字体
</span><span class='line'>        textField.font = UIFont.systemFontOfSize(15)
</span><span class='line'>        //设置文本编辑框的文本颜色
</span><span class='line'>        textField.textColor = UIColor.blackColor()
</span><span class='line'>        //设置文本编辑框输入文本时首字母是否自动大写
</span><span class='line'>        textField.autocapitalizationType = .None
</span><span class='line'>        //设置文本编辑框清除按钮显示模式
</span><span class='line'>        textField.clearButtonMode = .WhileEditing
</span><span class='line'>        //设置文本编辑框的文本对齐方式
</span><span class='line'>        textField.textAlignment = .Center
</span><span class='line'>        //设置文本编辑框返回键显示类型
</span><span class='line'>        textField.returnKeyType = .Search
</span><span class='line'>        //设置是否为安全文本输入状态
</span><span class='line'>        textField.secureTextEntry = true
</span><span class='line'>        //设置输入键盘类型
</span><span class='line'>        textField.keyboardType = .NumberPad
</span><span class='line'>        //设置文本编辑框的代理
</span><span class='line'>        textField.delegate = self
</span><span class='line'>        //唤起键盘，让文本编辑框成为第一响应者
</span><span class='line'>        textField.becomeFirstResponder()
</span><span class='line'>        view.addSubview(textField)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>UITextFiled代理方法（UITextFiledDelegate）:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//将要开始编辑代理方法,此方法会在键盘弹出之前调用
</span><span class='line'>    func textFieldShouldBeginEditing(textField: UITextField) -&gt; Bool {
</span><span class='line'>        return true
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //已经开始编辑代理方法，此方法会在键盘弹出之后调用
</span><span class='line'>    func textFieldDidBeginEditing(textField: UITextField) {
</span><span class='line'>        print(textField.text)
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //当return按钮被点击时调用
</span><span class='line'>    func textFieldShouldReturn(textField: UITextField) -&gt; Bool {
</span><span class='line'>        //收起键盘，注销文本编辑框为第一响应者
</span><span class='line'>        textField.resignFirstResponder()
</span><span class='line'>        return true
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //将要结束编辑代理方法，此方法会在收起键盘的时候调用
</span><span class='line'>    func textFieldShouldEndEditing(textField: UITextField) -&gt; Bool {
</span><span class='line'>        return true
</span><span class='line'>    }
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<p>5、开关控件（UISwitch）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    let sliderControl = UISlider(frame: CGRectMake(30, 200, 100, 30))
</span><span class='line'>    //设置滑动条控件最大值
</span><span class='line'>    sliderControl.maximumValue = 10
</span><span class='line'>    //设置滑动条控件最小值
</span><span class='line'>    sliderControl.minimumValue = 1
</span><span class='line'>    //设置滑动条控件初始值
</span><span class='line'>    sliderControl.value = 5
</span><span class='line'>    //设置滑动条控件最大值方向颜色显示
</span><span class='line'>    sliderControl.maximumTrackTintColor = UIColor.redColor()
</span><span class='line'>    //设置滑动条控件最小值方向颜色显示
</span><span class='line'>    sliderControl.minimumTrackTintColor = UIColor.brownColor()
</span><span class='line'>    //设置滑动条控件拖动按钮颜色
</span><span class='line'>    sliderControl.thumbTintColor = UIColor.blueColor()
</span><span class='line'>    //设置滑动条控件最大值方向图片显示：正常状态
</span><span class='line'>    sliderControl.setMaximumTrackImage(UIImage(named: "slidermax.png"), forState: .Normal)
</span><span class='line'>    //设置滑动条控件最小值方向图片显示：正常状态
</span><span class='line'>    sliderControl.setMinimumTrackImage(UIImage(named: "slidermin.png"), forState: .Normal)
</span><span class='line'>    //设置滑动条控件拖动按钮显示图片：正常状态
</span><span class='line'>    sliderControl.setThumbImage(UIImage(named: "thumb.png"), forState: .Normal)
</span><span class='line'>    //为滑动条控件添加：值改变触发事件
</span><span class='line'>    sliderControl.addTarget(self, action: "sliderAction:", forControlEvents: .ValueChanged)
</span><span class='line'>    view.addSubview(sliderControl)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>开关值改变事件响应方法：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sliderAction(sliderControl: UISlider) {
</span><span class='line'>        print("the slider value is \(sliderControl.value)")
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>6、加载指示器视图（UIActivityIndicatorView）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let activityControl = UIActivityIndicatorView(frame: CGRectMake(100, 200, 30, 30))
</span><span class='line'>        //设置加载指示器视图的风格
</span><span class='line'>        activityControl.activityIndicatorViewStyle = .Gray
</span><span class='line'>        //设置加载指示器视图的背景颜色
</span><span class='line'>        activityControl.backgroundColor = UIColor.redColor()
</span><span class='line'>        //开始动画
</span><span class='line'>        activityControl.startAnimating()
</span><span class='line'>        //停止动画
</span><span class='line'>        activityControl.stopAnimating()
</span><span class='line'>        view.addSubview(activityControl)</span></code></pre></td></tr></table></div></figure>


<p>7、分段控件视图（UISegmentedControl）:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let items = ["全部", "电影", "新闻", "科技"]
</span><span class='line'>        let segmentedControl = UISegmentedControl(items: items)
</span><span class='line'>        segmentedControl.frame = CGRectMake(30, 200, 180, 30)
</span><span class='line'>        //设置分段控件颜色
</span><span class='line'>        segmentedControl.tintColor = UIColor.redColor()
</span><span class='line'>        //设置分段控件默认选中索引
</span><span class='line'>        segmentedControl.selectedSegmentIndex = 1
</span><span class='line'>        //为分段控件添加值改变响应事件
</span><span class='line'>        segmentedControl.addTarget(self, action: "segmentControlAction:", forControlEvents: .ValueChanged)
</span><span class='line'>        view.addSubview(segmentedControl)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>分段控件值改变事件响应方法：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func segmentControlAction(segmentedControl: UISegmentedControl) {
</span><span class='line'>        if segmentedControl.selectedSegmentIndex == 0 {
</span><span class='line'>
</span><span class='line'>        } else if segmentedControl.selectedSegmentIndex == 1 {
</span><span class='line'>
</span><span class='line'>        } else if segmentedControl.selectedSegmentIndex == 2{
</span><span class='line'>
</span><span class='line'>        } else {
</span><span class='line'>
</span><span class='line'>        }
</span><span class='line'>       print("the segmented Control selected Index is \(segmentedControl.selectedSegmentIndex)")
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>8、页面控件（UIPageControl）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let pageControl = UIPageControl(frame: CGRectMake(30, 200, 180, 30))
</span><span class='line'>        //设置页面控件的背景颜色
</span><span class='line'>        pageControl.backgroundColor = UIColor.brownColor()
</span><span class='line'>        //设置总页数
</span><span class='line'>        pageControl.numberOfPages = 4
</span><span class='line'>        //设置当前页数
</span><span class='line'>        pageControl.currentPage = 1
</span><span class='line'>        //设置页面控件指示器颜色
</span><span class='line'>        pageControl.pageIndicatorTintColor = UIColor.redColor()
</span><span class='line'>        //设置页面控件当前页面指示器颜色
</span><span class='line'>        pageControl.currentPageIndicatorTintColor = UIColor.blueColor()
</span><span class='line'>        //添加页面控件点击响应事件
</span><span class='line'>        pageControl.addTarget(self, action: "changeAction:", forControlEvents: .TouchUpInside)
</span><span class='line'>        view.addSubview(pageControl)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>页面控件点击响应事件：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func changeAction(pageControl: UIPageControl) {   
</span><span class='line'>  print("the current select page is :\(pageControl.currentPage)")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>9、警告视图控制器（UIAlertController）：(UIAlertView 与 UIActionSheet在iOS8.0之后就弃用了，推荐使用UIAlertController)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    /**
</span><span class='line'>     * .Alert
</span><span class='line'>     * .ActionSheet
</span><span class='line'>     */
</span><span class='line'>    let alertCtrl = UIAlertController(title: "提示信息", message: "确定返回吗？", preferredStyle: .Alert)
</span><span class='line'>    //初始化警告动作
</span><span class='line'>    let cancelAction = UIAlertAction(title: "取消", style: .Cancel) { (action) -&gt; Void in
</span><span class='line'>        //...
</span><span class='line'>        //添加相应处理代码
</span><span class='line'>        //...
</span><span class='line'>        //把UIAlertController从父视图控制器中移除，防止内存泄漏
</span><span class='line'>        alertCtrl.removeFromParentViewController()
</span><span class='line'>    }
</span><span class='line'>    let okAction = UIAlertAction(title: "立即返回", style: .Default) { (action) -&gt; Void in
</span><span class='line'>        //...
</span><span class='line'>        //添加相应处理代码
</span><span class='line'>        //...
</span><span class='line'>        //把UIAlertController从父视图控制器中移除，防止内存泄漏
</span><span class='line'>        alertCtrl.removeFromParentViewController()
</span><span class='line'>    }
</span><span class='line'>    //添加动作
</span><span class='line'>    alertCtrl.addAction(cancelAction)
</span><span class='line'>    alertCtrl.addAction(okAction)
</span><span class='line'>    //弹出警告视图控制器
</span><span class='line'>    self.presentViewController(alertCtrl, animated: true, completion: nil)</span></code></pre></td></tr></table></div></figure>


<p>10、 进度条视图（UIProgressView）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> let progressView = UIProgressView(progressViewStyle: .Bar)
</span><span class='line'>    progressView.frame = CGRectMake(30, 200, 180, 30)
</span><span class='line'>    //设置默认进度
</span><span class='line'>    progressView.progress = 0.3
</span><span class='line'>    //设置进度条加载过的颜色
</span><span class='line'>    progressView.progressTintColor = UIColor.redColor()
</span><span class='line'>    //设置进度条未加载过的颜色
</span><span class='line'>    progressView.trackTintColor = UIColor.blueColor()
</span><span class='line'>    //设置进度条加载过的图片展示
</span><span class='line'>    progressView.progressImage = UIImage(named: "progress.png")
</span><span class='line'>    //设置进度条未加载过的图片展示
</span><span class='line'>    progressView.trackImage = UIImage(named: "track.png")
</span><span class='line'>    view.addSubview(progressView)</span></code></pre></td></tr></table></div></figure>


<p>11、 工具条控件（UIToolBar）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    let toolBar = UIToolbar(frame: CGRectMake(30, 200, 180, 49))
</span><span class='line'>    //设置工具条展示风格
</span><span class='line'>    toolBar.barStyle = .Default
</span><span class='line'>    //添加工具条按钮
</span><span class='line'>    let item = UIBarButtonItem(barButtonSystemItem: .Done, target: self, action: "itemButtonAction")
</span><span class='line'>    let item1 = UIBarButtonItem(barButtonSystemItem: .Edit, target: self, action: "itemButtonAction")
</span><span class='line'>    //固定间距工具条按钮
</span><span class='line'>    let item2 = UIBarButtonItem(barButtonSystemItem: .FixedSpace, target: self, action: "itemButtonAction")
</span><span class='line'>    item2.width = 30
</span><span class='line'>    let customButton = UIButton(type: .DetailDisclosure)
</span><span class='line'>    customButton.addTarget(self, action: "itemButtonAction", forControlEvents: .TouchUpInside)
</span><span class='line'>    //自定义按钮为工具条按钮
</span><span class='line'>    let item3 = UIBarButtonItem(customView: customButton)
</span><span class='line'>    let items = [item, item1, item2, item3]
</span><span class='line'>    //设置工具条要显示的所有按钮
</span><span class='line'>    toolBar.items = items
</span><span class='line'>    view.addSubview(toolBar)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>工具条按钮点击响应事件：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func itemButtonAction() {
</span><span class='line'>        print("tool bar button")
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015年终总结]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/01/2015nian-zhong-zong-jie/"/>
    <updated>2016-01-01T13:26:26+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/01/2015nian-zhong-zong-jie</id>
    <content type="html"><![CDATA[<h4>总结：</h4>

<p>回首过去一年，好像没有什么能说出口的成绩，专业没啥进步。在公司做了两款App，上半年主要开发的是一款叫“在线等”的手机应用，这是一款解决人们选择困难症的应用，经过重重困难，最终上线。没啥成绩可言。下半年主要研发的是一款叫“斗图神器”的应用，由于Android版早就开发好了，所以iOS版开发起来就快很多了。总的来说成绩还不错，其中也有点小波折。<!--more-->现在已经提交过3，4版了。目前“斗图神器”项目已经引入了全新的Swift语言与Objective-C语言混编。目的是拥抱Swift，它才是未来。这对我们来说是好事，有项目环境学习新语言就更快了。现在我还是处于Swift 初级入门阶段，明年希望能进一步提高吧！在学习方面，搭建了自己的<a href="http://yangshebing.github.io"><strong>个人技术博客</strong></a>，另外还写了几篇质量不高的博文，在github上放了几个质量不高的demo。买了手机和电脑，这也算专业学习上的投入吧。生活上，除了每天写写代码，并没有什么其他变化。4月份去了一趟泰山，7月份去了一次十渡，10月份游了半个北京（虽然来北京久了，却很少出去）顺带去了一趟天津。今年最大的事情就是拔了一颗智齿和一颗蛀牙，花了不少钱，现在都没弄好！折腾了半条命（太背），一直不太顺。其次就是大病没犯，小病不断，北京这边雾霾比较严重。咽炎也挺折腾人的。本来年底是计划上线一款自己的app,由于各种借口各种拖最终没能实现，也没啥可遗憾的，主要是自己没有努力。其实还计划学习一门除专业外的语言，这个计划也耽搁了！计划内的写一个插件，现在也还没开动！专业书今年没有仔细读过，其实应该多读几本。扩展书籍就读过《高效能人士的7个习惯》与《从0到1》。总而言之就是读的书还是太少，平常大部分时间是在网上看别人的博客学习，看官方文档，不会的就自己用google搜索。人丑就要多读书。越来越不会说话了，已经想不起还有什么要说的了，那就先写到这吧！共勉！
2016的计划与展望：</p>

<h4>计划：</h4>

<ul>
<li>1、  读10本以上的专业相关的书籍，扩展阅读书籍不少于5本。</li>
<li>2、  学一门专业外的语言</li>
<li>3、  在github上开源5个项目（高质量）</li>
<li>4、  博客不少于50篇博文（高质量）</li>
<li>5、  找个女盆友</li>
<li>6、  福利计划：去国外旅游一次（条件如下）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if plan five implement {
</span><span class='line'>      implement plan six
</span><span class='line'>} else {
</span><span class='line'>      nothing happened
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>展望：</h4>

<p>马上迎来全新的2016年，又是一个全新的开始。时间匆匆，趁着年轻就要好好努力，物尽其用。希望在新的一年里，事业蒸蒸日上，身体健健康康（身体是革命的本钱，是实现计划的基石），愿家人幸福安康。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS FFmpeg编译及kxmovie、iFrameExtractor调试详解（无障碍阅读，绝对是你想要的）]]></title>
    <link href="http://yangshebing.github.io/blog/2015/11/16/ios-ffmpegbian-yi-ji-kxmovie,-iframeextractordiao-shi-xiang-jie-(wu-zhang-ai-yue-du-,jue-dui-shi-ni-xiang-yao-de-)/"/>
    <updated>2015-11-16T01:44:27+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/11/16/ios-ffmpegbian-yi-ji-kxmovie,-iframeextractordiao-shi-xiang-jie-(wu-zhang-ai-yue-du-,jue-dui-shi-ni-xiang-yao-de-)</id>
    <content type="html"><![CDATA[<p><strong>特此声明：本文是通过网上收集整理加上自己亲自实验得来的。感谢所有网上分享的辛勤劳动者，本文仅供iOS学习使用。在学习的过程中，如果有问题或者不清楚的地方，欢迎留言，我们共同探讨互相学习。欢迎批评指正。</strong></p>

<p><strong>如需转载，请注明出处：<a href = "http://blog.csdn.net/yangshebing21/article/details/43986913"><a href="http://blog.csdn.net/yangshebing21/article/details/43986913">http://blog.csdn.net/yangshebing21/article/details/43986913</a></a></strong></p>

<h4>开发环境：最新 ffmpeg-2.5.4/iOS SDK8.1/Xcode6.1/OS X Yosemite版本10.10.2</h4>

<h3>一、编译ffmpeg库</h3>

<h4>编译调试ffmpeg库的步骤：</h4>

<p><strong>开发环境：ffmpeg-2.5.4/Xcode6.1</strong></p>

<h4>（一）、下载ffmpeg源码：</h4>

<p>请点击此链接<a href = "http://ffmpeg.org/download.html"><a href="http://ffmpeg.org/download.html">http://ffmpeg.org/download.html</a></a></p>

<p> <font color = "red"><b>注：我的ffmpeg-2.5.4是解压放至Desktop的</b></font></p>

<h4>（二）、调试编译ffmpeg源码</h4>

<p> 1、安装yasm:
 <!--more--></p>

<p> 方法一:</p>

<p> 在终端输入</p>

<pre><code class="`"> sudo curlhttp://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz &gt;yasm.tar.gz
</code></pre>

<p>方法二：</p>

<p>（1）Download yasm sourcecode from：
  <a href = "http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz"><a href="http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz">http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz</a></a></p>

<p>（2）Unpack tar xvzfyasm-1.2.0.tar.gz</p>

<p>（3）cd yasm-1.2.0</p>

<p>（4）Configure and build:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./configure && make -j 4 &&sudo make install</span></code></pre></td></tr></table></div></figure>


<p>2、下载pearl脚本文件：gas-preprocessor.pl：</p>

<p>下载地址： <a href = "https://github.com/libav/gas-preprocessor"><a href="https://github.com/libav/gas-preprocessor">https://github.com/libav/gas-preprocessor</a></a></p>

<p>（1）拷贝gas-preprocessor.pl文件到 /usr/bin 目录下。</p>

<p>如果找不到/usr/bin目录，直接使用”Finder—>前往—> 前往文件夹—>/usr/bin”或者使用快捷键“shift+command+G”前往文件夹，到指定目录下粘贴gas-preprocessor.pl文件</p>

<p>（2）修改gas-preprocessor.pl文件的读写权限，使用 chmod a+rwxgas-preprocessor.pl</p>

<p>用终端命令cd定位到 gas-preprocessor.pl文件夹下执行：<code>chmod a+rwxgas-preprocessor.pl</code>命令</p>

<p>3、下载build-shell.sh脚本文件：</p>

<p>下载地址：<a href = "https://github.com/kewlbear/FFmpeg-iOS-build-script"><a href="https://github.com/kewlbear/FFmpeg-iOS-build-script">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></a></p>

<p>（1）下载解压build-shell.sh文件</p>

<p>（2）定位至build-shell.sh文件夹执行build-shell.sh脚本文件</p>

<p>使用方式有4种，我们可以根据特定的使用环境来执行对应的脚本，一般我们就直接执行：<code>./build-ffmpeg.sh</code></p>

<ul>
<li>To build everything:</li>
</ul>


<p><strong><code>./build-ffmpeg.sh</code></strong></p>

<ul>
<li>To build arm64 libraries：</li>
</ul>


<p><strong><code>./build-ffmpeg.sh arm64</code></strong></p>

<ul>
<li>To build fat libraries for armv7 and x86_64 (64-bit simulator)：</li>
</ul>


<p><strong><code>./build-ffmpeg.sh armv7 x86_64</code></strong></p>

<ul>
<li>To build fat libraries from separately built thin libraries:</li>
</ul>


<p><strong><code>./build-ffmpeg.sh lipo</code></strong></p>

<p>注：我的build-shell.sh是解压放至Desktop的，以上四种shell脚本的使用方式来自<a href = "https://github.com/kewlbear/FFmpeg-iOS-build-script"><a href="https://github.com/kewlbear/FFmpeg-iOS-build-script">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></a>，后面几种方式大家可以自己去尝试。</p>

<p>4、脚本执行完成之后，会在桌面上生成三个文件夹：“FFmpeg-iOS”“scratch”和”thin”文件夹</p>

<p>scratch文件夹里面是单独编译的库，FFmpeg-iOS文件夹里面是合并编译的库。在使用的过程中，我们主要会用到FFmpeg-iOS 文件夹下的“include”文件夹和"lib"文件夹中的文件。</p>

<h3>二、在工程中使用FFmpeg，网上成熟的有kxmovie。</h3>

<p>1、下载kxmovie工程进行测试：</p>

<p>下载地址： <a href = "https://github.com/kolyvan/kxmovie"><a href="https://github.com/kolyvan/kxmovie">https://github.com/kolyvan/kxmovie</a></a></p>

<p>把FFmpeg编译出来的.a文件添加到工程中。</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37q81fp5j205r09xwfq.jpg" alt="" /></p>

<p>在使用的时候得注意添加下面的动态链接库文件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>libz.dylib
</span><span class='line'>libbz2.dylib
</span><span class='line'>libiconv.dylib</span></code></pre></td></tr></table></div></figure>


<p><strong>运行工程</strong></p>

<p>以下是在编译运行工程中可能会报的错误：</p>

<p>注意：如果在FFmpeg编译的时候出现“ffmpeg yasm not found，use &ndash;disable for a crippled build”，原因是 yasm是汇编编译器，因为FFmpeg中为了提高效率用到了汇编指令，解决这个问题有两种方法，一是下载一个yasm.exe安装在mingw/bin下面；二是不使用汇编指令，在配置上加上 即 ./configure &ndash;disable-yash 。(这就是为什么前面提到了要安装yasm)
成功通过编译（这里是指FFmpeg编译成静态库文件）</p>

<p>通过后会生成一个compiled(FFmpeg-iOS)的文件夹，里面有include和lib两个文件夹，这两个文件夹都要拷贝至工程目录下面。include是静态链接库要用到的头文件，lib是存放静态链接库的文件，然后把这些文件存放在项目里面即可，一定要把文件也copy进去，然后在项目的build settings中的header search paths字段加入include文件的路径 如：“$(SRCROOT)/ffmpeg/include” 前面的复选框选不选都可以；再在library search paths字段中加入a文件的路径 如：“$(SRCROOT)/ffmpeg/lib” 。否则可能会出现libavformat/avformat.h file not found 的错误。（出现这个错误是指编译kxmovie工程找不到相应的头文件）</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37rw3nknj20m207wwgg.jpg" alt="" /></p>

<p>上面图示：在工程目录下有个“FFmpeg”的文件夹，分别把编译FFmpeg完成后产生的“ FFmpeg-iOS ”文件夹中的“include”和”lib”文件夹拷贝至”FFmpeg”文件夹中，include文件夹中存放的是头文件，lib文件夹中存放的是.a静态库文件。最后就是在工程目录下的FFmpeg文件夹包含“include”和”lib”两个文件夹。设置Header Search Paths和Library Search Paths时直接include和lib两个文件夹拖上去，自动显示路径。</p>

<p><img src="http://ww4.sinaimg.cn/large/7f266405jw1ey37subv8hj20gu06omye.jpg" alt="" /></p>

<p>如果还出现找不到 avformat_open_input 的错误（我的没有出现过这个错误），说明你的ffmpeg还是太新了，之前的那个方法名已经改成了这个名字，把avformat_open_input改成av_open_input_file 就可以了。其他错误请自行谷歌或者留言，我们共同探讨。
上面报错总结文章来自：<a href="http://www.dnetzj.com/Content/267.html">http://www.dnetzj.com/Content/267.html</a></p>

<p>最后一步，别忘了安装kxmovie.xcworkspace的cocoapods</p>

<p><strong><code>pod install --verbose --no-repo-update</code></strong></p>

<p>否则会报链接错误</p>

<p>以上kxmovie工程编译调试完毕，模拟器真机都通过测试。目前没有进一步的去研究这个工程，发现播放的视频质量有点粗糙。有时间再做进一步的研究。</p>

<h3>三、iFrameExtractor-master（iFrameExtractor）工程编译和运行</h3>

<p>（1）运行iFrameExtractor-master工程，与上面kxmovie工程操作一样，把FFmpeg文件夹拷贝至工程目录下:
       (工程目录下本来是没有FFmpeg文件夹的)</p>

<p><img src="http://ww1.sinaimg.cn/large/7f266405jw1ey37tiypu8j20gx07b75s.jpg" alt="" /></p>

<p>iFrameExtractor-master下载地址：<a href="https://github.com/lajos/iFrameExtractor">https://github.com/lajos/iFrameExtractor</a></p>

<p>(2)设置好Header Search Paths和Library Search Paths</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37u3v6q5j20kj02x0ts.jpg" alt="" /></p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37v057v9j20kg07p40a.jpg" alt="" /></p>

<p>（3）最后还是会报链接错误：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Undefined symbols for architecture i386:
</span><span class='line'>"_iconv", referenced from:      
</span><span class='line'>    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)  
</span><span class='line'>"_iconv_close", referenced from:
</span><span class='line'>    _avcodec_open2 in libavcodec.a(utils.o)
</span><span class='line'>    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)
</span><span class='line'>"_iconv_open", referenced from:
</span><span class='line'>    _avcodec_open2 in libavcodec.a(utils.o)
</span><span class='line'>    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)
</span><span class='line'>ld: symbol(s) not found for architecture i386
</span><span class='line'>clang: error: linker command failed with exit code 1 (use -v to see invocation)</span></code></pre></td></tr></table></div></figure>


<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37vhigjfj20fq0a8djf.jpg" alt="" /></p>

<p><strong>解决办法："TARGETS" - > &ldquo;BuildSettings&rdquo; - > &ldquo;Other Linker Flags&rdquo; 添加other Linker Flags 项：-liconv</strong></p>

<p><img src="http://ww1.sinaimg.cn/large/7f266405jw1ey37wvjqv1j20dl01s74f.jpg" alt="" /></p>

<p>此报错问题出自：<a href = "http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851"><a href="http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851">http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851</a></a></p>

<p>至此完成iFrameExtractor-master工程编译和运行</p>

<h3>本文参考文章资料：</h3>

<ul>
<li><a href = "http://blog.csdn.net/oqqQuZi1234567/article/details/43152689">iOS－－kxmovie之FFmpeg编译和使用</a></li>
<li><a href = "http://www.th7.cn/Program/Ruby/201502/385491.shtml">iOS ffmpeg kxmovie 编译 调试</a></li>
</ul>


<p><strong>欢迎共同学习进步，本着分享的精神，只是为了让你学习起来更加轻松。</strong></p>

<p><strong>如需转载，请注明出处：<a href = "http://blog.csdn.net/yangshebing21/article/details/43986913"><a href="http://blog.csdn.net/yangshebing21/article/details/43986913">http://blog.csdn.net/yangshebing21/article/details/43986913</a></a></strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UICollectionView（纯代码方式）实现带上下拉刷新的瀑布流式（WaterFlow）布局]]></title>
    <link href="http://yangshebing.github.io/blog/2015/11/03/waterflow/"/>
    <updated>2015-11-03T22:40:32+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/11/03/waterflow</id>
    <content type="html"><![CDATA[<p>瀑布流（WaterFlow）是项目开发过程中的常见布局，有关于瀑布流（WaterFlow）的实现方式：在UICollectionView未出现之前，瀑布流的实现多半是采用UIScrollView或是UITableView。对于我们这种用惯了表视图的人来说，UICollectionView倒略显陌生。有关于UICollectionView的介绍我就不一一赘述，因为一两句话也很难说清楚。网上有很多优秀的文章专门对其进行了一系列的解说，另有苹果官方文档可以查阅。本文主要是介绍如何采用纯代码的方式利用UICollectionView实现带上下拉刷新的瀑布流式（WaterFlow）布局。废话少说，直接入题。</p>

<!--more-->


<h4>一、UICollectionView集成上下拉刷新</h4>

<p>（1）简单的介绍UICollectionView</p>

<p>UICollectionView和UITableView很相似，如果你对表视图非常熟悉，上手的速度也会快很多。使用它时需要相应的设置DataSource（UICollectionViewDataSoure)数据源协议和Delegate（UICollectionViewDelegate)事件协议，并实现相应的协议方法。它与UITableView不同的地方是它有UICollectionViewLayout，可以通过它的子类来定制布局。系统默认的布局方式是UICollectionViewDelegateFlowLayout，实现相应的协议（UICollectionViewDelegateFlowLayout）方法，便可达到默认布局效果。</p>

<p>UICollectionViewCell与UITableViewCell的使用也差不多，一样的有ReuseIdentifier,可以复用。使用UICollectionViewCell时，需要先注册，然后再出列使用。至于注册并出列使用Cell的具体方式，请自行下载文章末尾的BGWaterFlowView或者自行Google。</p>

<p>（2）集成上下拉刷新方式</p>

<p>一般UITableView添加上下拉刷新的方式，是把下拉或者上拉刷新视图的UI放置UITableView的表头属性(tableHeaderView)或者表尾属性（tableFooterView）。但是，在UICollectionView中没有这两个属性。那么我们该如何来集成上下拉刷新呢？这就得说到
UICollectionView布局中的三种显示内容视图：Cells、Supplementary views、Decoration views。(关于这三种视图的介绍可以去官网查阅相关文档，上面有详细的解释)。我们一般是把上下拉刷新的UI放置在Supplementary views（官方解释：它能显示数据但是不同于Cells。不像Cell,Supplementary views是不能被用户选定的。相反，你可以用它去实现类似于给一个指定的section或者整个CollectionView添加页眉和页脚视图这样的功能）上面，其实，Supplementary views就和TableView的section头视图和尾视图差不多。但是用法却大不相同。在自定义瀑布流布局中一定要把它也计算进去，不然显示就会有异常。</p>

<ul>
<li><strong>注册头视图和尾视图单元格类型</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//注册头视图：kind代表Supplementary视图类型，UICollectionElementKindSectionHeader表示组头
</span><span class='line'>
</span><span class='line'>[self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"bGCollectionHeaderView"];
</span><span class='line'>
</span><span class='line'>//注册尾视图：UICollectionElementKindSectionHeader表示组尾
</span><span class='line'>
</span><span class='line'>    [self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"bGCollectionFooterView"];
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>实现自定义组视图viewForSupplementaryElementOfKind代理方法</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath {
</span><span class='line'>
</span><span class='line'>  //kind代表Supplementary视图类型：头或尾视图（header OR footer）
</span><span class='line'>  
</span><span class='line'>    if([kind isEqual:UICollectionElementKindSectionHeader]) {
</span><span class='line'>        UICollectionReusableView *collectionHeaderView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"bGCollectionHeaderView" forIndexPath:indexPath];
</span><span class='line'>        
</span><span class='line'>        //初始化下拉刷新或者自定义页眉视图UI界面
</span><span class='line'>        ...
</span><span class='line'>        
</span><span class='line'>        return collectionHeaderView;
</span><span class='line'>    } else if([kind isEqual:UICollectionElementKindSectionFooter]) {
</span><span class='line'>        UICollectionReusableView *collectionFooterView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"bGCollectionFooterView" forIndexPath:indexPath];
</span><span class='line'>        
</span><span class='line'>        //初始化上拉刷新或者自定义页脚视图UI界面
</span><span class='line'>        ...
</span><span class='line'>        
</span><span class='line'>        return collectionFooterView;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return nil;
</span><span class='line'>}
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<p>完成以上两步，集成上下拉刷新的功能总算完成了。接下来你可以运行一下工程，看结果是否符合预期。如果你CollectionView使用的是系统的UICollectionViewFlowLayout布局，一定要返回组头或者组尾的高度，否则就会出现组头或者组尾无法显示（本文的下拉刷新视图所在的组头不返回高度不受影响，是因为它的纵坐标（y值）本来就是负数）。另外，还有一点需要注意的是，如果你的CollectionView中存在多组，最好是把上下拉刷新所在的组头或者组尾与其他组（section）的组头或组尾分开，相应的需要多注册一个组头或者组尾视图，分情况进行判断(这部分如果还有问题，可以在文章末尾留言，我会及时回复)。</p>

<h4>二、自定义瀑布流（WaterFlow）式布局</h4>

<p>（1）简单的介绍UICollectionView布局形式</p>

<p>一般来讲，UICollectionView的布局形式分为两种：</p>

<ul>
<li><p>布局与内容独立，其布局不需要根据显示的单元格内容来计算。Cell的显示顺序与内容顺序一致。Cell排满一行则换至下一行继续排列。系统的UICollectionViewFlowLayout就是这样。</p></li>
<li><p>布局需要计算内容，本文的瀑布流Demo局部正是如此。UICollectionViewFlowLayout系统布局在换行的时候，由于每个item高度不同，从而导致布局错乱，无法满足你的需求。所以，这个时候你需要计算每个item的高度，最终用来确定item显示的位置。</p></li>
</ul>


<p>从上述内容我们可以看出，一般如果布局需要计算内容的时候，我们就不应该直接使用UICollectionViewFlowLayout布局了，而是应该子类化一个UICollectionViewLayout，从而达到私人定制的目的。</p>

<p>（2）创建自定义布局</p>

<p><a href = "https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/CreatingCustomLayouts/CreatingCustomLayouts.html#//apple_ref/doc/uid/TP40012334-CH5-SW1">官方文档</a>中有提到，在布局的过程中，CollectionView会调用布局对象的具体方法。这些方法有机会使你计算这些项的位置以及给CollectionView提供它所需要的主要信息。其他的方法也有可能会被调用，但是在布局的过程中这些方法总是会按照以下的顺序调用：</p>

<ol>
<li>使用"prepareLayout"方法去执行一些CollectionView所需要的布局信息的预先计算操作。</li>
<li>使用"collectionViewContentSize"方法去返回根据你最初计算的整个内容区域的总体大小。</li>
<li>使用"layoutAttributesForElementsInRect:&ldquo;方法来返回指定区域的单元格与视图属性。</li>
</ol>


<p>下面我们通过Demo来详细的讲解一下如何自定义瀑布流，废话不多说，直接上代码（本文采用的Demo为<strong>BGWaterFlowView</strong>,<strong>GitHub传送门</strong>：<a href = 'https://github.com/yangshebing/BGWaterFlowView'>请点击这里</a>）：</p>

<ul>
<li><strong>重写"prepareLayout"方法计算布局信息。</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)prepareLayout{
</span><span class='line'>    [super prepareLayout];
</span><span class='line'>    ...
</span><span class='line'>    
</span><span class='line'>    //计算每个显示项的宽度，horizontalItemSpacing代表项与项之间的水平间隔， 
</span><span class='line'>    columnNum代表总列数，contentInset代表上下左右的内填充。详见下图说明
</span><span class='line'>    
</span><span class='line'>    self.itemWidth = (self.collectionView.frame.size.width - (self.horizontalItemSpacing * (self.columnNum - 1)) - self.contentInset.left - self.contentInset.right) / self.columnNum;
</span><span class='line'>    
</span><span class='line'>    //如有下拉刷新需求的则需要提供头视图（Supplementary view）布局属性。
</span><span class='line'>    demo中的headerHeight属性可设置是否显示头视图（是否计算头视图的布局属性）。
</span><span class='line'>    
</span><span class='line'>    if(self.headerHeight &gt; 0){
</span><span class='line'>    
</span><span class='line'>    //通过layoutAttributesForSupplementaryViewOfKind:withIndexPath:方法来创建Supplementary视图布局属性对象，kind用来区分Supplementary视图类型（header或者footer）。
</span><span class='line'>    
</span><span class='line'>        self.headerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionHeader withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];
</span><span class='line'>        
</span><span class='line'>        //修改布局参数frame属性
</span><span class='line'>        
</span><span class='line'>        self.headerLayoutAttributes.frame = CGRectMake(0, 0, self.collectionView.frame.size.width, self.headerHeight);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //初始化保存布局属性的字典
</span><span class='line'>    NSMutableDictionary *cellLayoutInfoDic = [NSMutableDictionary dictionary];
</span><span class='line'>    //初始化列高数组
</span><span class='line'>    NSMutableArray *columnInfoArray = [self columnInfoArray];
</span><span class='line'>    NSInteger numSections = [self.collectionView numberOfSections];
</span><span class='line'>    for(NSInteger section = 0; section &lt; numSections; section++)  {
</span><span class='line'>        NSInteger numItems = [self.collectionView numberOfItemsInSection:section];
</span><span class='line'>        for(NSInteger item = 0; item &lt; numItems; item++){
</span><span class='line'>            //获取列高最小的model，以它的高作为y坐标
</span><span class='line'>            BGWaterFlowModel *firstModel = columnInfoArray.firstObject;
</span><span class='line'>            CGFloat y = firstModel.height;
</span><span class='line'>            CGFloat x = self.contentInset.left + (self.horizontalItemSpacing + self.itemWidth) * firstModel.column;
</span><span class='line'>            
</span><span class='line'>            NSIndexPath *indexPath = [NSIndexPath indexPathForItem:item inSection:section];
</span><span class='line'>            
</span><span class='line'>            //通过代理方法传入对应item的高度。
</span><span class='line'>            
</span><span class='line'>            CGFloat itemHeight = [((id&lt;BGWaterFlowLayoutDelegate&gt;)self.collectionView.delegate) collectionView:self.collectionView layout:self heightForItemAtIndexPath:indexPath];
</span><span class='line'>            
</span><span class='line'>            //通过layoutAttributesForCellWithIndexPath:方法来创建cell的布局属性对象。
</span><span class='line'>            
</span><span class='line'>            UICollectionViewLayoutAttributes *itemAttributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];
</span><span class='line'>            //计算item的布局属性
</span><span class='line'>            itemAttributes.frame = CGRectMake(x, y+self.contentInset.top+self.headerHeight, self.itemWidth, itemHeight);
</span><span class='line'>            //计算当前列高,verticalItemSpacing代表项与项之间的垂直间隔。
</span><span class='line'>            firstModel.height += (itemHeight + self.verticalItemSpacing);
</span><span class='line'>            //保存新的列高，并进行排序：从后往前查找，查找到高度比它小的对象，就插入到该对象之后。
</span><span class='line'>            [self sortArrayByHeight:columnInfoArray];
</span><span class='line'>            
</span><span class='line'>     //保存计算好的item布局属性
</span><span class='line'>     cellLayoutInfoDic[indexPath] = itemAttributes;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //保存局部布局属性字典到全局字典中
</span><span class='line'>    self.cellLayoutInfoDic = [cellLayoutInfoDic copy];
</span><span class='line'>    
</span><span class='line'>    //按照前面的排序逻辑，列高数组中的最后一个元素，就是高度最大的一列。
</span><span class='line'>    BGWaterFlowModel *lastModel = columnInfoArray.lastObject;
</span><span class='line'>    
</span><span class='line'>    //如有上拉刷新需求的则需要提供尾视图布局属性。
</span><span class='line'>    demo中的footerHeight属性可设置是否显示尾视图（是否计算尾视图的布局属性）。
</span><span class='line'>    
</span><span class='line'>    if(self.footerHeight &gt; 0){
</span><span class='line'>        self.footerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionFooter withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];
</span><span class='line'>        //计算尾视图的布局属性
</span><span class='line'>        self.footerLayoutAttributes.frame = CGRectMake(0, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom, self.collectionView.frame.size.width, self.footerHeight);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //直接计算出collectionView的contentSize
</span><span class='line'>    self.contentSize = CGSizeMake(self.collectionView.frame.size.width, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom+self.footerHeight);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p><strong>好吧，这么一大坨代码看到就头疼了，来张图帮助理解一下！图糙理不糙，理解万岁</strong>
<img src="http://ww4.sinaimg.cn/mw690/7f266405jw1ey25ujzticj218a0xmjww.jpg" alt="" /></p>

<p><strong>这样看上去是不是更清晰了？</strong></p>

<ul>
<li><strong>重写"collectionViewContentSize"方法返回collectionView的内容高度。</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (CGSize)collectionViewContentSize{
</span><span class='line'>  //返回计算好的collectionView内容高度
</span><span class='line'>    return self.contentSize;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>重写"layoutAttributesForElementsInRect"方法返回指定矩形区域中的cell或者其他类型视图布局属性。</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect {
</span><span class='line'>
</span><span class='line'>  //返回一组已经计算好的布局属性。
</span><span class='line'>  
</span><span class='line'>    NSMutableArray *attributesArrs = [NSMutableArray array];
</span><span class='line'>    [self.cellLayoutInfoDic enumerateKeysAndObjectsUsingBlock:^(NSIndexPath *indexPath,
</span><span class='line'>                                                                UICollectionViewLayoutAttributes *attributes,
</span><span class='line'>                                                                BOOL *stop) { 
</span><span class='line'>        //遍历布局属性保存字典，添加布局属性至数组中                                                       
</span><span class='line'>        if (CGRectIntersectsRect(rect, attributes.frame)) {
</span><span class='line'>            [attributesArrs addObject:attributes];
</span><span class='line'>        }
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    //如果有头视图或者尾视图则需要添加头视图与尾视图的布局属性
</span><span class='line'>    
</span><span class='line'>    if (self.headerLayoutAttributes && CGRectIntersectsRect(rect, self.headerLayoutAttributes.frame)) {
</span><span class='line'>        [attributesArrs addObject:self.headerLayoutAttributes];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    
</span><span class='line'>    if (self.footerLayoutAttributes && CGRectIntersectsRect(rect, self.footerLayoutAttributes.frame)) {
</span><span class='line'>        [attributesArrs addObject:self.footerLayoutAttributes];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return attributesArrs;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>结语：</h4>

<p><a href = "https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/index.html#//apple_ref/occ/cl/UICollectionViewLayout">UICollectionViewLayout</a>相关的内容姿势非常多，相关文章也非常多。本文介绍的瀑布流布局也只是其中的冰山一角，很多东西官方文档中已经介绍的非常详细了。所以，还是建议多看官方文档。本文主要注重项目的实用性，在后面就直接上代码了，可能在理论方面还是有所欠缺，对于不足的地方，希望大家多提建议，一起交流学习，一起进步。如果文中有看不懂的地方，还请您留言。我会及时进行回复。最后，本文的Demo就在于方便徒手撸代码的人使用。你懂的。后期会不断的更新优化，进一步的完善。敬请期待&hellip;</p>

<p>点击此处下载本文的Demo:<a href = 'https://github.com/yangshebing/BGWaterFlowView'><strong>BGWaterFlowView</strong></a></p>

<p>Demo使用方式详见:<a href = "https://github.com/yangshebing/BGWaterFlowView/blob/master/README.md"><strong>README.md</strong></a></p>

<p>Demo运行瀑布流效果截图如下所示:</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey0z6x4xf9j20ku12aqb5.jpg"/ width = "375" height = "677" align = "center"></p>

<h6>参考博客地址：</h6>

<ul>
<li><a href = "http://objccn.io/issue-3-3/">自定义 Collection View 布局</a></li>
</ul>


<p>转载请注明出处</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS绘制虚线方式总结]]></title>
    <link href="http://yangshebing.github.io/blog/2015/10/12/ioshui-zhi-xu-xian-fang-shi-zong-jie/"/>
    <updated>2015-10-12T23:44:28+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/10/12/ioshui-zhi-xu-xian-fang-shi-zong-jie</id>
    <content type="html"><![CDATA[<h3>一、iOS中绘制虚线常见的几种方式：</h3>

<p>1、重写drawRect方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)drawRect:(CGRect)rect
</span><span class='line'>{
</span><span class='line'>    [super drawRect:rect];
</span><span class='line'>CGContextRef currentContext = UIGraphicsGetCurrentContext();
</span><span class='line'>//设置虚线颜色
</span><span class='line'>    CGContextSetStrokeColorWithColor(currentContext, [UIColor BlackColor].CGColor);
</span><span class='line'>    //设置虚线宽度
</span><span class='line'>    CGContextSetLineWidth(currentContext, 1);
</span><span class='line'>    //设置虚线绘制起点
</span><span class='line'>    CGContextMoveToPoint(currentContext, 0, 0);
</span><span class='line'>    //设置虚线绘制终点
</span><span class='line'>    CGContextAddLineToPoint(currentContext, self.frame.origin.x + self.frame.size.width, 0);
</span><span class='line'>    //设置虚线排列的宽度间隔:下面的arr中的数字表示先绘制3个点再绘制1个点
</span><span class='line'>    CGFloat arr[] = {3,1};
</span><span class='line'>    //下面最后一个参数“2”代表排列的个数。
</span><span class='line'>    CGContextSetLineDash(currentContext, 0, arr, 2);
</span><span class='line'>    CGContextDrawPath(currentContext, kCGPathStroke);
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>2、采用CAShapeLayer方式绘制虚线</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CAShapeLayer *shapeLayer = [CAShapeLayer layer];
</span><span class='line'>[shapeLayer setBounds:self.bounds];
</span><span class='line'>[shapeLayer setPosition:CGPointMake(self.frame.size.width / 2.0, self.frame.size.height)];
</span><span class='line'>[shapeLayer setFillColor:[UIColor clearColor].CGColor];
</span><span class='line'>//设置虚线颜色
</span><span class='line'>shapeLayer setStrokeColor:[UIColor BlackColor].CGColor];
</span><span class='line'>//设置虚线宽度
</span><span class='line'>[shapeLayer setLineWidth:self.frame.size.height];
</span><span class='line'>[shapeLayer setLineJoin:kCALineJoinRound];
</span><span class='line'>//设置虚线的线宽及间距
</span><span class='line'> [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:3], [NSNumber numberWithInt:1], nil]];
</span><span class='line'> //创建虚线绘制路径
</span><span class='line'> CGMutablePathRef path = CGPathCreateMutable();
</span><span class='line'> //设置虚线绘制路径起点
</span><span class='line'> CGPathMoveToPoint(path, NULL, 0, 0);
</span><span class='line'> //设置虚线绘制路径终点
</span><span class='line'> CGPathAddLineToPoint(path, NULL, self.frame.size.width, 0);
</span><span class='line'> //设置虚线绘制路径
</span><span class='line'> [shapeLayer setPath:path];
</span><span class='line'> CGPathRelease(path);
</span><span class='line'> //添加虚线
</span><span class='line'> [self.layer addSublayer:shapeLayer];
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<h5>关于这种方式已经有人整理出了一个非常好用的类方法，具体请参看文章末尾的参考博客地址：“iOS绘制虚线方法【原创】”一文，此方法使用起来非常简单方便。</h5>

<h6><strong><font color="red">注意：下面非完整代码，如有需要，请自行前往该博文中直接复制使用。</font></strong></h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> ** lineView:       需要绘制成虚线的view
</span><span class='line'> ** lineLength:     虚线的宽度
</span><span class='line'> ** lineSpacing:    虚线的间距
</span><span class='line'> ** lineColor:      虚线的颜色
</span><span class='line'> **/
</span><span class='line'> 
</span><span class='line'>+ (void)drawDashLine:(UIView *)lineView lineLength:(int)lineLength lineSpacing:(int)lineSpacing lineColor:(UIColor *)lineColor
</span><span class='line'>{
</span><span class='line'>    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
</span><span class='line'>    .....
</span><span class='line'>    [shapeLayer setStrokeColor:lineColor.CGColor];
</span><span class='line'>    ......
</span><span class='line'>    [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:lineLength], [NSNumber numberWithInt:lineSpacing], nil]];
</span><span class='line'>  　......
</span><span class='line'>    [lineView.layer addSublayer:shapeLayer];
</span><span class='line'>    
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>3、经济实惠型：采用贴图的方式绘制虚线（需要设计师切图配合）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIImageView *imgDashLineView =[[UIImageView alloc] initWithFrame:CGRectMake(15, 200, self.view.frame.size.width - 30, 1)];
</span><span class='line'>
</span><span class='line'>[imgDashLineView setBackgroundColor:[UIColor colorWithPatternImage:[UIImage imageNamed:@"xuxian.png"]]];
</span><span class='line'>
</span><span class='line'>[self.view addSubview:imgDashLineView];
</span></code></pre></td></tr></table></div></figure>


<p>在以上这几种方式中我个人比较偏爱最后一种，简单粗暴。</p>

<p>以上内容部分来自于网络，本着分享的学习精神，如有涉及侵权问题，请及时告知。欢迎一起探讨学习，有问题请留言。我将会在第一时间对你的问题进行回复。如需转载，请注明出处。</p>

<h6>参考博客地址：</h6>

<ul>
<li>1、<a href="http://blog.it985.com/14080.html">iOS绘制虚线方法【原创】</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于GitHub搭建Octopress个人技术博客(Mac版)]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/17/test/"/>
    <updated>2015-09-17T23:42:42+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/17/test</id>
    <content type="html"><![CDATA[<h6>作为一名屌逼的程序猿，肯定是要有一个屌逼的技术博客。在交流学习的同时，顺便见证自己成长的心路历程。废话不多说，直接进入正题。编程讲究的四门功课，“说，学，逗，唱”。不会就学嘛！没有就找嘛！网上相关的文章简直太多了！其中原理就不多说，我且按照我搭建的顺序写一下步骤吧！</h6>

<p><strong>注意事项：在搭建之前，检查MAC电脑是否已经安装了Git和Ruby 1.9.3及以上版本。（Mac默认均已自带，ruby请自行检查版本：ruby &ndash;version，如果缺少，当自行下载）</strong></p>

<h4>一、开始安装octopress</h4>

<!--more-->


<p>1、将Octopress从github上clone到本地</p>

<pre><code class="`">git clone git://github.com/imathis/octopress.git octopress
cd octopress
</code></pre>

<p>2、安装Octopress</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem install bundler
</span><span class='line'>bundle install
</span><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>


<p>如果当你执行“bundle install”这步失败了，请更改一下本地octopress文件夹下Gemfile文件当中的源（路径：/Users/用户名/octopress/Gemfile），将文件中的<code>source "https://rubygems.org"</code>更换成 <code>source "http://ruby.taobao.org/"</code>,然后保存文件再重新执行bundle install及其后续操作。</p>

<p>3、部署GitHub Pages
在CitHub中新建一个名为username.github.io的仓库（username为你的GitHub用户名）。</p>

<ul>
<li>开始配置GitHub Pages</li>
</ul>


<p>在终端继续输入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages</span></code></pre></td></tr></table></div></figure>


<p>在Repository url后面粘贴username.github.io仓库对应的url地址</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Enter the read/write url for your repository
</span><span class='line'>(For example, 'git@github.com:your_username/your_username.github.io.git)
</span><span class='line'>           or 'https://github.com/your_username/your_username.github.io')
</span><span class='line'>Repository url: </span></code></pre></td></tr></table></div></figure>


<p>把上面代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>https://github.com/your_username/your_username.github.io”
</span><span class='line'>或者
</span><span class='line'>“git@github.com:your_username/your_username.github.io.git</span></code></pre></td></tr></table></div></figure>


<p>中的your_username替换成自己GitHub用户名即可。（两种地址，前者是HTTPS地址，后者是SSH地址，任选一个粘贴即可）</p>

<p>现在可以开始生成自己的第一篇博客并部署放至GitHub上。
在终端输入以下命令：生成一篇新的博客</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post['test']</span></code></pre></td></tr></table></div></figure>


<p>其中test是默认的博客标题（当然博客的标题可以在markdown文件里面更改）。当然你也可以输入rake new_post命令，按照终端的提示输入博客的标题。生成完成的文章内容在octopress/source/_posts目录下。文件名为时间＋标题名，如“2015-09-17-test.markdown”。可以用markdown工具（本文用的markdown工具为“Mou”）进行编辑与修改。</p>

<p>接下来在终端输入rake generate命令生成静态文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate</span></code></pre></td></tr></table></div></figure>


<p>在部署到GitHub上之前，你可以在本地预览一下博客的效果。
先在终端输入rake preview命令，生成预览blog。然后在浏览器中输入<code>http://localhost:4000</code>查看博客的预览效果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake preview</span></code></pre></td></tr></table></div></figure>


<p>在终端退出预览效果：ctrl+c</p>

<p>确认效果之后，开始部署至GitHub。rake deploy命令会将octopress/public目录下的文件上传至仓库的master分支。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<p>最后一步，将Octopress的源码提交至GitHub</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m 'commit source file'
</span><span class='line'>git push origin source</span></code></pre></td></tr></table></div></figure>


<p>完工，屌逼的第一篇博客就已经发布到GitHub Pages上了。你现在可以输入:username.github.io在线查看自己的博客了（如：yangshebing.github.io）。</p>

<p>至于其中的相关原理分析我就不一一赘述了。请参看文章末尾的参考文章链接或者自行网上搜索。</p>

<h4>二、简单的配置Octopress</h4>

<h6>1、修改Octopress的配置文件（路径：octopress/_config.yml）</h6>

<ul>
<li>设置博客的标题，子标题以及作者相关信息。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>title: 杨社兵的技术博客
</span><span class='line'>subtitle: 业精于勤荒于嬉，行成于思毁于随.
</span><span class='line'>author: 杨社兵</span></code></pre></td></tr></table></div></figure>


<ul>
<li>删除twitter相关信息（GFW造成页面加载慢）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Twitter
</span><span class='line'>twitter_user:
</span><span class='line'>twitter_tweet_button: true</span></code></pre></td></tr></table></div></figure>


<ul>
<li>修改source/_includes目录下的head.html文件：将<code>//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.jst</code>替换成<code>http://cdn.staticfile.org/jquery/1.9.1/jquery.min.jst</code>（解决页面加载过慢问题）</li>
<li>修改source/_includes/custom目录下的自定义head.html文件，去掉google自定义字体（解决页面加载过慢问题）</li>
</ul>


<h6>2、添加统计工具（百度统计）</h6>

<p>去<a href="http://tongji.baidu.com">百度统计</a>官网申请一个账号，在管理界面选择“代码获取”，复制代码至<code>source/_includes/custom/footer.html</code>文件中。</p>

<h6>3、自定义博客导航栏</h6>

<p>部署好博客之后，你会发现导航栏上默认的只有两项：Blog、Archives，无法满足我们的需求。比如我们想在导航栏上添加一个选项为“关于我”。</p>

<p>打开“/source/_includes/custom”目录的navigation.html文件进行编辑：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*&lt;ul class="main-navigation"&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://yangshebing.github.io/"&gt;我的博客&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://yangshebing.github.io/blog/archives"&gt;所有文章&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://weibo.com/yangshebing" target="_blank"&gt;新浪微博&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://yangshebing.github.io/about"&gt;关于我&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span></code></pre></td></tr></table></div></figure>


<p>接下来在终端输入rake new_page命令，生成一个index.markdown文件，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_page['about']</span></code></pre></td></tr></table></div></figure>


<p>它的默认保存路径是：“source/about/index.markdown”，编辑index.markdown文件，即可定制“关于我”页面内容。</p>

<h6>4、关于博客的评论和分享到微博功能，请参考末尾文章链接《象写程序一样写博客：搭建基于github的博客》一文。</h6>

<p>参考文章链接：</p>

<p>（1）<a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/" target="_blank">象写程序一样写博客：搭建基于github的博客</a></p>

<p>（2）<a href="http://matrixzk.github.io/blog/20141020/octopress-setup-and-analysis/#section" target="_blank">使用 Octopress 2.0 搭建基于 Github Pages 个人博客的详细过程及原理分析</a></p>

<p>（3）<a href="http://www.jianshu.com/p/0ac2ac1a8e45" target="_blank">octopress博客搭建和个性化配置</a></p>

<p>（4）<a href="https://liuchungui.github.io/blog/2015/09/11/macdian-nao-shang-da-jian-octopressbo-ke/" target="_blank">Mac电脑上搭建octopress博客</a></p>

<p>（5）<a href="http://www.cnblogs.com/sawyerzhu/p/3710374.html" target="_blank">Mac环境下octopress个人博客搭建</a></p>

<p>（6）<a href="http://foggry.com/blog/2014/04/28/custom-your-octopress-blog/" target="_blank">自定义你的Octopress博客</a></p>

<p>（7）<a href="http://blog.devtang.com/blog/2014/06/02/use-gitcafe-to-host-blog/" target="_blank">将博客从GitHub迁移到GitCafe</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中点击状态栏让滑动视图回到顶部]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/13/arcticle/"/>
    <updated>2015-09-13T23:28:31+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/13/arcticle</id>
    <content type="html"><![CDATA[<h6>在产品开发过程中，有时候会有这种需求，需要点击状态栏让滑动视图（UIScrollView）或者表视图（UITableView）返回到顶部，让用户可以更快的浏览最新的信息。</h6>

<h6>这个时候我们需要设置滑动视图的scrollsToTop属性，让它决定点击状态栏是否返回顶部。</h6>

<!--more-->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// When the user taps the status bar, 
</span><span class='line'>the scroll view beneath the touch which is closest to the status bar will be scrolled to top,
</span><span class='line'> but only if its scrollsToTop property is YES, 
</span><span class='line'> its delegate does not return NO from shouldScrollViewScrollToTop,
</span><span class='line'>  and it is not already at the top. 
</span><span class='line'>// On iPhone, we execute this gesture only if there’s one on-screen scroll view with scrollsToTop == YES.
</span><span class='line'> If more than one is found, none will be scrolled.
</span><span class='line'>@property(nonatomic) BOOL scrollsToTop; // default is YES.</span></code></pre></td></tr></table></div></figure>


<h6>设置这个属性，可以让点击状态栏不返回顶部。如果我们需要让它点击状态栏回到顶部，我们可以把这个属性值设置为YES（默认为YES）。按正常情况来说，这个时候点击状态栏是可以返回到顶部。但是点击状态栏还是没有反应怎么办？</h6>

<h6>解决方法如下：</h6>

<h6>按照上面官方文档的说法，只有把当前主控制器需要设置的那个scrollview找到并把它的scrollsToTop属性设置为YES，然后再把其他scrollview的scrollsToTop属性设置为NO 。这样它才会响应这个事件。其中的原理非常简单，如果当前主控制器中有2个scrollview，系统压根就不知道你想要其中的哪个scrollview滑动到顶部。</h6>

<h6>举个栗子：</h6>

<ul>
<li>假设当前控制器中有三个表视图（UITableView）或者滑动视图(UIScrollView)要切换，把当前显示的滑动视图scrollsToTop属性设置为YES,其他滑动视图的scrollsToTop属性设置为NO即可。</li>
</ul>


<p><strong>注意：如果当前滑动视图中存在子视图也是滑动视图的情况，那么它子视图中的滑动视图scrollsToTop属性也要设置为NO，不然它仍然会造成点击状态栏无法响应返回到顶部操作。</strong></p>

<h6>参考博客地址：</h6>

<ul>
<li><a href="http://blog.sina.com.cn/s/blog_463dc5b90101k9ib.html">点击状态栏不返回顶部问题</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift语言编程]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/12/swift/"/>
    <updated>2015-09-12T12:53:21+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/12/swift</id>
    <content type="html"><![CDATA[<h4>Swift语言基础学习</h4>

<ul>
<li>导入系统类库头文件（swift中称之为模块）</li>
</ul>


<p><code>
import UIKit
</code></p>

<ul>
<li>定义一个常量</li>
</ul>


<p><code>
let a = 5
</code></p>

<ul>
<li>定义一个变量</li>
</ul>


<p><code>
var str = "Hello, World!"
</code></p>

<ul>
<li>swift中打印输出</li>
</ul>


<p><code>
print("Hi,Girl!");
</code></p>

<p><strong>注意事项：如果在一行内想要写多条语句时需要用分号隔开，一行内写一句代码分号可加可不加（不推荐加）</strong></p>

<!--more-->


<p><code>
//一行内多句代码
let dog = "ddd";print(dog)
</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//一行内一句代码
</span><span class='line'>let my = "我的"
</span><span class='line'>let age = 20
</span><span class='line'>let sex = "male"
</span><span class='line'>print(my)
</span><span class='line'>print(age)
</span><span class='line'>print(sex)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>一次性定义多个变量</li>
</ul>


<p><code>
var a = 0.0, b = 0.0, c = 0.0
</code></p>

<ul>
<li>定义变量并赋初值</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var a : Float = 5;
</span><span class='line'>var userName = "yangshebing"</span></code></pre></td></tr></table></div></figure>


<ul>
<li>字符串插值方式：相当于占位符输出</li>
</ul>


<p><code>
print("the user name is \(userName)”)
</code></p>

<ul>
<li>定义一个指定类型的变量</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var name : String
</span><span class='line'>name = "yangshebing";
</span><span class='line'>print(name);</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：在Swift中支持多行注释嵌套</strong></p>

<ul>
<li>定义一个数组</li>
</ul>


<p>最简单粗暴的方法：</p>

<p><code>
let array = ["a", "b", "c"]
</code></p>

<p>常规写法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let array1: [String] = ["A", "B", "C"]
</span><span class='line'>let array2: Array&lt;String&gt; = ["A", "B", "D”]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>整数和浮点数之间转换</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let num = 3
</span><span class='line'>let pointNum = 0.14159
</span><span class='line'>let pi = Double(num) + pointNum
</span><span class='line'>let numPi = Int(pi)
</span><span class='line'>//Float转换成Int类型时，实型值总是会被缩短，意味着4.75将会变成4, -3.9将会变成-3
</span><span class='line'>print(numPi)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>自定义类型别名</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typealias MyIntType = Int
</span><span class='line'>let num : MyIntType = 10</span></code></pre></td></tr></table></div></figure>


<ul>
<li>布尔</li>
</ul>


<p>Swift 有一个基本布尔类型，称之为Bool。它提供了两个布尔常量值:true和false</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let isMore = true
</span><span class='line'>let isRainy = false</span></code></pre></td></tr></table></div></figure>


<ul>
<li>布尔类型在if语句中的使用</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let isApple = true
</span><span class='line'>if isApple {
</span><span class='line'>    println("this is Apple")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>使用布尔类型应当注意事项：Swift的类型安全机制会防止non-Boolean代替Bool值，比如下面的代码就会报编译时错误：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let num = 1
</span><span class='line'>if num {
</span><span class='line'>  //这个例子编译的时候会报错，但是在Objective-C语言中不会。
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>正确使用的方式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let number = 1
</span><span class='line'>if number == 1 {
</span><span class='line'>    println("this is one")
</span><span class='line'>    //这个编译成功
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>另外，这里提一下：在Swift中判断两个对象是否相等是使用”===“”!=="</p>

<ul>
<li>Swift中元组的使用</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//定义一个元组
</span><span class='line'>let salaryCombination = （10000, "one month"）
</span><span class='line'>//它代表的是一个（Int, String）类型的元组</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//分解元组
</span><span class='line'>let (salary, month) = salaryCombination
</span><span class='line'>print("The salary is \(salary)")
</span><span class='line'>print("The month is \(month)")
</span><span class='line'>//你如果只需要元组的一部分值，你也可以这样写
</span><span class='line'>let (salary,_)
</span><span class='line'>print(the salary is \(salary))</span></code></pre></td></tr></table></div></figure>


<ul>
<li>元组取值方式总结</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>方式一
</span><span class='line'>let firstSalary = (10000, "one month")
</span><span class='line'>let (salary1,month1) = firstSalary
</span><span class='line'>let secondSalary = (20000,"two month")
</span><span class='line'>let (salary2, month2) = secondSalary
</span><span class='line'>print("一月收入month1: \(salary1)")
</span><span class='line'>print("二月收入month2: \(salary2)”)
</span><span class='line'>
</span><span class='line'>//方式二
</span><span class='line'>let firstSalary = (10000, "one month")
</span><span class='line'>let (salary1,month1) = firstSalary
</span><span class='line'>let secondSalary = (20000,"two month")
</span><span class='line'>let (salary2, month2) = secondSalary
</span><span class='line'>//输出元组中的第0个元素， firstSalary.0：firstSalary代表元组名，0代表下标
</span><span class='line'>print("一月的收入month1: \(firstSalary.0)")
</span><span class='line'>print("二月的收入month2: \(secondSalary.0)”)
</span><span class='line'>
</span><span class='line'>//方式三
</span><span class='line'>let firstSalary = (salary : 10000,month : "one month")
</span><span class='line'>let (salary1,month1) = firstSalary
</span><span class='line'>let secondSalary = (salary :20000,month : "two month")
</span><span class='line'>let (salary2, month2) = secondSalary
</span><span class='line'>//输出元组中的第0个元素， firstSalary.salary：firstSalary代表元组名，salary代表元组元素的名字
</span><span class='line'>print("一月的收入month1: \(firstSalary.salary)")
</span><span class='line'>print("二月的收入month2: \(secondSalary.salary)")</span></code></pre></td></tr></table></div></figure>


<h4>本文参考文章资料：</h4>

<ul>
<li>《The Swift Programming Language》</li>
</ul>


<p><strong>欢迎共同学习进步，本着分享的精神，只是为了让你学习起来更加轻松。</strong></p>

<p><strong>如需转载，请注明出处</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态限制UITextField或UITextView用户输入中英文混编字数统计]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/12/test/"/>
    <updated>2015-09-12T11:31:37+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/12/test</id>
    <content type="html"><![CDATA[<p><strong>动态限制用户输入字数，这个在很多app中都会涉及，由于NSString的Length属性获取的长度中英文都是一个字节，不满足一个汉字两个字节、一个字符一个字节的需求。网上的方法大致是以下两种：</strong></p>

<h6>1、使用Unicode编码把OC中的NSString字符串转换成C的字符串。然后对字符串遍历进行统计长度。</h6>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>-  (int)convertToInt:(NSString*)strtemp {  
</span><span class='line'>    int strlength = 0;
</span><span class='line'>    char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding];
</span><span class='line'>    for (int i=0 ; i&lt;[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding];i++) {
</span><span class='line'>        if (*p) {
</span><span class='line'>            p++;
</span><span class='line'>            strlength++;
</span><span class='line'>        }
</span><span class='line'>        else {
</span><span class='line'>            p++;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return strlength;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h6>2、直接计算OC中的NSString字符串中单词的个数</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSInteger)countWordWithStr:(NSString *)s
</span><span class='line'>{
</span><span class='line'>    NSInteger i,n=[s length],l=0,a=0,b=0;
</span><span class='line'>    unichar c;
</span><span class='line'>    for(i=0;i&lt;n;i++){
</span><span class='line'>        c=[s characterAtIndex:i];
</span><span class='line'>        if(isblank(c)){
</span><span class='line'>            b++;
</span><span class='line'>        }else if(isascii(c)){
</span><span class='line'>            a++;
</span><span class='line'>        }else{
</span><span class='line'>            l++;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    if(a==0 && l==0) return 0;
</span><span class='line'>    return l+(NSInteger)ceilf((float)(a+b)/2.0);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>以上资料均为网上整理得来，仅供学习交流使用。有关于此类问题，欢迎在最下方留言一起探讨优化学习。</strong></p>

<h6>参考博客地址：</h6>

<ul>
<li>1、<a href="http://mobilesolutions.blog.163.com/blog/static/18922417620116133910181/">统计含中英文混编的NSString 字符串长度 </a></li>
<li>2、<a href="http://blog.csdn.net/toss156/article/details/8993270">【IOS】IOS开发常用函数</a></li>
<li>3、<a href="http://code.qtuba.com/article-60968.html">iOS - 推断输入字符串长度函数</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
