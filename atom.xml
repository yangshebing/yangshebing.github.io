<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[杨社兵的技术博客]]></title>
  <link href="http://yangshebing.github.io/atom.xml" rel="self"/>
  <link href="http://yangshebing.github.io/"/>
  <updated>2016-05-02T13:53:04+08:00</updated>
  <id>http://yangshebing.github.io/</id>
  <author>
    <name><![CDATA[杨社兵]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS面试题系列之常见算法]]></title>
    <link href="http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-chang-jian-suan-fa/"/>
    <updated>2016-04-24T23:59:06+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-chang-jian-suan-fa</id>
    <content type="html"><![CDATA[<h4>iOS面试中熟悉常见算法</h4>

<p>1、    对以下一组数据进行降序排序（冒泡排序）。“24，17，85，13，9，54，76，45，5，63”</p>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main(int argc, char *argv[]) {
</span><span class='line'>  int array[10] = {24, 17, 85, 13, 9, 54, 76, 45, 5, 63};
</span><span class='line'>      int num = sizeof(array)/sizeof(int);
</span><span class='line'>      for(int i = 0; i &lt; num-1; i++) {
</span><span class='line'>          for(int j = 0; j &lt; num - 1 - i; j++) {
</span><span class='line'>                  if(array[j] &lt; array[j+1]) {
</span><span class='line'>                          int tmp = array[j];
</span><span class='line'>                              array[j] = array[j+1];
</span><span class='line'>                              array[j+1] = tmp;
</span><span class='line'>                          }
</span><span class='line'>                  }
</span><span class='line'>          }
</span><span class='line'>  
</span><span class='line'>  for(int i = 0; i &lt; num; i++) {
</span><span class='line'>          printf("%d", array[i]);
</span><span class='line'>              if(i == num-1) {
</span><span class='line'>                  printf("\n");
</span><span class='line'>                  }
</span><span class='line'>              else {
</span><span class='line'>                  printf(" ");
</span><span class='line'>                  }
</span><span class='line'>          }
</span><span class='line'>  }
</span></code></pre></td></tr></table></div></figure>


<p>2、    对以下一组数据进行升序排序（选择排序）。“86, 37, 56, 29, 92, 73, 15, 63, 30, 8”</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>void sort(int a[],int n)
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>    int i, j, index;
</span><span class='line'>    
</span><span class='line'>    for(i = 0; i &lt; n - 1; i++) {
</span><span class='line'>        
</span><span class='line'>        index = i;
</span><span class='line'>        
</span><span class='line'>        for(j = i + 1; j &lt; n; j++) {
</span><span class='line'>        
</span><span class='line'>            if(a[index] &gt; a[j]) {
</span><span class='line'>            
</span><span class='line'>                index = j;
</span><span class='line'>                
</span><span class='line'>            }
</span><span class='line'>            
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        if(index != i) {
</span><span class='line'>        
</span><span class='line'>            int temp = a[i];
</span><span class='line'>            
</span><span class='line'>            a[i] = a[index];
</span><span class='line'>            
</span><span class='line'>            a[index] = temp;
</span><span class='line'>            
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main(int argc, const char * argv[]) {
</span><span class='line'>
</span><span class='line'>    int numArr[10] = {86, 37, 56, 29, 92, 73, 15, 63, 30, 8};
</span><span class='line'>    
</span><span class='line'>    sort(numArr, 10);
</span><span class='line'>    
</span><span class='line'>    for (int i = 0; i &lt; 10; i++) {
</span><span class='line'>    
</span><span class='line'>        printf("%d, ", numArr[i]);
</span><span class='line'>        
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    printf("\n");
</span><span class='line'>    
</span><span class='line'>    return 0;
</span><span class='line'>    
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>3、    快速排序算法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void sort(int *a, int left, int right) {
</span><span class='line'>if(left &gt;= right) {
</span><span class='line'>return ;
</span><span class='line'>}
</span><span class='line'>int i = left;
</span><span class='line'>int j = right;
</span><span class='line'>int key = a[left];
</span><span class='line'>while (i &lt; j) {
</span><span class='line'>while (i &lt; j && key &gt;= a[j]) {
</span><span class='line'>j--;
</span><span class='line'>}
</span><span class='line'>a[i] = a[j];
</span><span class='line'>while (i &lt; j && key &lt;= a[i]) {
</span><span class='line'>  i++;
</span><span class='line'>  }
</span><span class='line'>a[j] = a[i];
</span><span class='line'>}
</span><span class='line'>a[i] = key;
</span><span class='line'>sort(a, left, i-1);
</span><span class='line'>sort(a, i+1, right);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>4、    归并排序</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void merge(int sourceArr[], int tempArr[], int startIndex, int midIndex, int endIndex) {
</span><span class='line'>    int i = startIndex;
</span><span class='line'>        int j = midIndex + 1;
</span><span class='line'>        int k = startIndex;
</span><span class='line'>        while (i != midIndex + 1 && j != endIndex + 1) {
</span><span class='line'>            if (sourceArr[i] &gt;= sourceArr[j]) {
</span><span class='line'>                    tempArr[k++] = sourceArr[j++];
</span><span class='line'>                    } else {
</span><span class='line'>                    tempArr[k++] = sourceArr[i++];
</span><span class='line'>                     }
</span><span class='line'>            }        while (i != midIndex + 1) {
</span><span class='line'>            tempArr[k++] = sourceArr[i++];
</span><span class='line'>            }        while (j != endIndex + 1) {
</span><span class='line'>            tempArr[k++] = sourceArr[j++];
</span><span class='line'>            }        for (i = startIndex; i &lt;= endIndex; i++) {
</span><span class='line'>            sourceArr[i] = tempArr[i];
</span><span class='line'>            }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>void sort(int souceArr[], int tempArr[], int startIndex, int endIndex) {
</span><span class='line'>    int midIndex;
</span><span class='line'>        if (startIndex &lt; endIndex) {
</span><span class='line'>            midIndex = (startIndex + endIndex) / 2;
</span><span class='line'>                sort(souceArr, tempArr, startIndex, midIndex);
</span><span class='line'>                sort(souceArr, tempArr, midIndex + 1, endIndex);
</span><span class='line'>                merge(souceArr, tempArr, startIndex, midIndex, endIndex);
</span><span class='line'>            }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>int main(int argc, const char * argv[]) {
</span><span class='line'>    int numArr[10] = {86, 37, 56, 29, 92, 73, 15, 63, 30, 8};
</span><span class='line'>        int tempArr[10];
</span><span class='line'>        sort(numArr, tempArr, 0, 9);
</span><span class='line'>        for (int i = 0; i &lt; 10; i++) {
</span><span class='line'>            printf("%d, ", numArr[i]);
</span><span class='line'>            }
</span><span class='line'>        printf("\n");
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'></span></code></pre></td></tr></table></div></figure>


<p>5、    实现二分查找算法（编程语言不限）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int bsearchWithoutRecursion(int array[],int low,int high,int target) {
</span><span class='line'>while(low &lt;= high) {
</span><span class='line'>int mid = (low + high) / 2;
</span><span class='line'>if(array[mid] &gt; target)
</span><span class='line'>high = mid - 1;
</span><span class='line'>else if(array[mid] &lt; target)
</span><span class='line'>low = mid + 1;
</span><span class='line'>else  //findthetarget
</span><span class='line'>return mid;
</span><span class='line'>}
</span><span class='line'>//the array does not contain the target
</span><span class='line'>return -1;
</span><span class='line'>}
</span><span class='line'>----------------------------------------
</span><span class='line'>递归实现
</span><span class='line'>int binary_search(const int arr[],int low,int high,int key){
</span><span class='line'>int mid=low + (high - low) / 2;
</span><span class='line'>if(low &gt; high)
</span><span class='line'>return -1;
</span><span class='line'>else{
</span><span class='line'>if(arr[mid] == key)
</span><span class='line'>  return mid;
</span><span class='line'>else if(arr[mid] &gt; key)
</span><span class='line'>return binary_search(arr, low, mid-1, key);
</span><span class='line'>else
</span><span class='line'>return binary_search(arr, mid+1, high, key);
</span><span class='line'>}
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>6、    如何实现链表翻转（链表逆序）？思路：每次把第二个元素提到最前面来。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>typedef struct NODE {
</span><span class='line'>    struct NODE *next;
</span><span class='line'>        int num;
</span><span class='line'>    }node;
</span><span class='line'>
</span><span class='line'>node *createLinkList(int length) {
</span><span class='line'>    if (length &lt;= 0) {
</span><span class='line'>            return NULL;
</span><span class='line'>            }
</span><span class='line'>        node *head,*p,*q;
</span><span class='line'>        int number = 1;
</span><span class='line'>        head = (node *)malloc(sizeof(node));
</span><span class='line'>        head-&gt;num = 1;
</span><span class='line'>        head-&gt;next = head;
</span><span class='line'>        p = q = head;
</span><span class='line'>        while (++number &lt;= length) {
</span><span class='line'>            p = (node *)malloc(sizeof(node));
</span><span class='line'>                p-&gt;num = number;
</span><span class='line'>                p-&gt;next = NULL;
</span><span class='line'>                q-&gt;next = p;
</span><span class='line'>                q = p;
</span><span class='line'>            }
</span><span class='line'>        return head;}
</span><span class='line'>
</span><span class='line'>void printLinkList(node *head) {
</span><span class='line'>    if (head == NULL) {
</span><span class='line'>            return;
</span><span class='line'>            }
</span><span class='line'>        node *p = head;
</span><span class='line'>        while (p) {
</span><span class='line'>            printf("%d ", p-&gt;num);
</span><span class='line'>                p = p -&gt; next;
</span><span class='line'>            }
</span><span class='line'>        printf("\n");
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>node *reverseFunc1(node *head) {
</span><span class='line'>    if (head == NULL) {
</span><span class='line'>            return head;
</span><span class='line'>        
</span><span class='line'>            }
</span><span class='line'>    
</span><span class='line'>        node *p,*q;
</span><span class='line'>        p = head;
</span><span class='line'>        q = NULL;
</span><span class='line'>        while (p) {
</span><span class='line'>            node *pNext = p -&gt; next;
</span><span class='line'>                p -&gt; next = q;
</span><span class='line'>                q = p;
</span><span class='line'>                p = pNext;
</span><span class='line'>            }
</span><span class='line'>        return q;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>int main(int argc, const char * argv[]) {
</span><span class='line'>    node *head = createLinkList(7);
</span><span class='line'>        if (head) {
</span><span class='line'>            printLinkList(head);
</span><span class='line'>                node *reHead = reverseFunc1(head);
</span><span class='line'>                printLinkList(reHead);
</span><span class='line'>                free(reHead);    
</span><span class='line'>    }
</span><span class='line'>        free(head);
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span></code></pre></td></tr></table></div></figure>


<p>7、    实现一个字符串“how are you”的逆序输出（编程语言不限）。如给定字符串为“hello world”,输出结果应当为“world hello”。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int spliterFunc(char *p) {
</span><span class='line'>    char c[100][100];
</span><span class='line'>        int i = 0;
</span><span class='line'>        int j = 0;
</span><span class='line'>    
</span><span class='line'>        while (*p != '\0') {
</span><span class='line'>            if (*p == ' ') {
</span><span class='line'>                    i++;
</span><span class='line'>                        j = 0;
</span><span class='line'>                    } else {
</span><span class='line'>                    c[i][j] = *p;
</span><span class='line'>                        j++;
</span><span class='line'>                    }
</span><span class='line'>                p++;    
</span><span class='line'>    
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>        for (int k = i; k &gt;= 0; k--) {
</span><span class='line'>            printf("%s", c[k]);
</span><span class='line'>                if (k &gt; 0) {
</span><span class='line'>                    printf(" ");
</span><span class='line'>                    } else {
</span><span class='line'>                    printf("\n");
</span><span class='line'>                      }
</span><span class='line'>            }    return 0;
</span><span class='line'>    
</span><span class='line'>    }
</span><span class='line'></span></code></pre></td></tr></table></div></figure>


<p>8、    给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？如“abaccddeeef”,字符是b,输出应该是2。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>char *strOutPut(char *);
</span><span class='line'>
</span><span class='line'>int compareDifferentChar(char, char *);
</span><span class='line'>
</span><span class='line'>int main(int argc, const char * argv[]) {    
</span><span class='line'>        char *inputStr = "abaccddeeef";
</span><span class='line'>        char *outputStr = strOutPut(inputStr);
</span><span class='line'>        printf("%c \n", *outputStr);
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>char *strOutPut(char *s) {
</span><span class='line'>    char str[100];
</span><span class='line'>        char *p = s;
</span><span class='line'>        int index = 0;
</span><span class='line'>        while (*s != '\0') {
</span><span class='line'>            if (compareDifferentChar(*s, p) == 1) {
</span><span class='line'>                    str[index] = *s;
</span><span class='line'>                        index++;
</span><span class='line'>                    }
</span><span class='line'>                s++;
</span><span class='line'>            }
</span><span class='line'>        return &str;}
</span><span class='line'>
</span><span class='line'>int compareDifferentChar(char c, char *s) {
</span><span class='line'>    int i = 0;
</span><span class='line'>        while (*s != '\0' && i&lt;= 1) {
</span><span class='line'>            if (*s == c) {
</span><span class='line'>                    i++;
</span><span class='line'>                    }
</span><span class='line'>                s++;    }
</span><span class='line'>        if (i == 1) {
</span><span class='line'>            return 1;
</span><span class='line'>            } else {
</span><span class='line'>            return 0;
</span><span class='line'>            }
</span><span class='line'>    }
</span></code></pre></td></tr></table></div></figure>


<p>9、    二叉树的先序遍历为FBACDEGH,中序遍历为：ABDCEFGH,请写出这个二叉树的后序遍历结果。
<strong>ADECBHGF</strong></p>

<ul>
<li>先序+中序遍历还原二叉树：先序遍历是：ABDEGCFH 中序遍历是：DBGEACHF</li>
</ul>


<p>首先从先序得到第一个为A，就是二叉树的根，回到中序，可以将其分为三部分：</p>

<p>左子树的中序序列DBGE，根A，右子树的中序序列CHF
接着将左子树的序列回到先序可以得到B为根，这样回到左子树的中序再次将左子树分割为三部分：
左子树的左子树D，左子树的根B，左子树的右子树GE
同样地，可以得到右子树的根为C
类似地将右子树分割为根C，右子树的右子树HF，注意其左子树为空
如果只有一个就是叶子不用再进行了，刚才的GE和HF再次这样运作，就可以将二叉树还原了。</p>

<p>10、   打印2-100之间的素数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main(int argc, const char * argv[]) {
</span><span class='line'>    for (int i = 2; i &lt; 100; i++) {
</span><span class='line'>            int r = isPrime(i);
</span><span class='line'>                if (r == 1) {
</span><span class='line'>                    printf("%ld ", i);
</span><span class='line'>                    }
</span><span class='line'>            }
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>int isPrime(int n){
</span><span class='line'>    int i, s;
</span><span class='line'>        for(i = 2; i &lt;= sqrt(n); i++)
</span><span class='line'>            if(n % i == 0)  return 0;
</span><span class='line'>            return 1;
</span><span class='line'>    }
</span></code></pre></td></tr></table></div></figure>


<p>11、   求两个整数的最大公约数。</p>

<pre><code>int gcd(int a, int b) {
    int temp = 0;
        if (a &lt; b) {
            temp = a;
                a = b;
                b = temp;
            }        while (b != 0) {
            temp = a % b;
                a = b;
                b = temp;
            }
        return a;
    }
</code></pre>

<p><strong>本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！</strong></p>

<p><strong>如需转载，请注明出处</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS面试题系列之UI相关]]></title>
    <link href="http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-uiji-chu/"/>
    <updated>2016-04-24T23:58:39+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-uiji-chu</id>
    <content type="html"><![CDATA[<p><strong>1、  简述app启动周期。</strong></p>

<p>打开应用程序，它先会执行main函数，再执行UIApplicationMain函数。初始化
UIApplication，设置代理对象，开启事件循环，调用代理方法进行事件处理。</p>

<p>首先会调用application:didFinishLaunchingWithOptions:代理方法。</p>

<!--more-->


<p>接下来会调用applicationDidBecomeActive:代理方法。监听系统事件，结束程序。当程序正常退出UIApplicationMain函数才会返回。</p>

<p>监听系统事件：</p>

<p>锁屏后app会调用：applicationWillResignActive:代理方法。然后接着调用
applicationDidEnterBackground:方法。</p>

<p>解锁后app会调用：applicationWillEnterForeground:代理方法。接着调用
applicationDidBecomeActive代理方法。</p>

<p>杀死进程会调用：applicationWillTerminate:代理方法。</p>

<p>接听电话：先调用applicationWillResignActive:代理方法。挂断电话后会直接进入
应用调：applicationDidBecomeActive:代理方法。</p>

<p>出现内存警告会调用：applicationDidReceiveMemoryWarning:代理方法</p>

<p><strong>2、  简单的说说UIApplication的作用及继承关系。</strong></p>

<p>（1）UIApplication是继承UIResponder的。UIApplication是整个应用程序的核
心。每一个程序在运行期必须有UIApplication(或子类)的一个实例（有且只有一
个），通过[UIApplication shareApplication]可以得到这个单例实例。</p>

<p>（2）UIApplication帮助管理应用程序的生命周期，通过delegate来履行任务。</p>

<p>（3）UIApplication可以接收事件，把所有用户事件都放入队列，逐个处理。它会发送
当前事件给一个合适的目标控件进行处理。他还将部分事件转给delegate对象来处理。
delegate可以处理的事件包括：应用程序的生命周期事件（如程序启动与关闭）、系统事
件（如来电）。</p>

<p><strong>3、  简述推送消息原理。</strong></p>

<p>（1）应用程序注册接收远程通知的时候，系统会发送请求到APNS服务器。APNS服务器收
到请求后会根据请求所带的key值生成一个独一无二的deviceToken。然后APNS服务器会把deviceToken包装成NSData对象发送到对应请求的App上。接下来APP把deviceToken发送给我们自己的服务器（Provider）。服务器接收到deviceToken后进行存储等相关处理。服务器会把推送给用户的消息发送至APNS服务器，最后APNS服务器再发送通知给app。</p>

<p>（2）有关于deviceToken变化问题：重新安装或卸载应用程序，deviceToken不会发生变化。系统升级deviceToken可能会发生变化。抹掉所有内容和设置，重置设备后，deviceToken会变化</p>

<p>（3）注册远程通知方法注册远程通知：一般在app启动完成的时候注册远程通知，注册方法一般在didFinishLaunchingWithOptions：代理方法中处理注册远程通知回调方法：注册成功会回调didRegisterForRometoNotificationsWithDeviceToken:其中的deviceToken参数就是APNS服务器返回的token。注册失败会回调didFailToRegisterForRemoteNotificationsWithError:</p>

<p>（4）处理接收到的远程通知消息程序启动时，app从Terminate状态进入Foreground状态时，会根据didFinishLaunchingWithOptions:代理方法中的luanchOptions参数来获取userInfo。判断是否有推送消息。方式如下：   // userInfo为收到远程通知的内容NSDictionary*userInfo=launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey];if (userInfo) {   // 有推送的消息，处理推送的消息  }如果app处于Background状态时，只有用户点击了通知消息才会调用didReceiveRemoteNotification:，如果当前app处于Foreground状态，会直接调用该方法。</p>

<p><strong>4、  简单说下UITableView、UIButton、UIWindow控件的继承关系。</strong></p>

<p>（1）UITableView的继承关系：UITableView继承UIScrollView。UIScrollView继承UIView。UIView继承UIResponder。UIResponder继承NSObject。</p>

<p>（2）UIButton的继承关系：UIButton继承UIControl，UIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。</p>

<p>（3）UIWindow继承UIView。</p>

<p><strong>5、  UIView与UIButton有什么区别？UISwitch呢？</strong></p>

<p>UIView继承自UIResponder，它能响应某个动作。UIButton继承UIControl。它不仅可以响应某个动作，还能为某个对象添加对应的动作加以响应。UIButton也能实现UISwitch的功能，它们的区别是分发的事件不一样。</p>

<p><strong>6、  简述UIControl的继承关系，它用来做什么？</strong></p>

<p>UIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。它能为某个特定对象添加事件。能进行事件分发。</p>

<p><strong>7、  简述UIViewController中view的生命周期。</strong></p>

<p>先调用loadView方法，再调用viewDidLoad方法，调用viewWillAppear方法，调用viewWillLayoutSubviews方法，调用viewDidLayoutSubviews方法，再调用viewDidApper方法。控制器消失的时候先调用viewWillDisappear方法，再调用viewDidDisapper方法。最后调用dealloc方法。当出现内存警告的时候会调用didReceiveMemoryWarning方法。</p>

<p><strong>8、  简述UITableView的代理方法调用顺序。</strong></p>

<p>先调用numberOfSectionsInTableView:方法，</p>

<p>numberOfRowsInSection:</p>

<p>heightForRowAtIndexPath:</p>

<p>cellForRowAtIndexPath:</p>

<p><strong>9、  你在用CollectionView的时候有没有遇到什么问题？问题是怎么解决的？</strong></p>

<p>刷新的时候会闪烁。在刷新的时候会默认附加一个隐式的fade动画。可以通过取消动画来达到取消闪烁的目的。</p>

<p><strong>10、 简述UIResponder类的作用。</strong></p>

<p>UIResponder类主要是为那些需要响应并处理事件的对象定义了一组接口。这些事件包括：触摸事件、运动事件、远程控制事件（如耳机控制音视频播放）。当用户触发某一事件时，UIKit会创建一个UIEvent事件对象，事件对象会加入到一个FIFO先进先出的队列中。UIApplication对象处理事件时，会从队列头部取出一个事件对象进行分发。</p>

<p><strong>11、 如何监听View的触摸事件？事件如何传递？简述视图的响应者链。</strong></p>

<p>可以通过View类的touchesBegan、touchesMoved、touchesEnded、touchesCancelled方法监听视图的触摸。
当触摸一个视图对象时，系统会捕捉此事件，并给这个事件创建一个UIEvent对象，将此对象加入当前应用程序的事件队列中，然后由UIApplication对象从队列中取出来进行事件分发，首先会分发给UIWindow对象，然后由UIWindow对象分发给触摸的视图对象，即第一响应者对象。</p>

<p>响应者链：当事件交给第一响应者处理，如果第一响应者不处理，事件就会沿着响应者链向上传递，交给下一个响应者。一般来说，第一响应者是一个视图对象或者是其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象，然后是它的父视图对象，以此类推，直到顶层视图。接下来会沿着顶层视图到UIWindow对象，再到UIApplication对象。如果整个过程都没有响应这个事件，该事件就会被丢弃，一般情况下，在响应者链中只要有对象处理事件，事件就会停止传递。有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。</p>

<p><strong>12、 CALayer与UIView有什么区别？</strong></p>

<p>（1）UIView是iOS系统中界面元素的继承。所有的界面元素都继承自它，他本身完全是由CoreAnimation来实现的。它真正的绘图部分，是由一个叫CALayer的类来管理。UIView本身更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，如frame,bounds等，实际上内部都是在访问它所包含的CALayer的相关属性。</p>

<p>（2）UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示。</p>

<p>（3）UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer。</p>

<p>（4）CALayer坐标系统与UIView有点不一样，它多了一个anchorPoint的属性。</p>

<p>（5）UIView的layer树形在系统内部，被系统维护着三份copy。逻辑树，动画树，显示树。</p>

<p>（6）CALayer默认修改属性支持隐式动画</p>

<p>（7）View可以接受并处理事件，Layer不可以。</p>

<p><strong>13、 如何优化UITableView?</strong></p>

<p>（1）复用单元格</p>

<p>（2）使用不透明的视图，单元格中少使用动画。</p>

<p>（3）图片使用异步加载，设置图片加载的并发数。</p>

<p>（4）滑动时不加载图片，停止滑动时再加载。</p>

<p>（5）图片和文字可以直接drawRect</p>

<p>（6）如果cell是动态行高，计算缓存单元格高度</p>

<p>（7）尽量少reloadData，只reloadRowsAtIndexPaths</p>

<p>（8）cell高度固定直接用rowHeight属性设置高度。</p>

<p><strong>14、 简述加载到控制器上的根视图创建与加载时机。</strong></p>

<p>视图控制器的根视图加载是在UIViewController的loadView方法中。当视图控制中的loadView方法被调用时，会先通过NSBundle加载，通过控制器的类名作为xib文件名加载xib文件，如果存在，加载View为根视图，如果不存在，则自动创建一个View作为根视图。</p>

<p><strong>15、 简述UITableView中cell的复用机制。</strong></p>

<p>UITableView会创建屏幕显示单元格个数（N）+1个单元格，当滑动到第N+2个单元格时就会复用第1个单元格。UITableView中还有单元格复用池的概念。当tableView调用初始化单元格协议方法获取单元格时，它会根据你设定的reuse identifier先去复用池中查找可用的复用单元格，找到则复用该单元格，没找到这创建一个新的单元格对象。</p>

<p><strong>本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！</strong></p>

<p><strong>如需转载，请注明出处</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS面试题系列之Objective-C相关]]></title>
    <link href="http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-zhi-objective-cji-chu/"/>
    <updated>2016-04-24T23:58:04+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-zhi-objective-cji-chu</id>
    <content type="html"><![CDATA[<p><strong>1、简述你项目中常用的设计模式。它们有什么优缺点？</strong></p>

<p>常用的设计模式有：代理、观察者、单例。</p>

<p>（1）单例：它是用来限制一个类只能创建一个对象。这个对象中的属性可以存储全局共享的数据。所有的类都能访问、设置此单例中的属性数据。</p>

<p>优点：是它只会创建一个对象容易供外界访问，节约性能。</p>

<!--more-->


<p>缺点：是一个类只有一个对象，可能造成责任过重，在一定程度上违背了“单一职责原则”。单例模式中没有抽象层，所以单例类的扩展有很大的困难。不能过多创建单例，因为单例从创建到程序关闭前会一直存在，过多的单例会影响性能，浪费系统资源。</p>

<p>（2）观察者（KVO）:它提供了观察某一属性变化的方法。当指定对象的属性发生改变后，它会自动通知相应的观察者。</p>

<p>优点：能提供被观察者属性的新值与旧值。用keypaths来观察属性，因此也可以观察嵌套对象。</p>

<p>缺点：需要注册观察者，实现observeValueForKeyPath:方法，属性必须通过KVC的方法来修改。否则观察者收不到通知。</p>

<p>（3）代理：可以实现类与类之间一对一的通信。</p>

<p>优点：代理协议方法都有清晰的定义。代理方法可以设置可选或必须实现。</p>

<p>缺点：需要定义协议方法，需要设置代理对象，代理对象实现协议方法。内存管理方面，需要注意循环引用问题。</p>

<p><strong>2、代理模式能否实现一对多的通信？</strong></p>

<p>可以，采用多播委托的方式来实现。多播委托：它是指允许创建方法的调用列表或者链表的能力。当多播委托被调用时，列表中的方法均自动执行。</p>

<p>普通代理只能是一对一的回调，无法做到一对多的回调，而多播委托正式对delegate的一种扩展与延伸，多了一个注册和取消的过程。任何需要回调的对象都必须先注册。</p>

<p><strong>3、  重复注册通知会有问题吗？</strong></p>

<p>不会出现问题，若多次发送同一通知，对方就会多次响应。如果重复注册通知，也会有多次响应的效果。为了避免重复注册通知而造成的错误，建议每次注册一个通知前，可以移除一次该通知。</p>

<p><strong>4、项目中是否用过多线程编程？简述你常用的多线程实现方式？</strong></p>

<p>常用的是GCD。</p>

<p>GCD是苹果开发中一个多核编程的解决方案。GCD的队列分为两种类型，SerialDispatchQueue与ConcurrentDispatchQueue。系统默认提供了一个dispatch_get_main_queue，一个dispatch_get_global_queue。</p>

<p><strong>5、简述NSOperationQueue与GCD的区别。</strong></p>

<p>(1) GCD是底层的C语言构成的API。NSOperationQueue及相关对象是Objc对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构。而Operation作为一个对象，为我们提供了更多的选择。</p>

<p>(2) 在NSOperationQueue中，我们可以取消任务，而GCD没法停止已经加入queue的block。</p>

<p>(3) NSOperation能够方便的设置依赖关系。还能设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行。在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务优先级也需要大量复杂代码。NSOperation还可以设置并发数。</p>

<p><strong>6、实现多线程有哪几种方式？</strong></p>

<p>（1）NSThread:detachNewThreadSelector:</p>

<p>（2）继承NSOperation</p>

<p>（3）GCD：dispatch_async</p>

<p>（4）NSObject：performSelectorInBackground:</p>

<p><strong>7、KVC、KVO是什么？简述KVO的实现原理。KVO能否监听数组？如何实现？</strong></p>

<p>KVC:键值编码，它是一种间接访问对象实例变量机制，可以不通过存取方法访问对象的实例变量。</p>

<p>KVO:键值观察，它可以使对象获取其他对象属性变化的通知机制。</p>

<p>键值编码和键值观察是根据isa-swizzling技术来实现的，主要依据runtime的强大动态能力。当给某个对象第一次添加KVO监听的时候，运行时会动态的创建一个被监听对象的派生类，然后重写KVO需要监听属性值对应的setter方法，在这个setter方法中实现了通知机制。最后将被监听对象的isa指向动态创建的派生类。这样当使用KVC修改属性值时，就会调用动态创建的派生类中对应的setter方法，触发通知机制，从而实现了KVO了。KVO可以监听数组。</p>

<p>实现 NSMutableArray 的增删改操作遵从 KVC 的规则，需要实现其对应方法:</p>

<p>增操作 -insertObject:in<Key>AtIndex: 或者 -insert<Key>:atIndexes:</p>

<p>删操作 -removeObjectFrom<Key>AtIndex: 或者 -remove<Key>AtIndexes:</p>

<p>改操作 -replaceObjectIn<Key>AtIndex:withObject: 或者 -replace<Key>AtIndexes:with<Key>:</p>

<p>并将这些接口暴露给调用者，在对数组进行操作时需使用上述实现的接口。</p>

<p><strong>8、简单说下C++，JAVA，Objective-C这几种语言有什么区别？</strong></p>

<p>Objective-C与JAVA都是单继承语言，C++是多继承语言。</p>

<p>Objective-C不支持命名空间机制，通过类名前面加前缀NS来区分。</p>

<p>Objective-C与JAVA不支持运算符重载。</p>

<p>Objective-C协议可选实现，JAVA的接口必须实现。</p>

<p><strong>9、数组添加nil元素有问题吗？字典object与key可以设置为nil吗？</strong></p>

<p>会有问题，数组中添加nil元素，程序会崩溃！报object cannot be nil错误。字典的key不能为nil，否则会造成崩溃。字典的object也不能为nil。</p>

<p><strong>10、oc中向一个nil对象发送消息会出现问题吗？</strong></p>

<p>不会出现问题，因为objc是动态语言，每个方法在运行时会被动态转为消息发送。即：objc_msgSend(receiver，selector)。objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p>

<p><strong>11、可变数组是线程安全的吗？什么情况下不安全？可以加锁吗？它锁住的是添加元素操作还是数组对象？</strong></p>

<p>可变数组不是线程安全的，在异步读取数据的情况下是不安全的。可以加锁，锁住的是数组。</p>

<p><strong>12、数组能添加一个block吗？数组添加一个block之后再取出来，这个block还有用吗？</strong></p>

<p>可以，还有用，它只是多retain了一次</p>

<p><strong>13、NSMutableDictionary中的setObject:forKey:与setValue:forKey:方法有什么区别?</strong></p>

<p>setObject:forkey:中value是不能够为nil的，不然会报错。</p>

<p>setValue:forKey:中的value能够为nil，但是当value为nil的时候，会自动调用removeObject:forKey方法。</p>

<p>setValue:forKey:中的key的参数只能是NSString类型，而setObject:forKey是可以任何类型。</p>

<p><strong>14、简述copy与mutablecopy的区别。</strong></p>

<p>（1）非容器对象：</p>

<p>对不可变对象：copy是指针复制（浅拷贝）， mutableCopy是对象复制（深拷贝）。对可变对象：copy和mutableCopy都是对象复制。</p>

<p>（2）容器对象：</p>

<p>对不可变对象：copy是指针复制，mutableCopy是对象复制。</p>

<p>对可变对象：copy和mutableCopy都是对象复制，只是返回的对象类型不一样，前者返回的是不可变对象，后者返回的是可变对象。</p>

<p>容器对象复制仅限于对象本身，对象元素仍然是指针复制。</p>

<p><strong>15、简述weak与assign的区别。</strong></p>

<p>weak用来修饰对象，不能修饰基本数据类型。assign一般用来修饰基本数据类型。weak修饰对象，在对象释放之后会把对象置为nil。</p>

<p><strong>16、ARC下，不显示指定任何属性关键字时，默认的关键字有哪些？</strong></p>

<p>基本数据类型默认修饰关键字：atomic,readwrite,assign</p>

<p>普通的OC对象默认修饰关键字：atomic,readwrite,strong</p>

<p><strong>17、weak在什么时候置空？</strong></p>

<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>

<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>

<p>objc_storeWeak(&amp;a, b)函数：</p>

<p>objc_storeWeak函数把第二个参数&ndash;赋值对象（b）的内存地址作为键值key，将第一个参数&ndash;weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，你可以把objc_storeWeak(&amp;a, b)理解为：objc_storeWeak(value, key)，并且当key变nil，将value置nil。</p>

<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>

<p>而如果a是由assign修饰的，则： 在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。</p>

<p>下面我们将基于objc_storeWeak(&amp;a, b)函数，使用伪代码模拟“runtime如何实现weak属性”：</p>

<p>// 使用伪代码模拟：runtime如何实现weak属性id obj1;objc_initWeak(&amp;obj1, obj);/<em>obj引用计数变为0，变量作用域结束</em>/objc_destroyWeak(&amp;obj1);</p>

<p>下面对用到的两个方法objc_initWeak和objc_destroyWeak做下解释：</p>

<p>总体说来，作用是： 通过objc_initWeak函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过objc_destoryWeak函数释放该变量（obj1）。</p>

<p>下面分别介绍下方法的内部实现：</p>

<p>objc_initWeak函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用objc_storeWeak函数。obj1 = 0；obj_storeWeak(&amp;obj1, obj);</p>

<p>也就是说：weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）然后obj_destroyWeak函数将0（nil）作为参数，调用objc_storeWeak函数。objc_storeWeak(&amp;obj1, 0);前面的源代码与下列源代码相同。</p>

<p>// 使用伪代码模拟：runtime如何实现weak属性id obj1;obj1 = 0;objc_storeWeak(&amp;obj1, obj);/<em> &hellip; obj的引用计数变为0，被置nil &hellip; </em>/objc_storeWeak(&amp;obj1, 0);</p>

<p>objc_storeWeak函数把第二个参数&ndash;赋值对象（obj）的内存地址作为键值，将第一个参数&ndash;weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除，在后面的相关一题会详解。</p>

<p>以上内容总结如下：</p>

<p>（1）从weak表中获取废弃对象的地址为键值的记录</p>

<p>（2）将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil</p>

<p>（3）从weak表中删除该记录</p>

<p>（4）从引用计数表中删除废弃对象的地址为键值的记录。</p>

<p><strong>18、自动释放池用过吗？它是什么时候释放？什么情况下对象会被加入到自动释放池，它会加入到哪个自动释放池?</strong></p>

<p>主线程默认开启runloop,同时runloop会自动创建一个autoreleasepool，autorelease对象会自动被加入autoreleasepool中，一次runloop后清空自动释放池。用__autoreleasing修饰符修饰，或类方法创建会自动加入autoreleasepool。它会加入到最近的autoreleasepool中。</p>

<p><strong>19、你知道iOS中有哪些数据持久化方式吗？请简要加以说明。</strong></p>

<p>iOS中数据持久化方式有：SQLite3数据库，CoreData，文件归档，属性列表（plist文件写入）。</p>

<p>属性列表：涉及的主要类是NSUserDefaults，存储小量的数据。</p>

<p>文件归档：对象必须实现NSCoding协议。实现initWithCoder:方法与encodeWithCoder方法。同时也建议实现NSCopying协议。</p>

<p>SQLite3数据库:SQLite是一个开源的嵌入式关系数据库。可移植性好，容易使用，需要内存开销小。适合嵌入式设备。</p>

<p>CoreData：它可以使用SQLite保存数据，而且不需要写SQL语句。另外它还可以使用XML方式保存数据。要使用CoreData，需要在Xcode中的数据模型编辑器中设计好各个实体以及定义好他们的属性和关系。通过操作这些对象来完成数据的持久化。</p>

<p><strong>20、fmdb中支持多线程吗？它是如何实现的！</strong></p>

<p>支持多线程。它里面有个FMDatabaseQueue类。它看似是一个队列，实际上它本身并不是，它继承NSObject，通过内部创建一个Serial的dipatch_queue_t来处理inDatabase和inTransaction传入的Block，所以当我们在主线程（或者后台）调用inDatabase或者inTransaction时，代码实际上是同步的。FMDatabaseQueue如此设计的目的是为了避免并发访问数据库的线程安全问题，所有的数据库访问都是同步执行，比@synchronized与NSLock效率高。</p>

<p><strong>21、简述category与extension的区别。Category与extension加载的时机。</strong></p>

<p>category中只能增加方法，不可添加实例变量（可添加属性）。extension不仅可以增加方法，还可以增加实例变量或属性（私有的）。extension不能像category一样有独立的实现部分。category是运行时决定的。extension是编译期决定的。</p>

<p><strong>22、category的方法能被子类继承吗？它覆盖原有类的方法后，原有类的方法还能调用吗？如果能，你说明理由。</strong></p>

<p>category的方法可以被子类继承。category并不是绝对的覆盖了类的同名方法，而是category的方法排在了类的同名方法之前，方法的检索方式是顺序检索，所以在调用方法时，调用到的同名方法是category，从而产生了覆盖。利用运行时遍历方法列表，可以调用被category覆盖的方法。</p>

<p><strong>23、 扩展一个类的方式用继承好还是category好？请说明理由。</strong></p>

<p>用类目好。因为继承还需要定义子类。类目不需要通过创建子类来增加现有类的方法。用category去重写一个类的方法，仅仅只对本category有效，不会影响到其他类与原有类的关系。</p>

<p><strong>24、 block有几种类型？block的实现？</strong></p>

<p>block分为三种类型:</p>

<p>_NSConcreteGlobalBlock</p>

<p>_NSConcreteStackBlock</p>

<p>_NSConcreteMallocBlock</p>

<p>block：匿名函数</p>

<p><strong>25、 Swift用的多吗？简单的说说1.0与2.0的区别。</strong></p>

<p>swift2.0新增:guard语句，异常处理，协议扩展，打印语句改变，avaliable检查，do-while语句重命名：repeat-while，defer关键字</p>

<p><strong>26、 在Swift用有没有用过defer关键字？</strong></p>

<p>对defer语句进行的延迟，函数结束时调用。</p>

<p><strong>27、 SDWebImage的图片保存在什么位置？</strong></p>

<p>图片保存在沙盒中的library/caches文件夹下。</p>

<p><strong>28、 Objective-C中类目为什么不能添加实例变量？</strong></p>

<p>因为在运行时，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局。</p>

<p><strong>29、 Objective-C中的协议默认是@optional还是@require？在使用协议的时候应当注意哪些问题？</strong></p>

<p>Objective-C中的协议默是必须实现的@require，使用协议的时候应当注意循环引用问题，多个协议之间采用逗号分隔。</p>

<p><strong>30、 Objective-C的协议与JAVA中的接口有什么区别？</strong>
OC中的协议可选实现，JAVA中的接口必须实现。</p>

<p><strong>31、 类目的应用场景有哪些？</strong></p>

<p>（1）可以把类的实现分开在几个不同的文件里面</p>

<p>（2）声明私有方法</p>

<p>（3）模拟多继承</p>

<p>（4）把Framework的私有方法公开</p>

<p><strong>32、 self与super的区别？</strong></p>

<p>super本质上是一个编译器标示符，它和self指向的是同一个消息接受者，两者不同在于：super会告诉编译器，调用class这个方法时，要去父类方法，而不是本类方法。
<strong>33、 图片缓存为什么不保存到沙盒下的tmp文件目录中？</strong></p>

<p>因为tmp文件夹是用来存放临时文件，iTunes不会备份和恢复此目录，此目录下文件可能会在应用退出后删除。</p>

<p><strong>34、 NSURLConnection与NSURLSession。</strong>
NSURLConnection它是CoreFoundation/CFNetwork框架的API之上的一个抽象。</p>

<p>NSURLConnection这个名字实际指代Foundation框架的URL加载系统中一系列有关联的组件：NSURLRequest、NSURLResponse、NSURLProtocol、NSURLCache、NSHTTPCookieStorage、NSURLCredentialStorage以及同名类NSURLConnection。NSURLRequest 被传递给 NSURLConnection。被委托对象（遵守以前的非正式协议 <NSURLConnectionDelegate> 和 <NSURLConnectionDataDelegate>）异步地返回一个 NSURLResponse 以及包含服务器返回信息的 NSData。</p>

<p>NSURLSession包括：NSURLRequest、NSURLCache、NSURLSession、NSURLSessionConfiguration、NSURLSessionDataTask、NSURLSessionUploadTask、NSURLSessionDownloadTask。它与NSURLConnection的区别在于：NSURLSession最直接的改进就是可以配置每个Session的缓存，协议，cookie以及正式策略。甚至跨程序共享这些信息。每个NSURLSession对象都由一个NSURLSessionConfiguration对象来进行初始化。session task：负责处理数据的加载以及文件和数据在客户端与服务器之间的上次和下载。</p>

<p><strong>35、 简述ARC与MRC的区别。</strong></p>

<p>ARC:自动引用计数。MRC：手动引用计数。ARC是把内存交给系统管理。系统会在编译的时候自动插入retain/release。MRC则需要手动管理对象的引用计数。当你alloc,new,copy,mutablecopy或者retain一个对象时，你就有义务向它发送一条release或autorelease消息。</p>

<p><strong>36、 简述ARC的实现原理。它在什么时机插入retain/release？</strong></p>

<p>ARC：自动引用计数。它会在对象创建或者消亡的时候自动插入retain/release。达到自动管理内存的目的。</p>

<p><strong>37、 Framework与Library的区别？动态库与静态库的区别？</strong>
library与Framework的区别：</p>

<p>在iOS中，Library 仅能包含编译后的代码，即 .a 文件。但一般来说，一个完整的模块不仅有代码，还可能包含.h 头文修的、.nib 视图文件、图片资源文件、说明文档。（像 UMeng 提供的那些库，集成时，要把一堆的文件拖到Xcode中，配置起来真不是省心的事。Framework 作为 Cocoa/Cocoa Touch 中使用的一种资源打包方式，可以上述文件等集中打包在一起，方便开发者使用（就像Bundle）。</p>

<p>静态库与动态库的区别：</p>

<p>简单的说，静态链接库是指模块被编译合并到应用中，应用程序本身比较大，但不再需要依赖第三方库。运行多个含有该库的应用时，就会有多个该库的Copy在内存中，冗余。动态库可以分开发布，在运行时查找并载入到内存，如果有通用的库，可以共用，节省空间和内存。同时库也可以直接单独升级，或作为插件发布。</p>

<p><strong>38、 什么是runloop？</strong></p>

<p>一般来说，一个线程一次只能执行一个任务，执行完成后线程就会退出，如果我们需要一个机制，让线程能随时处理事件但并不退出。代码逻辑如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function loop() {        initialize();       do {    var message = get_next_message();   process_message(message);} while(message != quit)}
</span></code></pre></td></tr></table></div></figure>


<p>这种模型我们通常称之为EventLoop（事件循环）。RunLoop实际上是一个对象，这个对象管理了其需要处理的事件和消息。并提供了一个入口函数来执行上面EventLoop逻辑。在OSX/iOS系统中，提供了两个这样的对象：NSRunLoop和CFRunLoopRef。</p>

<p>CFRunLoopRef是在CoreFoundation框架内，它提供了纯C函数的API,所有这些API都是线程安全的。</p>

<p>NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API，这些API不是线程安全的。</p>

<p>苹果不允许直接创建RunLoop，只提供了两个自动获取的函数：CFRunLoopGetMain()和CFRunLoopGetCurrent()。</p>

<p>线程和RunLoop之间是一一对应的。</p>

<p><strong>39、#include与#import的区别？#import与@class的区别？</strong></p>

<p>&ldquo;#include"与&rdquo;#import"功能一样，都是导出头文件。只是#import不会引起交叉编译，可以确保头文件只导入一次。#import会包含这个类的所有信息。包括实例变量和方法，而@class只是告诉编译器，它后面声明的名称是类的名称，至于类的定义，后面会告诉你。使用#import编译效率高，可以防止相互包含的编译错误。</p>

<p><strong>40、Static与const的区别？</strong>
const表示只读的意思，只在声明中使用。</p>

<p>static一般有2个作用，规定作用域和存储方法。对于局部变量，static规定其为静态存储区，每次调用的初始值为上一次调用的值，调用结束后存储空间不释放。</p>

<p>对于全局变量，如果以文件划分作用域的话，此变量只在当前文件可见，对于static函数也是在当前模块内函数可见。</p>

<p><strong>41、简述GET请求与POST请求的区别。</strong></p>

<p>(1)POST 需要明确制定方法 GET不需要 ，并且默认就是GET方法，并且GET有缓存，POST没有缓存</p>

<p>(2)GET的参数放在URL的后面,并且第一个参数用?拼接,后面的从第二个参数开始,直到最后一个,如果有多个,用&amp;分割;POST 的参数放在请求体里面,并且第一个参数,不用,后面从第二开始,直到最后,如果有多个,用&amp;分割;</p>

<p>(3)GET 一般用于获取数据，POST向服务器提交数据用到</p>

<p>(4)GET的参数是暴漏在地址栏的,不安全;POST的参数隐藏在请求体里面,相对安全一点;</p>

<p>(5)GET请求没有请求体，POST请求有请求体。</p>

<p>(6)GET请求提交数据受浏览器限制，1k，POST请求理论上无限制。</p>

<p><strong>42、属性用__block修饰时在内存中会发生什么变化？</strong></p>

<p>为什么在block外面用weak修饰属性来打破循环，在block还需要把属性转换成strong。</p>

<p><strong>43、谈谈block与函数的区别。</strong></p>

<p>block可以写在方法里面，函数需要写在方法外面。block可以访问方法中的局部变量。</p>

<p><strong>44、你了解runloop吗？它有几种模式？简要的说下它的应用场景。</strong></p>

<p>runloop模式：</p>

<p>Default：</p>

<p>NSDefaultRunLoopMode(Cocoa)、kCFRunLoopDefaultMode(CoreFoundation)</p>

<p>Connection：</p>

<p>NSConnectionReplyMode</p>

<p>Modal：</p>

<p>NSModalPanelRunLoopMode</p>

<p>Event tracking:</p>

<p>NSEventTrackingRunLoopMode</p>

<p>Common modes:</p>

<p>NSRunLoopCommonModes(Cocoa)、kCFRunLoopCommonModes(CoreFoundation)</p>

<p>应用场景：</p>

<p>（1）使用端口或自定义输入源与其他线程通信。</p>

<p>（2）在线程中使用计时器</p>

<p>（3）使用任意的performSelector方法</p>

<p>（4）保持线程去执行一个周期任务。</p>

<p><strong>45、你工作中用到的版本管理工具是什么？</strong></p>

<p>用的是git工具来进行版本管理。</p>

<p><strong>46、你用过git工具吗？用过哪些常见的命令？</strong></p>

<p>git init，git add, git commit，git merge，git branch，git checkout，git pull，git push等</p>

<p><strong>47、CoreAnimation常用的动画有哪些类型？</strong></p>

<p>所有的核心动画的动画类都从CAAnimation类继承而来。CAAnimationGroup组动画，CATransition转场动画，CABasicAnimation:基础动画，CAKeyframeAnimation关键帧动画。</p>

<p><strong>48、GCD中系统提供了几种queue？</strong></p>

<p>两种：DispatchSerialQueue、DispatchConcurrentQueue。</p>

<p><strong>49、二叉搜索树的概念及时间复杂度是多少？</strong></p>

<p>O(n)</p>

<p><strong>50、block中的weak self，是任何时候都需要加的么？</strong></p>

<p>不一定，可加可不加。将block置nil也可以打破循环引用。</p>

<p><strong>51、GCD的queue，main queue中执行的代码，一定是在main thread么？</strong></p>

<p>是的。一定是在main thread。</p>

<p><strong>52、你在使用数据库的过程中有没有遇到过问题？如何解决？</strong></p>

<p>遇到过多线程操作数据库读写死锁问题，采用fmdb中提供的回滚的方式解决</p>

<p><strong>53、简述iOS中的沙盒机制。</strong></p>

<p>iOS中的沙盒机制是一种安全体系，它规定了应用程序只能在为该应用创建的文件夹读取文件，不可以访问其他地方的内容。所有非代码文件都保存在这个地方。如图片，声音，属性列表及文本文件等。</p>

<p>（1）每个应用程序都在自己的沙盒内</p>

<p>（2）不能随意跨越自己的沙盒去访问别的应用程序沙盒的内容</p>

<p>（3）应用程序向外请求或者接收数据都需要经过权限认证。</p>

<p>沙盒目录结构这种，因为应用是在沙箱（sandbox）中的，在文件读写权限上受到限制，只能在几个目录下读写文件：</p>

<p>Documents：应用中用户数据可以放在这里，iTunes备份和恢复的时候会包括此目录</p>

<p>tmp：存放临时文件，iTunes不会备份和恢复此目录，此目录下文件可能会在应用退出后删除</p>

<p>Library：存储程序的默认设置或其他状态信息。</p>

<p>Library/Caches：存放缓存文件，iTunes不会备份此目录，此目录下文件不会在应用退出删除</p>

<p><strong>54、字符串为什么要用copy修饰？</strong></p>

<p>是为了防止mutablestring被无意中修改，NSMutableString是NSString的子类。因此NSString指针可以持有NSMutableString对象。</p>

<p><strong>55、nonatomic与atomic有什么区别？</strong></p>

<p>atomic是Objective-C使用的一种线程保护技术，它是为了防止写操作在未完成的时候被另外一个线程读取。从而造成数据错误。这种机制是非常耗费系统资源的，所以在iphone这种小的移动设备上，如果没有使用多线程间的通讯编程。建议使用nonatomic。</p>

<p>默认的访问器是原子操作，就是说在多线程环境下，解析的访问器提供一个对属性安全访问，从获取器得到的返回值或者通过设置器设置的值可以一次完成，即便是多线程也在对其进行访问，如果不指定nonatomic ，在自己管理内存的环境中，解析的访问器保留并自动释放保留的值，如果是指定了nonatomic，访问器只是简单的返回一个值。</p>

<p><strong>56、@synthesize与@dynamic的区别？</strong></p>

<p>@synthesize：如果你没有手动实现setter方法和getter方法，编译器会自动为帮你生成setter方法和getter方法。</p>

<p>@dynamic：告诉编译器属性的setter和getter方法由用户自己实现，不自动生成。如果一个属性声明为@dynamic var，又没有提供setter和getter方法，编译的时候不会有问题，如果程序中运行到person.name = newName;或newName=person.name时候就会导致程序崩溃。因为”unrecognized selector sent to instance …”这就是动态绑定。</p>

<p><strong>57、@property(copy)NSMutableArray *array;这句代码有什么问题？如果有请简述原因；</strong></p>

<p>（1）添加、删除、修改数组内的元素的时候，程序会因为找不到对应的方法而崩溃，因为copy就是复制一个不可变的NSArray对象。</p>

<p>（2）没有使用nonatomic属性修饰符，默认是 atomic修饰，这样会严重影响性能。</p>

<p><strong>58、NSString <em>str = @“hello world!”与NSString </em>str =  [[NSString alloc] initWithString:@&ldquo;hello world!”];在内存管理上有什么区别？</strong></p>

<p>在MRC中，前者表示，你不持有这个对象，所以不需要手动管理其内存。后者意味着你持有这个字符串，需要自己手动管理内存，对其进行释放。</p>

<p><strong>59、对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别是什么类型的对象?</strong></p>

<p>编译时是NSString类型对象，运行时时NSData类型对象首先，声明NSString*testObject是告诉编译器,obj是一个指向某个Objective-C对象的指针，因为不管指向的是什么类型的对象，一个指针所占的内存空间都是固定的，所以这里声明称任何类型的对象，最终生成的可执行代码都是没有区别的。这里限定了NSString只不过是告诉编译器，请把obj当做一个NSString来检查，如果后面调用了非NSString的方法，会产生警告，接着，你创建了一个NSData对象，然后把这个对象所在的内存地址保存在obj里。那么运行时，obj指向的内存空间就是一个NSData对象。你可以把obj当做一个NSData对象来用。</p>

<p><strong>60、self.name=object与name=object在内存管理上有什么区别？</strong></p>

<p>前者通过调用setter方法设置值，后者是普通的赋值操作。</p>

<p><strong>61、为什么property声明中只有”copy”特性而没有“mutableCopy”特性？</strong></p>

<p>这是由于当声明property为"copy"特性时，系统会自动根据receiver的特点决定使用copy（已含retain的情况）还是mutableCopy。</p>

<p><strong>62、Objective-C中id与void*有什么区别？id与instancetype有什么区别？nil、null、NULL三者有什么区别？</strong></p>

<p>Objective-C中id与void*区别：</p>

<p>id是指向OC类对象的指针，它可以声明为任何类对象的指针，当在OC中使用id时，编译器会假定你知道，id指向哪个类的对象。与void<em>不同，void</em>编译器不知道也不假定指向任何类型的指针。</p>

<p>id与instancetype区别：</p>

<p>id返回的是id类型，instancetype返回的是所在类的类型。</p>

<p>相同点是同样都是作为方法的返回类型。</p>

<p>区别：</p>

<p>(1) instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象。</p>

<p>(2) instancetype只能作为返回值，id可以作为参数。</p>

<p>nil、Nil、NULL三者区别：</p>

<p>nil是一个指向不存在的对象指针（对象空指针）。Nil是指向不存在的类指针（类空指针）。NULL指向其他类型的空指针。NSNull在集合对象中，表示空值的对象。</p>

<p><strong>63、数据解析方式有几种？他们有什么区别？你项目中采用的是哪种数据解析方式？</strong></p>

<p>JSON和XML。</p>

<p><strong>64、用预处理指令#define声明一个常数，用以表明1年中有多少秒（忽略闰年问题）</strong></p>

<p>“#define SECONDS_PER_YEAR(60<em>60</em>24*365)UL”</p>

<p><strong>65、写一个”标准"宏MIN ，这个宏输入两个参数并返回较小的一个。</strong></p>

<p>“#define MIN(X,Y) ((X)>(Y)?(X):(Y))”</p>

<p><strong>66、+load和+initialize 的区别是什么？</strong></p>

<p>+initialize:第一次初始化这个类之前被调用，我们用它来初始化静态变量。</p>

<p>+load方法会在加载类的时候就被调用，也就是iOS应用启动的时候，就会加载所有的类。</p>

<p>+initialize方法类似一个懒加载，如果没有使用这个类，系统默认不会去调用这个方法，且默认只加载一次。</p>

<p>如果是在类别中，+load方法会全都执行，但是类别中的load方法会后于类中的方法，+initialize方法会覆盖类中的方法，只执行一个。</p>

<p>+initialize的调用发生在+init方法之前。子类会去调用父类的+initialize方法。</p>

<p><strong>67、new和alloc/init的区别</strong></p>

<p>概括来说，new和alloc/init在功能上几乎是一致的，分配内存并完成初始化。差别在于，采用new的方式只能采用默认的init方法完成初始化。而采用alloc的方式可以用其他定制的初始化方法。</p>

<p><strong>68、如果让你设计接口与API，应该注意点什么？</strong></p>

<p>（1）用前缀避免命名空间冲突</p>

<p>（2）提供“全能初始化方法”</p>

<p>（3）实现description方法</p>

<p>（4）尽量使用不可变对象</p>

<p>（5）使用清晰而协调的命名方法</p>

<p>（6）为私有方法名加前缀</p>

<p>（7）错误处理</p>

<p>（8）实现NSCopying协议。</p>

<p><strong>69、你在项目中用过懒加载吗？能简单的说说懒加载吗？</strong></p>

<p>懒加载又称为延迟加载。写的是其get方法。如果是懒加载的话则一定要注意先判断是否已经有了，如果没有那么再去进行实例化。</p>

<p>好处是不必将创建对象的代码全部写在viewDidLoad方法中，代码的可读性更强。每个控件的getter方法中分别负责各自的实例化处理，代码彼此之间的独立性强，松耦合。</p>

<p><strong>70、进程和线程的区别与联系。</strong></p>

<p>进程是个静态的容器，里面容纳了很多个线程，线程是一系列方法的线性执行路径。</p>

<p><strong>71、简述内存分区情况。</strong></p>

<p>栈区：存放函数的参数值，局部变量的值等。由编译器自动分配释放</p>

<p>堆区：由程序员分配释放。程序员如果不释放，则程序结束时可能由系统回收</p>

<p>全局区：全局变量和静态变量是存储在一块的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在另一块区域。程序结束后由系统释放。全局区可分为未初始化全局区：.bbs段和初始化全局区：data段。</p>

<p>常量区：存放常量字符串，程序结束后由系统释放</p>

<p>代码区：存放函数体的二进制代码。</p>

<p><strong>72、队列与栈有什么区别?</strong></p>

<p>栈：限定仅在表尾进行插入或删除操作的线性表。表尾是栈顶，表头是栈底。它又称后进先出线性表。</p>

<p>队列：是一种先进先出的线性表。它只允许在表的一端进行插入，而在另一端删除元素。</p>

<p><strong>73、Objective-C中多线程的编程方式有几种</strong></p>

<p>pthread、NSThread、NSOperation、GCD。</p>

<p><strong>74、Objective-C运行时（runtime）机制了解吗？简单的说说对象调用方法的过程。</strong></p>

<p>对象调用方法的过程：(<a href="http://tech.glowing.com/cn/objective-c-runtime/">Objective-C Runtime</a>)</p>

<p>（1）在对象类的dispatch table中尝试找到该消息。如果找到了，跳到相应的函数IMP去执行实现代码</p>

<p>（2）如果没有找到，Runtime会发送+resolveInstanceMethod: 或者 +resolveClassMethod: 尝试去resolve这个消息</p>

<p>（3）如果resolve方法返回NO，Runtime就发送 -forwardingTargetForSelector: 允许你把这个消息转发给另一个对象；</p>

<p>（4）如果没有新的目标对象返回，Runtime 就会发送 -methodSignatureForSelector: 和 -forwardInvocation: 消息。你可以发送 -invokeWithTarget: 消息来手动转发消息或者发送 -doesNotRecognizeSelector: 抛出异常。</p>

<p><strong>参考资料如下：</strong></p>

<p>（1）<a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md" target="_blank">《招聘一个靠谱的 iOS》—参考答案（上）</a></p>

<p>（2）<a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md" target="_blank">《招聘一个靠谱的 iOS》—参考答案（下）</a></p>

<p><strong>本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！</strong></p>

<p><strong>如需转载，请注明出处</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native iOS 开发环境搭建]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/21/react-native-ios-kai-fa-huan-jing-da-jian/"/>
    <updated>2016-01-21T01:07:09+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/21/react-native-ios-kai-fa-huan-jing-da-jian</id>
    <content type="html"><![CDATA[<h4>一、React Native基础环境搭建</h4>

<p>1、安装<a href="http://brew.sh">Homebrew</a></p>

<p>打开终端输入：
<code>
ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
</code></p>

<!--more-->


<p>2、安装<a href="https://github.com/creationix/nvm#installation">nvm</a>方法</p>

<p>通过脚本安装方式，在终端执行：
<code>
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.1/install.sh | bash
</code></p>

<p>激活nvm,在安装脚本执行完之后，在终端执行:
<code>
. ~/.nvm/nvm.sh
</code></p>

<p>nvm其他安装方式详见<a href="https://github.com/creationix/nvm#installation">安装向导</a></p>

<p>3、默认安装最新版本的Node.js并且设置好命令行的环境变量
<code>
nvm install node &amp;&amp; nvm alias default node
</code></p>

<p>可以输入node命令启动Node.js环境，npm(node package manager)文档传送门:<a href="https://docs.npmjs.com">&ldquo;点击此处&rdquo;</a></p>

<p>4、安装watchman</p>

<p>在终端输入：
<code>
brew install watchman
</code></p>

<p>到此处React Native基础环境搭建基本完成，推荐经常运行<code>brew update &amp;&amp; brew upgrade</code>命令保持你的程序是最新的。</p>

<h4>二、iOS开发环境</h4>

<p>1、iOS开发环境：（默认读者已经安装<strong>Xcode7.0或以上版本</strong>，没有可自行前往AppStore下载）</p>

<ul>
<li>使用npm（node包管理工具）安装react-native-cli(此处应注意权限问题，如果遇到权限问题，请在下面的命令前加上sudo)</li>
</ul>


<p><code>
npm install -g react-native-cli
</code></p>

<ul>
<li>初始化工程（下面的语句中千万不要加sudo，后果自负）</li>
</ul>


<p><code>
react-native init ReactNativeProject（工程名）
</code></p>

<p>在初始化的过程中，如果进度缓慢，推荐你将npm仓库源换成国内镜像：(翻墙用户请忽略)
在终端输入：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>npm config set registry https://registry.npm.taobao.org
</span><span class='line'>npm config set disturl https://npm.taobao.org/dist</span></code></pre></td></tr></table></div></figure>


<p>2、使用Xcode运行调试程序</p>

<ul>
<li>查找ReactNativeProject文件目录</li>
</ul>


<p>按住快捷键<code>Command+Shift+G</code>，在弹出的“前往文件夹”对话框中输入路径<code>/Users/yangshebing/ReactNativeProject</code>（yangshebing表示电脑用户名，请自行更改）,点击前往。在文件目中的ios文件夹下找到“ReactNativeProject.xcodeproj”工程文件。如图所示：（有关终端查找该文件目录方法，请自行到文章末尾的参考文章中寻找）
<img src="http://ww4.sinaimg.cn/large/7f266405jw1f0651k88wij216s0oa42t.jpg" alt="" /></p>

<ul>
<li>运行ReactNativeProject工程</li>
</ul>


<p>使用Xcode打开“ReactNativeProject.xcodeproj”工程文件，按住快捷键"Command+R"运行此项目，运行成功后便可在模拟器上看到效果。</p>

<ul>
<li>编辑index.ios.js文件修改界面</li>
</ul>


<p>笔者编辑index.ios.js文件工具是Vim，每当编辑完index.ios.js文件并保存之后，在模拟器(Simulator)中，按<code>Command+R</code>可刷新界面查看改变后的效果。</p>

<p>下面我们也试着稍微修改一下index.ios.js文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * Sample React Native App
</span><span class='line'> * https://github.com/facebook/react-native
</span><span class='line'> */
</span><span class='line'>'use strict';
</span><span class='line'>import React, {
</span><span class='line'>  AppRegistry,
</span><span class='line'>  Component,
</span><span class='line'>  StyleSheet,
</span><span class='line'>  //添加Image全局变量
</span><span class='line'>  Image,
</span><span class='line'>  Text,
</span><span class='line'>  View
</span><span class='line'>} from 'react-native';
</span><span class='line'>
</span><span class='line'>class ReactNativeProject extends Component {
</span><span class='line'>  render() {
</span><span class='line'>    return (
</span><span class='line'>      &lt;View style={styles.container}&gt;
</span><span class='line'>      //添加文本展示
</span><span class='line'>        &lt;Text style={styles.welcome}&gt;
</span><span class='line'>          美女
</span><span class='line'>        &lt;/Text&gt;
</span><span class='line'>        //添加图片展示
</span><span class='line'>        &lt;Image 
</span><span class='line'>        source= 
</span><span class='line'>        //这里需要指定图片的大小
</span><span class='line'>        style={styles.picture} /&gt;
</span><span class='line'>      &lt;/View&gt;
</span><span class='line'>    );
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>const styles = StyleSheet.create({
</span><span class='line'>  container: {
</span><span class='line'>    flex: 1,
</span><span class='line'>    justifyContent: 'center',
</span><span class='line'>    alignItems: 'center',
</span><span class='line'>    backgroundColor: '#F5FCFF',
</span><span class='line'>  },
</span><span class='line'>  //这里可以设置文本的字体，对齐方式等
</span><span class='line'>  welcome: {
</span><span class='line'>    fontSize: 20,
</span><span class='line'>    textAlign: 'center',
</span><span class='line'>    margin: 10,
</span><span class='line'>  },
</span><span class='line'>  //新增图片style，设置图片大小
</span><span class='line'>  picture: {
</span><span class='line'>    width: 80,
</span><span class='line'>    height: 150,
</span><span class='line'>  },
</span><span class='line'>});
</span><span class='line'>
</span><span class='line'>AppRegistry.registerComponent('ReactNativeProject', () =&gt; ReactNativeProject);</span></code></pre></td></tr></table></div></figure>


<p>刷新后运行效果如下图所示：
<img src="http://ww3.sinaimg.cn/mw690/7f266405jw1f06flkcxxgj20ku12a3zr.jpg" alt="" /></p>

<ul>
<li>真机运行调试项目</li>
</ul>


<p>在<code>ReactNativeProject</code>工程中找到AppDelegate.m文件，将<code>localhost</code>替换成自己电脑的IP地址。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//  jsCodeLocation = [NSURL URLWithString:@"http://localhost:8081/index.ios.bundle?platform=ios&dev=true"];
</span><span class='line'>
</span><span class='line'>  jsCodeLocation = [NSURL URLWithString:@"http://192.168.31.168:8081/index.ios.bundle?platform=ios&dev=true"];</span></code></pre></td></tr></table></div></figure>


<p>替换完成之后再次运行程序，这个时候可以通过摇晃设备唤出开发菜单。</p>

<ul>
<li>禁用开发菜单</li>
</ul>


<p>在打包提交市场前，需要禁用开发菜单。禁用开发菜单方法如下：
打开工程，选择<code>Product → Scheme → Edit Scheme</code>或使用快捷键“Command + &lt;”,在弹出的窗口中选择左边的Run菜单项。更改“Build Configuration” 设置项为“Release”。
<img src="http://ww1.sinaimg.cn/large/7f266405jw1f06e3sf5qjj21ds0s0tc2.jpg" alt="" /></p>

<h4>三、参考资料地址：</h4>

<ul>
<li><a href="https://facebook.github.io/react-native/docs/tutorial.html">React Native开发指南英文版（官方）</a></li>
<li><a href="http://reactnative.cn/docs/getting-started.html#content">React Native开发指南中文版</a></li>
<li><a href="http://www.cnblogs.com/meteoric_cry/p/4862314.html">React Native入门遇到的一些问题</a></li>
</ul>


<p><strong>此文仅供学习交流，转载请注明出处！</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift内存管理（ARC）之循环引用]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/15/swiftnei-cun-guan-li-(arc)zhi-xun-huan-yin-yong/"/>
    <updated>2016-01-15T01:37:31+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/15/swiftnei-cun-guan-li-(arc)zhi-xun-huan-yin-yong</id>
    <content type="html"><![CDATA[<p>Swift中是采用自动引用计数(ARC，AutomaticReferenceCounting)机制来对内存进行管理的。</p>

<h4>一、简述ARC如何工作：</h4>

<p>每当你每创建一个新的对象，它便会分配一块内存来存储该对象的相关信息。当你不再需要这个对象的时候，它就会自动释放这个对象，避免它再占用内存空间。当然，如果该对象只要至少存在一个引用就不会被释放。另外，你如果访问了一个已经被释放的对象，则很有可能会出现崩溃（野指针）。
拿《The Swift Programming Language》里面的例子来套一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//创建一个Cat类，自带常量name属性
</span><span class='line'>class Cat {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) {
</span><span class='line'>    //初始化name属性
</span><span class='line'>        self.name = name;
</span><span class='line'>        print("\(name) 对象已经被初始化")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(name) 对象释放成功！")
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>接下来定义三个变量类型为:Cat?用来对一个新的Cat对象建立多个引用。因为变量是一个可选类型（是Cat?而不是Cat）， 他们会自动给变量初始化为nil，所有当前它不需要引用一个Cat对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var cat1: Cat?
</span><span class='line'>var cat2: Cat?
</span><span class='line'>var cat3: Cat?</span></code></pre></td></tr></table></div></figure>


<p>创建一个新的Cat对象，并对之前定义的三个变量进行赋值操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat1 = Cat(name: "jack")
</span><span class='line'>//输出：jack 对象已经被初始化
</span></code></pre></td></tr></table></div></figure>


<p>当你调用Cat类构造器，它会输出："jack 对象已经被初始化"。这就代表已经完成了对象初始化操作。接下来，一个新的Cat对象被赋值给了 cat1变量，从而建立了cat1对新Cat实例对象的强引用。因此，它存在了至少一个强引用。这个新的Cat对象就不会被释放。
如果你把同一个Cat实例对象赋值给另外两个变量，它则又多建立了两个强引用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//通过赋值对Cat实例对象建立强引用
</span><span class='line'>cat2 = cat1
</span><span class='line'>cat3 = cat1</span></code></pre></td></tr></table></div></figure>


<p>此时这个Cat实例对象已经有三个强引用了。
如果你用把其中两个变量赋值为nil的方式来打破这些强引用，对象是不会被释放的。因为它还存在一个强引用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//通过把置nil来打破cat1,cat2对Cat实例对象的强引用
</span><span class='line'>cat1 = nil
</span><span class='line'>cat2 = nil</span></code></pre></td></tr></table></div></figure>


<p>只有直到对象所有的引用被打破，ARC才会释放该对象</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//打破最后一个强引用
</span><span class='line'>cat3 = nil
</span><span class='line'>//输出：jack 对象释放成功！</span></code></pre></td></tr></table></div></figure>


<p>当最后一个强引用被打破后，这个Cat对象被成功释放，输出：jack 对象释放成功！</p>

<h4>二、循环引用</h4>

<p>1、什么是循环引用？
简单的来说就是两个对象互相持有对方，使对方处于活跃状态不被释放，从而导致了循环引用。套个例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//创建一个Cat类，拥有一个String类型的name属性与一个可选类型的dog属性。
</span><span class='line'>class Cat {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name;
</span><span class='line'>        print("\(name) 对象已经被初始化")
</span><span class='line'>    }
</span><span class='line'>    var dog: Dog?
</span><span class='line'>    
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(name) 对象释放成功！")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//创建一个Dog类，拥有一个String类型的type属性与一个可选类型的jack属性。
</span><span class='line'>class Dog {
</span><span class='line'>    let type: String
</span><span class='line'>    init(type: String) {
</span><span class='line'>        self.type = type
</span><span class='line'>        print("\(type) 对象已经被初始化")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    var cat: Cat?
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(type) 对象释放成功")
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>定义两个变量并初始化</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var jack: Cat?
</span><span class='line'>var tom: Dog?
</span><span class='line'>
</span><span class='line'>jack = Cat(name: "jack")
</span><span class='line'>//print:jack 对象已经被初始化
</span><span class='line'>tom = Dog(type: "red")
</span><span class='line'>//print:red 对象已经被初始化</span></code></pre></td></tr></table></div></figure>


<p>建立强引用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>jack!.dog = tom
</span><span class='line'>tom!.cat = jack</span></code></pre></td></tr></table></div></figure>


<p>通过把对象置nil打破强引用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>jack = nil
</span><span class='line'>tom = nil</span></code></pre></td></tr></table></div></figure>


<p>这个地方Cat对象和Dog对象都不会被释放，因为他们两个之间还存在强引用。</p>

<ul>
<li><p>解决循环引用办法
  Swift提供了两种方法来解决循环引用问题：</p>

<p>  （1）弱引用（weak）</p>

<p>  （2）无主引用（unowned）</p></li>
</ul>


<p>声明变量或属性时，在前面加上"weak"关键词表示它是一个弱引用。如果确定访问属性或函数的时候该对象不会被释放，也可以用无主引用（unowned）来取代。unowned跟Objective-C中的unsafe_unretained类似。它与weak的区别在于weak在引用的对象被释放后，会自动置nil。所以它必须声明成可选类型（？）。而unowned在引用对象被释放后不会自动置nil(因为非可选类型的变量不能被设置成nil)，而是保留对原有对象的无效引用，一旦对象被释放，再访问该对象的属性或函数就会造成崩溃。官方建议是当你在可以确定访问属性或函数所属对象不会被释放时，使用unowned。否则，还是使用weak吧！</p>

<p>解决上面代码的循环引用问题，可做如下修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Dog {
</span><span class='line'>    let type: String
</span><span class='line'>    init(type: String) {
</span><span class='line'>        self.type = type
</span><span class='line'>        print("\(type) 对象已经被初始化")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    weak var jack: Cat
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(type) 对象释放成功")
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>jack = nil
</span><span class='line'>tom = nil</span></code></pre></td></tr></table></div></figure>


<p>2、常见的循环引用问题：</p>

<p>（1）delegate
在项目中我们经常会用到代理模式，在Objective-C中我们一般在delegate前面加上weak关键词，表示它是一个弱引用。从而达到打破循环引用的效果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//在前面加上@objc是指定这里的代码属于Objective-C的代码，因为Swift中协议可以用于class、struct、enum。对于基本数据类型，它不是对象，没有引用计数这个概念，因此无法使用weak关键词。  Objective-C中的协议只适用于类，所以这里需要加上@objc。
</span><span class='line'>@objc protocol AClassDelegate {
</span><span class='line'>    func wash()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class A {
</span><span class='line'>    weak var delegate: AClassDelegate!
</span><span class='line'>    func cry() {
</span><span class='line'>        
</span><span class='line'>    }
</span><span class='line'>    func play() {
</span><span class='line'>        delegate.wash()
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class B: AClassDelegate {
</span><span class='line'>    
</span><span class='line'>    func feed() {
</span><span class='line'>        let nurse = A()
</span><span class='line'>        nurse.delegate = self
</span><span class='line'>        nurse.cry()
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    @objc func wash() {
</span><span class='line'>        print("begin wash and sleep")
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>（2）Block(闭包)中的循环引用
Block(闭包)的循环引用在于它会持有所有引用的元素。比如我们在Block(闭包)中访问了self，那么它就持有了self。这样一来就形成了一个环：self持有Block(闭包)，Block(闭包)持有self。下面我们举个栗子加以说明：类A中有个闭包，我们在闭包中访问了self的name属性。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class A {
</span><span class='line'>    let name: String
</span><span class='line'>    lazy var wash: Void -&gt;Void = {
</span><span class='line'>        var name = self.name + " nurse"
</span><span class='line'>        print("wash room is \(name)")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>        print("\(self.name) 创建了")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(self.name) 释放了")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class B {
</span><span class='line'>    func play() {
</span><span class='line'>        var nurse: A?
</span><span class='line'>        nurse = A(name: "jack")
</span><span class='line'>        nurse?.wash()
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var baby: B?
</span><span class='line'>baby = B()
</span><span class='line'>baby?.play()
</span><span class='line'>
</span><span class='line'>输出结果：
</span><span class='line'>jack 创建了
</span><span class='line'>wash room is jack nurse</span></code></pre></td></tr></table></div></figure>


<p> 因为wash是self的一个属性，所以wash被self持有。这个时候我们又在闭包中访问了self的name属性，所以它又在闭包中持有了self。这样便导致了循环引用。为了解决闭包中的循环引用问题，Swift中提供了一个叫”闭包捕获列表”的解决方案。</p>

<ul>
<li>定义一个捕获列表</li>
</ul>


<p> 捕获列表中的每一项都是一个用weak或 unowned关键字与一个实例对象的引用（如self）或者是一个用初始化值的变量（如delegate = self.delegate!）搭配成对，配对之间用逗号隔开，最后用方括号括起来。如下所示：</p>

<pre><code class="`">
  lazy var someClosure:(Int, String) -&gt; String = {
        [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in

    }
</code></pre>

<p> 如果闭包中没有指定参数列表或者返回类型，可直接把捕获列表放置在闭包开始的地方（花括号后面）然后紧跟着是"in"关键词，示例代码如下：</p>

<pre><code class="``">  lazy var someClosure:Void -&gt; String = {
        [unowned self, weak delegate = self.delegate!]  in

    }
</code></pre>

<ul>
<li>解决Block(闭包)中的循环引用，ClassA中的Block(闭包)代码可做以下修改：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lazy var wash:Void -&gt;Void = { [weak self] in
</span><span class='line'>//这个地方使用self!.name而不是self.name。是因为weak修饰，self有可能为nil，如果是unowned修饰，这个地方应该是self.name。因为unowned修饰的self永远不可能为空。
</span><span class='line'>        var name = self!.name + " nurse"
</span><span class='line'>        print("wash room is \(name)")
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'> 输出结果：
</span><span class='line'>jack 创建了
</span><span class='line'>wash room is jack nurse
</span><span class='line'>jack 释放了</span></code></pre></td></tr></table></div></figure>


<h4>参考资料及文章</h4>

<ul>
<li><a herf="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/">《The Swift Programming Language》</a></li>
<li><a href="http://swifter.tips/retain-cycle/">内存管理，WEAK 和 UNOWNED </a></li>
<li><a href="http://skyfly.xyz/2015/12/18/Swift/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Swift学习笔记-内存管理</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中UITableView的用法(自定义UITableView和UITableViewCell)]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/04/swiftzhong-uitableviewde-yong-fa-zi-ding-yi-uitableviewhe-uitableviewcell/"/>
    <updated>2016-01-04T21:23:33+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/04/swiftzhong-uitableviewde-yong-fa-zi-ding-yi-uitableviewhe-uitableviewcell</id>
    <content type="html"><![CDATA[<p>一、自定义表视图（UITableView）</p>

<!--more-->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>import UIKit
</span><span class='line'>class HomeTableView: UITableView, UITableViewDataSource, UITableViewDelegate {
</span><span class='line'>//表视图的数据源：dataList
</span><span class='line'>    var dataList = [AnyObject]()
</span><span class='line'>//单元格的标识符：homeCellId
</span><span class='line'>    let identify = "homeCellId"
</span><span class='line'>    //重写表视图初始化方法
</span><span class='line'>    override init(frame: CGRect, style: UITableViewStyle) {
</span><span class='line'>        super.init(frame:frame, style:style)
</span><span class='line'>        //调用初始化子视图方法
</span><span class='line'>        initSubviews()
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    required init?(coder aDecoder: NSCoder) {
</span><span class='line'>        fatalError("init(coder:) has not been implemented")
</span><span class='line'>    }
</span><span class='line'>    //初始化表视图的子视图方法
</span><span class='line'>    func initSubviews () {
</span><span class='line'>    //设置数据源代理
</span><span class='line'>        dataSource = self;
</span><span class='line'>   //设置表视图代理
</span><span class='line'>        delegate = self;
</span><span class='line'>        //注册单元格class方式
</span><span class='line'>        registerClass(HomeCell.self, forCellReuseIdentifier: identify)
</span><span class='line'>       //设置表视图的分割线显示风格
</span><span class='line'>        separatorStyle = .None;
</span><span class='line'>        //注册单元格xib方式
</span><span class='line'>        //registerNib(UINib(nibName: "HomeCell", bundle: nil), forCellReuseIdentifier:identify)
</span><span class='line'>    }
</span><span class='line'>   //实现表视图返回组数代理方法：不实现默认为1
</span><span class='line'>    func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int {
</span><span class='line'>        return 1;
</span><span class='line'>    }
</span><span class='line'>//实现表视图返回行数代理方法
</span><span class='line'>    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
</span><span class='line'>        return dataList.count;
</span><span class='line'>    }
</span><span class='line'>    //实现表视图返回单元格代理方法
</span><span class='line'>    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
</span><span class='line'>    //取单元格
</span><span class='line'>        let cell = tableView.dequeueReusableCellWithIdentifier(identify) as! HomeCell
</span><span class='line'>        //设置单元格的选中风格
</span><span class='line'>        cell.selectionStyle = .None;
</span><span class='line'>        cell.titleStr = dataList[indexPath.row] as? String
</span><span class='line'>        return cell
</span><span class='line'>    }
</span><span class='line'>    //选中单元格的代理方法
</span><span class='line'>    func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
</span><span class='line'>        print("the indexpath row is \(indexPath.row)")
</span><span class='line'>    }
</span><span class='line'>    //返回单元格高度的代理方法
</span><span class='line'>    func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat {
</span><span class='line'>        return 80;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>二、自定义单元格（UITableViewCell）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import UIKit
</span><span class='line'>
</span><span class='line'>class HomeCell: UITableViewCell {
</span><span class='line'>//定义子视图变量
</span><span class='line'>    var imgView: UIImageView!
</span><span class='line'>    var titleLabel: UILabel!
</span><span class='line'>    var button: UIButton!
</span><span class='line'>    var titleStr: String?
</span><span class='line'>    // 重写单元格初始化方法
</span><span class='line'>    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {
</span><span class='line'>        super.init(style: style, reuseIdentifier: reuseIdentifier);
</span><span class='line'>        //调用单元格初始化方法
</span><span class='line'>        initSubviews()
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    required init?(coder aDecoder: NSCoder) {
</span><span class='line'>        fatalError("init(coder:)has not been implemented")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    override func awakeFromNib() {
</span><span class='line'>        super.awakeFromNib()
</span><span class='line'>        // Initialization code
</span><span class='line'>    }
</span><span class='line'>    //单元格子视图初始化方法
</span><span class='line'>    func initSubviews () {
</span><span class='line'>        imgView = UIImageView(frame: CGRectMake(0, 0, 30, 30))
</span><span class='line'>        imgView.image = UIImage(named: "exam.png")
</span><span class='line'>        contentView.addSubview(imgView);
</span><span class='line'>        
</span><span class='line'>        titleLabel = UILabel(frame: CGRectMake(0, 0, frame.size.width, frame.size.height))
</span><span class='line'>        titleLabel.textAlignment = .Left;
</span><span class='line'>        titleLabel.textColor = UIColor.lightGrayColor();
</span><span class='line'>        titleLabel.font = UIFont.systemFontOfSize(15);
</span><span class='line'>        titleLabel.text = "心灵鸡汤，每天一起干"
</span><span class='line'>        contentView.addSubview(titleLabel)
</span><span class='line'>        
</span><span class='line'>        button = UIButton(type: .Custom)
</span><span class='line'>        button.frame = CGRectMake(0, 0, frame.size.width, frame.size.height)
</span><span class='line'>        button.setTitle("关注", forState: .Normal)
</span><span class='line'>        button.setTitleColor(UIColor.whiteColor(), forState: .Normal)
</span><span class='line'>        button.backgroundColor = UIColor.grayColor()
</span><span class='line'>        contentView.addSubview(button)
</span><span class='line'>    }
</span><span class='line'>    //重写单元格布局子视图方法
</span><span class='line'>    override func layoutSubviews() {
</span><span class='line'>        super.layoutSubviews()
</span><span class='line'>        titleLabel.text = titleStr
</span><span class='line'>      //...
</span><span class='line'>      //布局单元格子视图
</span><span class='line'>      //...
</span><span class='line'>    override func setSelected(selected: Bool, animated: Bool) {
</span><span class='line'>        super.setSelected(selected, animated: animated)
</span><span class='line'>        // Configure the view for the selected state
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之基础控件（Swift版）]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/02/ioskai-fa-zhi-ji-chu-kong-jian-(swiftban-)/"/>
    <updated>2016-01-02T11:08:19+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/02/ioskai-fa-zhi-ji-chu-kong-jian-(swiftban-)</id>
    <content type="html"><![CDATA[<p>  1、文本（UILabel）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  let titleLabel = UILabel(frame: CGRectMake(0, 0, view.frame.size.width, view.frame.size.height))
</span><span class='line'>        //设置titleLabel的文本对齐方式：左：.Left, 中:.Center, 右:.Right
</span><span class='line'>        titleLabel.textAlignment = .Center
</span><span class='line'>        //设置titleLabel的文本颜色
</span><span class='line'>        titleLabel.textColor = UIColor.lightGrayColor()
</span><span class='line'>        //设置titleLabel文字的字体为系统字体，大小为15
</span><span class='line'>        titleLabel.font = UIFont.systemFontOfSize(15)
</span><span class='line'>        //设置titleLabel文字的字体为"Helvetica", 大小为15
</span><span class='line'>        titleLabel.font = UIFont(name: "Helvetica", size: 15)
</span><span class='line'>        titleLabel.text = "心灵鸡汤，每天一起干"
</span><span class='line'>        //titleLabel字体大小自适应宽度，根据指定宽度titleLabel自动调整字体显示大小
</span><span class='line'>        titleLabel.adjustsFontSizeToFitWidth = true
</span><span class='line'>        //指定titleLabel的显示行数，0代表自动折行
</span><span class='line'>        titleLabel.numberOfLines = 1
</span><span class='line'>        //获取系统所有字体名称
</span><span class='line'>        let fontFamily = UIFont.familyNames()
</span><span class='line'>        print(fontFamily)
</span><span class='line'>        view.addSubview(titleLabel)</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>2、按钮（UIButton）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//按钮类型：常见的两种如下
</span><span class='line'>         /**
</span><span class='line'>         *.Custom:自定义类型
</span><span class='line'>         *.System:系统类型（iOS7.0）
</span><span class='line'>         **/
</span><span class='line'>        let followButton = UIButton(type: .Custom)
</span><span class='line'>        followButton.frame = CGRectMake(100, 100, 100, 50)
</span><span class='line'>        //设置按钮在特定状态下的文本显示，常见的有：
</span><span class='line'>        /**
</span><span class='line'>         *.Normal:按钮常规显示状态
</span><span class='line'>         *.Selected:按钮选中显示状态
</span><span class='line'>         *.Highlighted:按钮高亮显示状态
</span><span class='line'>         *.Disabled:按钮关闭状态显示
</span><span class='line'>        **/
</span><span class='line'>        followButton.setTitle("关注", forState: .Normal)
</span><span class='line'>        //设置按钮在特定状态下的文本色值显示
</span><span class='line'>        followButton.setTitleColor(UIColor.whiteColor(), forState: .Normal)
</span><span class='line'>        //设置按钮在特定状态下的图片显示
</span><span class='line'>        followButton.setImage(UIImage(named: "back"), forState: .Normal)
</span><span class='line'>        followButton.setImage(UIImage(named: "select"), forState: .Disabled)
</span><span class='line'>        //设置按钮显示文本的字体大小
</span><span class='line'>        followButton.titleLabel?.font = UIFont.systemFontOfSize(15)
</span><span class='line'>        //设置按钮选中状态
</span><span class='line'>        followButton.selected = true
</span><span class='line'>        //设置按钮是否打开状态
</span><span class='line'>        followButton.enabled = true
</span><span class='line'>        //设置是否响应用户touch事件
</span><span class='line'>        followButton.userInteractionEnabled = true
</span><span class='line'>        //设置按钮的背景颜色
</span><span class='line'>        followButton.backgroundColor = UIColor.grayColor()
</span><span class='line'>        //关闭按钮处于高亮状态图片变暗显示状态
</span><span class='line'>        followButton.adjustsImageWhenHighlighted = false
</span><span class='line'>        //设置按钮图片的内部填充
</span><span class='line'>        followButton.imageEdgeInsets = UIEdgeInsetsMake(10, 10, 10, 10)
</span><span class='line'>        //设置按钮文本的内部填充
</span><span class='line'>        followButton.titleEdgeInsets = UIEdgeInsetsMake(10, 10, 10, 10)
</span><span class='line'>        //为按钮添加点击事件
</span><span class='line'>        followButton.addTarget(self, action: "followAction", forControlEvents: .TouchUpInside)
</span><span class='line'>        view.addSubview(followButton)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>按钮点击事件响应方法：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func followAction(sender: UIButton) {
</span><span class='line'>    print("关注")
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>3、图片展示视图（UIImageView）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let imgView = UIImageView(frame: CGRectMake(0, 0, view.frame.size.width, view.frame.size.height))
</span><span class='line'>        //设置图片视图显示图片
</span><span class='line'>        imgView.image = UIImage(named: "exam.png")
</span><span class='line'>        //设置图片视图高亮状态显示图片
</span><span class='line'>        imgView.highlightedImage = UIImage(named: "exam1.png")
</span><span class='line'>        //设置图片视图内容展示模式：常见的几种内容展示模式
</span><span class='line'>        /**
</span><span class='line'>        *.ScaleToFill:缩放图片填满整个图片视图
</span><span class='line'>        *.ScaleAspectFit:缩放内容以适应原图尺寸，没有铺满的地方保持透明
</span><span class='line'>        *.ScaleAspectFill:按钮高亮显示状态
</span><span class='line'>        **/
</span><span class='line'>        imgView.contentMode = .ScaleAspectFit
</span><span class='line'>        //设置图片视图是否高亮显示
</span><span class='line'>        imgView.highlighted = true
</span><span class='line'>        //设置是否响应用户touch事件,默认为false
</span><span class='line'>        imgView.userInteractionEnabled = true
</span><span class='line'>        //播放一组图片
</span><span class='line'>        let img1 = UIImage(named: "play1.png")!
</span><span class='line'>        let img2 = UIImage(named: "play2.png")!
</span><span class='line'>        let img3 = UIImage(named: "play3.png")!
</span><span class='line'>        let images = [img1, img2, img3]
</span><span class='line'>        //设置需要播放的一组图片
</span><span class='line'>        imgView.animationImages = images
</span><span class='line'>        //设置播放持续时间
</span><span class='line'>        imgView.animationDuration = 1
</span><span class='line'>        //设置播放重复次数
</span><span class='line'>        imgView.animationRepeatCount = 20
</span><span class='line'>        //开始播放
</span><span class='line'>        imgView.startAnimating()
</span><span class='line'>        //停止播放
</span><span class='line'>        imgView.stopAnimating()
</span><span class='line'>        
</span><span class='line'>        view.addSubview(imgView);</span></code></pre></td></tr></table></div></figure>


<p>4、文字输入框（UITextField）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let textField = UITextField(frame: CGRectMake(20, 100, 100,30))
</span><span class='line'>        //设置文本编辑框显示文字
</span><span class='line'>        textField.text = "将编程进行到底"
</span><span class='line'>        //设置文本编辑框占位文字
</span><span class='line'>        textField.placeholder = "客官，你想不想要？"
</span><span class='line'>        //设置文本编辑框的边框显示类型
</span><span class='line'>        textField.borderStyle = .RoundedRect
</span><span class='line'>        //设置文本编辑框的文字字体
</span><span class='line'>        textField.font = UIFont.systemFontOfSize(15)
</span><span class='line'>        //设置文本编辑框的文本颜色
</span><span class='line'>        textField.textColor = UIColor.blackColor()
</span><span class='line'>        //设置文本编辑框输入文本时首字母是否自动大写
</span><span class='line'>        textField.autocapitalizationType = .None
</span><span class='line'>        //设置文本编辑框清除按钮显示模式
</span><span class='line'>        textField.clearButtonMode = .WhileEditing
</span><span class='line'>        //设置文本编辑框的文本对齐方式
</span><span class='line'>        textField.textAlignment = .Center
</span><span class='line'>        //设置文本编辑框返回键显示类型
</span><span class='line'>        textField.returnKeyType = .Search
</span><span class='line'>        //设置是否为安全文本输入状态
</span><span class='line'>        textField.secureTextEntry = true
</span><span class='line'>        //设置输入键盘类型
</span><span class='line'>        textField.keyboardType = .NumberPad
</span><span class='line'>        //设置文本编辑框的代理
</span><span class='line'>        textField.delegate = self
</span><span class='line'>        //唤起键盘，让文本编辑框成为第一响应者
</span><span class='line'>        textField.becomeFirstResponder()
</span><span class='line'>        view.addSubview(textField)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>UITextFiled代理方法（UITextFiledDelegate）:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//将要开始编辑代理方法,此方法会在键盘弹出之前调用
</span><span class='line'>    func textFieldShouldBeginEditing(textField: UITextField) -&gt; Bool {
</span><span class='line'>        return true
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //已经开始编辑代理方法，此方法会在键盘弹出之后调用
</span><span class='line'>    func textFieldDidBeginEditing(textField: UITextField) {
</span><span class='line'>        print(textField.text)
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //当return按钮被点击时调用
</span><span class='line'>    func textFieldShouldReturn(textField: UITextField) -&gt; Bool {
</span><span class='line'>        //收起键盘，注销文本编辑框为第一响应者
</span><span class='line'>        textField.resignFirstResponder()
</span><span class='line'>        return true
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //将要结束编辑代理方法，此方法会在收起键盘的时候调用
</span><span class='line'>    func textFieldShouldEndEditing(textField: UITextField) -&gt; Bool {
</span><span class='line'>        return true
</span><span class='line'>    }
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<p>5、开关控件（UISwitch）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    let sliderControl = UISlider(frame: CGRectMake(30, 200, 100, 30))
</span><span class='line'>    //设置滑动条控件最大值
</span><span class='line'>    sliderControl.maximumValue = 10
</span><span class='line'>    //设置滑动条控件最小值
</span><span class='line'>    sliderControl.minimumValue = 1
</span><span class='line'>    //设置滑动条控件初始值
</span><span class='line'>    sliderControl.value = 5
</span><span class='line'>    //设置滑动条控件最大值方向颜色显示
</span><span class='line'>    sliderControl.maximumTrackTintColor = UIColor.redColor()
</span><span class='line'>    //设置滑动条控件最小值方向颜色显示
</span><span class='line'>    sliderControl.minimumTrackTintColor = UIColor.brownColor()
</span><span class='line'>    //设置滑动条控件拖动按钮颜色
</span><span class='line'>    sliderControl.thumbTintColor = UIColor.blueColor()
</span><span class='line'>    //设置滑动条控件最大值方向图片显示：正常状态
</span><span class='line'>    sliderControl.setMaximumTrackImage(UIImage(named: "slidermax.png"), forState: .Normal)
</span><span class='line'>    //设置滑动条控件最小值方向图片显示：正常状态
</span><span class='line'>    sliderControl.setMinimumTrackImage(UIImage(named: "slidermin.png"), forState: .Normal)
</span><span class='line'>    //设置滑动条控件拖动按钮显示图片：正常状态
</span><span class='line'>    sliderControl.setThumbImage(UIImage(named: "thumb.png"), forState: .Normal)
</span><span class='line'>    //为滑动条控件添加：值改变触发事件
</span><span class='line'>    sliderControl.addTarget(self, action: "sliderAction:", forControlEvents: .ValueChanged)
</span><span class='line'>    view.addSubview(sliderControl)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>开关值改变事件响应方法：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sliderAction(sliderControl: UISlider) {
</span><span class='line'>        print("the slider value is \(sliderControl.value)")
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>6、加载指示器视图（UIActivityIndicatorView）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let activityControl = UIActivityIndicatorView(frame: CGRectMake(100, 200, 30, 30))
</span><span class='line'>        //设置加载指示器视图的风格
</span><span class='line'>        activityControl.activityIndicatorViewStyle = .Gray
</span><span class='line'>        //设置加载指示器视图的背景颜色
</span><span class='line'>        activityControl.backgroundColor = UIColor.redColor()
</span><span class='line'>        //开始动画
</span><span class='line'>        activityControl.startAnimating()
</span><span class='line'>        //停止动画
</span><span class='line'>        activityControl.stopAnimating()
</span><span class='line'>        view.addSubview(activityControl)</span></code></pre></td></tr></table></div></figure>


<p>7、分段控件视图（UISegmentedControl）:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let items = ["全部", "电影", "新闻", "科技"]
</span><span class='line'>        let segmentedControl = UISegmentedControl(items: items)
</span><span class='line'>        segmentedControl.frame = CGRectMake(30, 200, 180, 30)
</span><span class='line'>        //设置分段控件颜色
</span><span class='line'>        segmentedControl.tintColor = UIColor.redColor()
</span><span class='line'>        //设置分段控件默认选中索引
</span><span class='line'>        segmentedControl.selectedSegmentIndex = 1
</span><span class='line'>        //为分段控件添加值改变响应事件
</span><span class='line'>        segmentedControl.addTarget(self, action: "segmentControlAction:", forControlEvents: .ValueChanged)
</span><span class='line'>        view.addSubview(segmentedControl)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>分段控件值改变事件响应方法：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func segmentControlAction(segmentedControl: UISegmentedControl) {
</span><span class='line'>        if segmentedControl.selectedSegmentIndex == 0 {
</span><span class='line'>
</span><span class='line'>        } else if segmentedControl.selectedSegmentIndex == 1 {
</span><span class='line'>
</span><span class='line'>        } else if segmentedControl.selectedSegmentIndex == 2{
</span><span class='line'>
</span><span class='line'>        } else {
</span><span class='line'>
</span><span class='line'>        }
</span><span class='line'>       print("the segmented Control selected Index is \(segmentedControl.selectedSegmentIndex)")
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>8、页面控件（UIPageControl）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let pageControl = UIPageControl(frame: CGRectMake(30, 200, 180, 30))
</span><span class='line'>        //设置页面控件的背景颜色
</span><span class='line'>        pageControl.backgroundColor = UIColor.brownColor()
</span><span class='line'>        //设置总页数
</span><span class='line'>        pageControl.numberOfPages = 4
</span><span class='line'>        //设置当前页数
</span><span class='line'>        pageControl.currentPage = 1
</span><span class='line'>        //设置页面控件指示器颜色
</span><span class='line'>        pageControl.pageIndicatorTintColor = UIColor.redColor()
</span><span class='line'>        //设置页面控件当前页面指示器颜色
</span><span class='line'>        pageControl.currentPageIndicatorTintColor = UIColor.blueColor()
</span><span class='line'>        //添加页面控件点击响应事件
</span><span class='line'>        pageControl.addTarget(self, action: "changeAction:", forControlEvents: .TouchUpInside)
</span><span class='line'>        view.addSubview(pageControl)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>页面控件点击响应事件：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func changeAction(pageControl: UIPageControl) {   
</span><span class='line'>  print("the current select page is :\(pageControl.currentPage)")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>9、警告视图控制器（UIAlertController）：(UIAlertView 与 UIActionSheet在iOS8.0之后就弃用了，推荐使用UIAlertController)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    /**
</span><span class='line'>     * .Alert
</span><span class='line'>     * .ActionSheet
</span><span class='line'>     */
</span><span class='line'>    let alertCtrl = UIAlertController(title: "提示信息", message: "确定返回吗？", preferredStyle: .Alert)
</span><span class='line'>    //初始化警告动作
</span><span class='line'>    let cancelAction = UIAlertAction(title: "取消", style: .Cancel) { (action) -&gt; Void in
</span><span class='line'>        //...
</span><span class='line'>        //添加相应处理代码
</span><span class='line'>        //...
</span><span class='line'>        //把UIAlertController从父视图控制器中移除，防止内存泄漏
</span><span class='line'>        alertCtrl.removeFromParentViewController()
</span><span class='line'>    }
</span><span class='line'>    let okAction = UIAlertAction(title: "立即返回", style: .Default) { (action) -&gt; Void in
</span><span class='line'>        //...
</span><span class='line'>        //添加相应处理代码
</span><span class='line'>        //...
</span><span class='line'>        //把UIAlertController从父视图控制器中移除，防止内存泄漏
</span><span class='line'>        alertCtrl.removeFromParentViewController()
</span><span class='line'>    }
</span><span class='line'>    //添加动作
</span><span class='line'>    alertCtrl.addAction(cancelAction)
</span><span class='line'>    alertCtrl.addAction(okAction)
</span><span class='line'>    //弹出警告视图控制器
</span><span class='line'>    self.presentViewController(alertCtrl, animated: true, completion: nil)</span></code></pre></td></tr></table></div></figure>


<p>10、 进度条视图（UIProgressView）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> let progressView = UIProgressView(progressViewStyle: .Bar)
</span><span class='line'>    progressView.frame = CGRectMake(30, 200, 180, 30)
</span><span class='line'>    //设置默认进度
</span><span class='line'>    progressView.progress = 0.3
</span><span class='line'>    //设置进度条加载过的颜色
</span><span class='line'>    progressView.progressTintColor = UIColor.redColor()
</span><span class='line'>    //设置进度条未加载过的颜色
</span><span class='line'>    progressView.trackTintColor = UIColor.blueColor()
</span><span class='line'>    //设置进度条加载过的图片展示
</span><span class='line'>    progressView.progressImage = UIImage(named: "progress.png")
</span><span class='line'>    //设置进度条未加载过的图片展示
</span><span class='line'>    progressView.trackImage = UIImage(named: "track.png")
</span><span class='line'>    view.addSubview(progressView)</span></code></pre></td></tr></table></div></figure>


<p>11、 工具条控件（UIToolBar）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    let toolBar = UIToolbar(frame: CGRectMake(30, 200, 180, 49))
</span><span class='line'>    //设置工具条展示风格
</span><span class='line'>    toolBar.barStyle = .Default
</span><span class='line'>    //添加工具条按钮
</span><span class='line'>    let item = UIBarButtonItem(barButtonSystemItem: .Done, target: self, action: "itemButtonAction")
</span><span class='line'>    let item1 = UIBarButtonItem(barButtonSystemItem: .Edit, target: self, action: "itemButtonAction")
</span><span class='line'>    //固定间距工具条按钮
</span><span class='line'>    let item2 = UIBarButtonItem(barButtonSystemItem: .FixedSpace, target: self, action: "itemButtonAction")
</span><span class='line'>    item2.width = 30
</span><span class='line'>    let customButton = UIButton(type: .DetailDisclosure)
</span><span class='line'>    customButton.addTarget(self, action: "itemButtonAction", forControlEvents: .TouchUpInside)
</span><span class='line'>    //自定义按钮为工具条按钮
</span><span class='line'>    let item3 = UIBarButtonItem(customView: customButton)
</span><span class='line'>    let items = [item, item1, item2, item3]
</span><span class='line'>    //设置工具条要显示的所有按钮
</span><span class='line'>    toolBar.items = items
</span><span class='line'>    view.addSubview(toolBar)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>工具条按钮点击响应事件：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func itemButtonAction() {
</span><span class='line'>        print("tool bar button")
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015年终总结]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/01/2015nian-zhong-zong-jie/"/>
    <updated>2016-01-01T13:26:26+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/01/2015nian-zhong-zong-jie</id>
    <content type="html"><![CDATA[<h4>总结：</h4>

<p>回首过去一年，好像没有什么能说出口的成绩，专业没啥进步。在公司做了两款App，上半年主要开发的是一款叫“在线等”的手机应用，这是一款解决人们选择困难症的应用，经过重重困难，最终上线。没啥成绩可言。下半年主要研发的是一款叫“斗图神器”的应用，由于Android版早就开发好了，所以iOS版开发起来就快很多了。总的来说成绩还不错，其中也有点小波折。<!--more-->现在已经提交过3，4版了。目前“斗图神器”项目已经引入了全新的Swift语言与Objective-C语言混编。目的是拥抱Swift，它才是未来。这对我们来说是好事，有项目环境学习新语言就更快了。现在我还是处于Swift 初级入门阶段，明年希望能进一步提高吧！在学习方面，搭建了自己的<a href="http://yangshebing.github.io"><strong>个人技术博客</strong></a>，另外还写了几篇质量不高的博文，在github上放了几个质量不高的demo。买了手机和电脑，这也算专业学习上的投入吧。生活上，除了每天写写代码，并没有什么其他变化。4月份去了一趟泰山，7月份去了一次十渡，10月份游了半个北京（虽然来北京久了，却很少出去）顺带去了一趟天津。今年最大的事情就是拔了一颗智齿和一颗蛀牙，花了不少钱，现在都没弄好！折腾了半条命（太背），一直不太顺。其次就是大病没犯，小病不断，北京这边雾霾比较严重。咽炎也挺折腾人的。本来年底是计划上线一款自己的app,由于各种借口各种拖最终没能实现，也没啥可遗憾的，主要是自己没有努力。其实还计划学习一门除专业外的语言，这个计划也耽搁了！计划内的写一个插件，现在也还没开动！专业书今年没有仔细读过，其实应该多读几本。扩展书籍就读过《高效能人士的7个习惯》与《从0到1》。总而言之就是读的书还是太少，平常大部分时间是在网上看别人的博客学习，看官方文档，不会的就自己用google搜索。人丑就要多读书。越来越不会说话了，已经想不起还有什么要说的了，那就先写到这吧！共勉！
2016的计划与展望：</p>

<h4>计划：</h4>

<ul>
<li>1、  读10本以上的专业相关的书籍，扩展阅读书籍不少于5本。</li>
<li>2、  学一门专业外的语言</li>
<li>3、  在github上开源5个项目（高质量）</li>
<li>4、  博客不少于50篇博文（高质量）</li>
<li>5、  找个女盆友</li>
<li>6、  福利计划：去国外旅游一次（条件如下）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if plan five implement {
</span><span class='line'>      implement plan six
</span><span class='line'>} else {
</span><span class='line'>      nothing happened
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>展望：</h4>

<p>马上迎来全新的2016年，又是一个全新的开始。时间匆匆，趁着年轻就要好好努力，物尽其用。希望在新的一年里，事业蒸蒸日上，身体健健康康（身体是革命的本钱，是实现计划的基石），愿家人幸福安康。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS FFmpeg编译及kxmovie、iFrameExtractor调试详解（无障碍阅读，绝对是你想要的）]]></title>
    <link href="http://yangshebing.github.io/blog/2015/11/16/ios-ffmpegbian-yi-ji-kxmovie,-iframeextractordiao-shi-xiang-jie-(wu-zhang-ai-yue-du-,jue-dui-shi-ni-xiang-yao-de-)/"/>
    <updated>2015-11-16T01:44:27+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/11/16/ios-ffmpegbian-yi-ji-kxmovie,-iframeextractordiao-shi-xiang-jie-(wu-zhang-ai-yue-du-,jue-dui-shi-ni-xiang-yao-de-)</id>
    <content type="html"><![CDATA[<p><strong>特此声明：本文是通过网上收集整理加上自己亲自实验得来的。感谢所有网上分享的辛勤劳动者，本文仅供iOS学习使用。在学习的过程中，如果有问题或者不清楚的地方，欢迎留言，我们共同探讨互相学习。欢迎批评指正。</strong></p>

<p><strong>如需转载，请注明出处：<a href = "http://blog.csdn.net/yangshebing21/article/details/43986913"><a href="http://blog.csdn.net/yangshebing21/article/details/43986913">http://blog.csdn.net/yangshebing21/article/details/43986913</a></a></strong></p>

<h4>开发环境：最新 ffmpeg-2.5.4/iOS SDK8.1/Xcode6.1/OS X Yosemite版本10.10.2</h4>

<h3>一、编译ffmpeg库</h3>

<h4>编译调试ffmpeg库的步骤：</h4>

<p><strong>开发环境：ffmpeg-2.5.4/Xcode6.1</strong></p>

<h4>（一）、下载ffmpeg源码：</h4>

<p>请点击此链接<a href = "http://ffmpeg.org/download.html"><a href="http://ffmpeg.org/download.html">http://ffmpeg.org/download.html</a></a></p>

<p> <font color = "red"><b>注：我的ffmpeg-2.5.4是解压放至Desktop的</b></font></p>

<h4>（二）、调试编译ffmpeg源码</h4>

<p> 1、安装yasm:
 <!--more--></p>

<p> 方法一:</p>

<p> 在终端输入</p>

<pre><code class="`"> sudo curlhttp://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz &gt;yasm.tar.gz
</code></pre>

<p>方法二：</p>

<p>（1）Download yasm sourcecode from：
  <a href = "http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz"><a href="http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz">http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz</a></a></p>

<p>（2）Unpack tar xvzfyasm-1.2.0.tar.gz</p>

<p>（3）cd yasm-1.2.0</p>

<p>（4）Configure and build:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./configure && make -j 4 &&sudo make install</span></code></pre></td></tr></table></div></figure>


<p>2、下载pearl脚本文件：gas-preprocessor.pl：</p>

<p>下载地址： <a href = "https://github.com/libav/gas-preprocessor"><a href="https://github.com/libav/gas-preprocessor">https://github.com/libav/gas-preprocessor</a></a></p>

<p>（1）拷贝gas-preprocessor.pl文件到 /usr/bin 目录下。</p>

<p>如果找不到/usr/bin目录，直接使用”Finder—>前往—> 前往文件夹—>/usr/bin”或者使用快捷键“shift+command+G”前往文件夹，到指定目录下粘贴gas-preprocessor.pl文件</p>

<p>（2）修改gas-preprocessor.pl文件的读写权限，使用 chmod a+rwxgas-preprocessor.pl</p>

<p>用终端命令cd定位到 gas-preprocessor.pl文件夹下执行：<code>chmod a+rwxgas-preprocessor.pl</code>命令</p>

<p>3、下载build-shell.sh脚本文件：</p>

<p>下载地址：<a href = "https://github.com/kewlbear/FFmpeg-iOS-build-script"><a href="https://github.com/kewlbear/FFmpeg-iOS-build-script">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></a></p>

<p>（1）下载解压build-shell.sh文件</p>

<p>（2）定位至build-shell.sh文件夹执行build-shell.sh脚本文件</p>

<p>使用方式有4种，我们可以根据特定的使用环境来执行对应的脚本，一般我们就直接执行：<code>./build-ffmpeg.sh</code></p>

<ul>
<li>To build everything:</li>
</ul>


<p><strong><code>./build-ffmpeg.sh</code></strong></p>

<ul>
<li>To build arm64 libraries：</li>
</ul>


<p><strong><code>./build-ffmpeg.sh arm64</code></strong></p>

<ul>
<li>To build fat libraries for armv7 and x86_64 (64-bit simulator)：</li>
</ul>


<p><strong><code>./build-ffmpeg.sh armv7 x86_64</code></strong></p>

<ul>
<li>To build fat libraries from separately built thin libraries:</li>
</ul>


<p><strong><code>./build-ffmpeg.sh lipo</code></strong></p>

<p>注：我的build-shell.sh是解压放至Desktop的，以上四种shell脚本的使用方式来自<a href = "https://github.com/kewlbear/FFmpeg-iOS-build-script"><a href="https://github.com/kewlbear/FFmpeg-iOS-build-script">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></a>，后面几种方式大家可以自己去尝试。</p>

<p>4、脚本执行完成之后，会在桌面上生成三个文件夹：“FFmpeg-iOS”“scratch”和”thin”文件夹</p>

<p>scratch文件夹里面是单独编译的库，FFmpeg-iOS文件夹里面是合并编译的库。在使用的过程中，我们主要会用到FFmpeg-iOS 文件夹下的“include”文件夹和"lib"文件夹中的文件。</p>

<h3>二、在工程中使用FFmpeg，网上成熟的有kxmovie。</h3>

<p>1、下载kxmovie工程进行测试：</p>

<p>下载地址： <a href = "https://github.com/kolyvan/kxmovie"><a href="https://github.com/kolyvan/kxmovie">https://github.com/kolyvan/kxmovie</a></a></p>

<p>把FFmpeg编译出来的.a文件添加到工程中。</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37q81fp5j205r09xwfq.jpg" alt="" /></p>

<p>在使用的时候得注意添加下面的动态链接库文件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>libz.dylib
</span><span class='line'>libbz2.dylib
</span><span class='line'>libiconv.dylib</span></code></pre></td></tr></table></div></figure>


<p><strong>运行工程</strong></p>

<p>以下是在编译运行工程中可能会报的错误：</p>

<p>注意：如果在FFmpeg编译的时候出现“ffmpeg yasm not found，use &ndash;disable for a crippled build”，原因是 yasm是汇编编译器，因为FFmpeg中为了提高效率用到了汇编指令，解决这个问题有两种方法，一是下载一个yasm.exe安装在mingw/bin下面；二是不使用汇编指令，在配置上加上 即 ./configure &ndash;disable-yash 。(这就是为什么前面提到了要安装yasm)
成功通过编译（这里是指FFmpeg编译成静态库文件）</p>

<p>通过后会生成一个compiled(FFmpeg-iOS)的文件夹，里面有include和lib两个文件夹，这两个文件夹都要拷贝至工程目录下面。include是静态链接库要用到的头文件，lib是存放静态链接库的文件，然后把这些文件存放在项目里面即可，一定要把文件也copy进去，然后在项目的build settings中的header search paths字段加入include文件的路径 如：“$(SRCROOT)/ffmpeg/include” 前面的复选框选不选都可以；再在library search paths字段中加入a文件的路径 如：“$(SRCROOT)/ffmpeg/lib” 。否则可能会出现libavformat/avformat.h file not found 的错误。（出现这个错误是指编译kxmovie工程找不到相应的头文件）</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37rw3nknj20m207wwgg.jpg" alt="" /></p>

<p>上面图示：在工程目录下有个“FFmpeg”的文件夹，分别把编译FFmpeg完成后产生的“ FFmpeg-iOS ”文件夹中的“include”和”lib”文件夹拷贝至”FFmpeg”文件夹中，include文件夹中存放的是头文件，lib文件夹中存放的是.a静态库文件。最后就是在工程目录下的FFmpeg文件夹包含“include”和”lib”两个文件夹。设置Header Search Paths和Library Search Paths时直接include和lib两个文件夹拖上去，自动显示路径。</p>

<p><img src="http://ww4.sinaimg.cn/large/7f266405jw1ey37subv8hj20gu06omye.jpg" alt="" /></p>

<p>如果还出现找不到 avformat_open_input 的错误（我的没有出现过这个错误），说明你的ffmpeg还是太新了，之前的那个方法名已经改成了这个名字，把avformat_open_input改成av_open_input_file 就可以了。其他错误请自行谷歌或者留言，我们共同探讨。
上面报错总结文章来自：<a href="http://www.dnetzj.com/Content/267.html">http://www.dnetzj.com/Content/267.html</a></p>

<p>最后一步，别忘了安装kxmovie.xcworkspace的cocoapods</p>

<p><strong><code>pod install --verbose --no-repo-update</code></strong></p>

<p>否则会报链接错误</p>

<p>以上kxmovie工程编译调试完毕，模拟器真机都通过测试。目前没有进一步的去研究这个工程，发现播放的视频质量有点粗糙。有时间再做进一步的研究。</p>

<h3>三、iFrameExtractor-master（iFrameExtractor）工程编译和运行</h3>

<p>（1）运行iFrameExtractor-master工程，与上面kxmovie工程操作一样，把FFmpeg文件夹拷贝至工程目录下:
       (工程目录下本来是没有FFmpeg文件夹的)</p>

<p><img src="http://ww1.sinaimg.cn/large/7f266405jw1ey37tiypu8j20gx07b75s.jpg" alt="" /></p>

<p>iFrameExtractor-master下载地址：<a href="https://github.com/lajos/iFrameExtractor">https://github.com/lajos/iFrameExtractor</a></p>

<p>(2)设置好Header Search Paths和Library Search Paths</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37u3v6q5j20kj02x0ts.jpg" alt="" /></p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37v057v9j20kg07p40a.jpg" alt="" /></p>

<p>（3）最后还是会报链接错误：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Undefined symbols for architecture i386:
</span><span class='line'>"_iconv", referenced from:      
</span><span class='line'>    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)  
</span><span class='line'>"_iconv_close", referenced from:
</span><span class='line'>    _avcodec_open2 in libavcodec.a(utils.o)
</span><span class='line'>    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)
</span><span class='line'>"_iconv_open", referenced from:
</span><span class='line'>    _avcodec_open2 in libavcodec.a(utils.o)
</span><span class='line'>    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)
</span><span class='line'>ld: symbol(s) not found for architecture i386
</span><span class='line'>clang: error: linker command failed with exit code 1 (use -v to see invocation)</span></code></pre></td></tr></table></div></figure>


<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37vhigjfj20fq0a8djf.jpg" alt="" /></p>

<p><strong>解决办法："TARGETS" - > &ldquo;BuildSettings&rdquo; - > &ldquo;Other Linker Flags&rdquo; 添加other Linker Flags 项：-liconv</strong></p>

<p><img src="http://ww1.sinaimg.cn/large/7f266405jw1ey37wvjqv1j20dl01s74f.jpg" alt="" /></p>

<p>此报错问题出自：<a href = "http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851"><a href="http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851">http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851</a></a></p>

<p>至此完成iFrameExtractor-master工程编译和运行</p>

<h3>本文参考文章资料：</h3>

<ul>
<li><a href = "http://blog.csdn.net/oqqQuZi1234567/article/details/43152689">iOS－－kxmovie之FFmpeg编译和使用</a></li>
<li><a href = "http://www.th7.cn/Program/Ruby/201502/385491.shtml">iOS ffmpeg kxmovie 编译 调试</a></li>
</ul>


<p><strong>欢迎共同学习进步，本着分享的精神，只是为了让你学习起来更加轻松。</strong></p>

<p><strong>如需转载，请注明出处：<a href = "http://blog.csdn.net/yangshebing21/article/details/43986913"><a href="http://blog.csdn.net/yangshebing21/article/details/43986913">http://blog.csdn.net/yangshebing21/article/details/43986913</a></a></strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UICollectionView（纯代码方式）实现带上下拉刷新的瀑布流式（WaterFlow）布局]]></title>
    <link href="http://yangshebing.github.io/blog/2015/11/03/waterflow/"/>
    <updated>2015-11-03T22:40:32+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/11/03/waterflow</id>
    <content type="html"><![CDATA[<p>瀑布流（WaterFlow）是项目开发过程中的常见布局，有关于瀑布流（WaterFlow）的实现方式：在UICollectionView未出现之前，瀑布流的实现多半是采用UIScrollView或是UITableView。对于我们这种用惯了表视图的人来说，UICollectionView倒略显陌生。有关于UICollectionView的介绍我就不一一赘述，因为一两句话也很难说清楚。网上有很多优秀的文章专门对其进行了一系列的解说，另有苹果官方文档可以查阅。本文主要是介绍如何采用纯代码的方式利用UICollectionView实现带上下拉刷新的瀑布流式（WaterFlow）布局。废话少说，直接入题。</p>

<!--more-->


<h4>一、UICollectionView集成上下拉刷新</h4>

<p>（1）简单的介绍UICollectionView</p>

<p>UICollectionView和UITableView很相似，如果你对表视图非常熟悉，上手的速度也会快很多。使用它时需要相应的设置DataSource（UICollectionViewDataSoure)数据源协议和Delegate（UICollectionViewDelegate)事件协议，并实现相应的协议方法。它与UITableView不同的地方是它有UICollectionViewLayout，可以通过它的子类来定制布局。系统默认的布局方式是UICollectionViewDelegateFlowLayout，实现相应的协议（UICollectionViewDelegateFlowLayout）方法，便可达到默认布局效果。</p>

<p>UICollectionViewCell与UITableViewCell的使用也差不多，一样的有ReuseIdentifier,可以复用。使用UICollectionViewCell时，需要先注册，然后再出列使用。至于注册并出列使用Cell的具体方式，请自行下载文章末尾的BGWaterFlowView或者自行Google。</p>

<p>（2）集成上下拉刷新方式</p>

<p>一般UITableView添加上下拉刷新的方式，是把下拉或者上拉刷新视图的UI放置UITableView的表头属性(tableHeaderView)或者表尾属性（tableFooterView）。但是，在UICollectionView中没有这两个属性。那么我们该如何来集成上下拉刷新呢？这就得说到
UICollectionView布局中的三种显示内容视图：Cells、Supplementary views、Decoration views。(关于这三种视图的介绍可以去官网查阅相关文档，上面有详细的解释)。我们一般是把上下拉刷新的UI放置在Supplementary views（官方解释：它能显示数据但是不同于Cells。不像Cell,Supplementary views是不能被用户选定的。相反，你可以用它去实现类似于给一个指定的section或者整个CollectionView添加页眉和页脚视图这样的功能）上面，其实，Supplementary views就和TableView的section头视图和尾视图差不多。但是用法却大不相同。在自定义瀑布流布局中一定要把它也计算进去，不然显示就会有异常。</p>

<ul>
<li><strong>注册头视图和尾视图单元格类型</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//注册头视图：kind代表Supplementary视图类型，UICollectionElementKindSectionHeader表示组头
</span><span class='line'>
</span><span class='line'>[self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"bGCollectionHeaderView"];
</span><span class='line'>
</span><span class='line'>//注册尾视图：UICollectionElementKindSectionHeader表示组尾
</span><span class='line'>
</span><span class='line'>    [self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"bGCollectionFooterView"];
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>实现自定义组视图viewForSupplementaryElementOfKind代理方法</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath {
</span><span class='line'>
</span><span class='line'>  //kind代表Supplementary视图类型：头或尾视图（header OR footer）
</span><span class='line'>  
</span><span class='line'>    if([kind isEqual:UICollectionElementKindSectionHeader]) {
</span><span class='line'>        UICollectionReusableView *collectionHeaderView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"bGCollectionHeaderView" forIndexPath:indexPath];
</span><span class='line'>        
</span><span class='line'>        //初始化下拉刷新或者自定义页眉视图UI界面
</span><span class='line'>        ...
</span><span class='line'>        
</span><span class='line'>        return collectionHeaderView;
</span><span class='line'>    } else if([kind isEqual:UICollectionElementKindSectionFooter]) {
</span><span class='line'>        UICollectionReusableView *collectionFooterView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"bGCollectionFooterView" forIndexPath:indexPath];
</span><span class='line'>        
</span><span class='line'>        //初始化上拉刷新或者自定义页脚视图UI界面
</span><span class='line'>        ...
</span><span class='line'>        
</span><span class='line'>        return collectionFooterView;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return nil;
</span><span class='line'>}
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<p>完成以上两步，集成上下拉刷新的功能总算完成了。接下来你可以运行一下工程，看结果是否符合预期。如果你CollectionView使用的是系统的UICollectionViewFlowLayout布局，一定要返回组头或者组尾的高度，否则就会出现组头或者组尾无法显示（本文的下拉刷新视图所在的组头不返回高度不受影响，是因为它的纵坐标（y值）本来就是负数）。另外，还有一点需要注意的是，如果你的CollectionView中存在多组，最好是把上下拉刷新所在的组头或者组尾与其他组（section）的组头或组尾分开，相应的需要多注册一个组头或者组尾视图，分情况进行判断(这部分如果还有问题，可以在文章末尾留言，我会及时回复)。</p>

<h4>二、自定义瀑布流（WaterFlow）式布局</h4>

<p>（1）简单的介绍UICollectionView布局形式</p>

<p>一般来讲，UICollectionView的布局形式分为两种：</p>

<ul>
<li><p>布局与内容独立，其布局不需要根据显示的单元格内容来计算。Cell的显示顺序与内容顺序一致。Cell排满一行则换至下一行继续排列。系统的UICollectionViewFlowLayout就是这样。</p></li>
<li><p>布局需要计算内容，本文的瀑布流Demo局部正是如此。UICollectionViewFlowLayout系统布局在换行的时候，由于每个item高度不同，从而导致布局错乱，无法满足你的需求。所以，这个时候你需要计算每个item的高度，最终用来确定item显示的位置。</p></li>
</ul>


<p>从上述内容我们可以看出，一般如果布局需要计算内容的时候，我们就不应该直接使用UICollectionViewFlowLayout布局了，而是应该子类化一个UICollectionViewLayout，从而达到私人定制的目的。</p>

<p>（2）创建自定义布局</p>

<p><a href = "https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/CreatingCustomLayouts/CreatingCustomLayouts.html#//apple_ref/doc/uid/TP40012334-CH5-SW1">官方文档</a>中有提到，在布局的过程中，CollectionView会调用布局对象的具体方法。这些方法有机会使你计算这些项的位置以及给CollectionView提供它所需要的主要信息。其他的方法也有可能会被调用，但是在布局的过程中这些方法总是会按照以下的顺序调用：</p>

<ol>
<li>使用"prepareLayout"方法去执行一些CollectionView所需要的布局信息的预先计算操作。</li>
<li>使用"collectionViewContentSize"方法去返回根据你最初计算的整个内容区域的总体大小。</li>
<li>使用"layoutAttributesForElementsInRect:&ldquo;方法来返回指定区域的单元格与视图属性。</li>
</ol>


<p>下面我们通过Demo来详细的讲解一下如何自定义瀑布流，废话不多说，直接上代码（本文采用的Demo为<strong>BGWaterFlowView</strong>,<strong>GitHub传送门</strong>：<a href = 'https://github.com/yangshebing/BGWaterFlowView'>请点击这里</a>）：</p>

<ul>
<li><strong>重写"prepareLayout"方法计算布局信息。</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)prepareLayout{
</span><span class='line'>    [super prepareLayout];
</span><span class='line'>    ...
</span><span class='line'>    
</span><span class='line'>    //计算每个显示项的宽度，horizontalItemSpacing代表项与项之间的水平间隔， 
</span><span class='line'>    columnNum代表总列数，contentInset代表上下左右的内填充。详见下图说明
</span><span class='line'>    
</span><span class='line'>    self.itemWidth = (self.collectionView.frame.size.width - (self.horizontalItemSpacing * (self.columnNum - 1)) - self.contentInset.left - self.contentInset.right) / self.columnNum;
</span><span class='line'>    
</span><span class='line'>    //如有下拉刷新需求的则需要提供头视图（Supplementary view）布局属性。
</span><span class='line'>    demo中的headerHeight属性可设置是否显示头视图（是否计算头视图的布局属性）。
</span><span class='line'>    
</span><span class='line'>    if(self.headerHeight &gt; 0){
</span><span class='line'>    
</span><span class='line'>    //通过layoutAttributesForSupplementaryViewOfKind:withIndexPath:方法来创建Supplementary视图布局属性对象，kind用来区分Supplementary视图类型（header或者footer）。
</span><span class='line'>    
</span><span class='line'>        self.headerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionHeader withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];
</span><span class='line'>        
</span><span class='line'>        //修改布局参数frame属性
</span><span class='line'>        
</span><span class='line'>        self.headerLayoutAttributes.frame = CGRectMake(0, 0, self.collectionView.frame.size.width, self.headerHeight);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //初始化保存布局属性的字典
</span><span class='line'>    NSMutableDictionary *cellLayoutInfoDic = [NSMutableDictionary dictionary];
</span><span class='line'>    //初始化列高数组
</span><span class='line'>    NSMutableArray *columnInfoArray = [self columnInfoArray];
</span><span class='line'>    NSInteger numSections = [self.collectionView numberOfSections];
</span><span class='line'>    for(NSInteger section = 0; section &lt; numSections; section++)  {
</span><span class='line'>        NSInteger numItems = [self.collectionView numberOfItemsInSection:section];
</span><span class='line'>        for(NSInteger item = 0; item &lt; numItems; item++){
</span><span class='line'>            //获取列高最小的model，以它的高作为y坐标
</span><span class='line'>            BGWaterFlowModel *firstModel = columnInfoArray.firstObject;
</span><span class='line'>            CGFloat y = firstModel.height;
</span><span class='line'>            CGFloat x = self.contentInset.left + (self.horizontalItemSpacing + self.itemWidth) * firstModel.column;
</span><span class='line'>            
</span><span class='line'>            NSIndexPath *indexPath = [NSIndexPath indexPathForItem:item inSection:section];
</span><span class='line'>            
</span><span class='line'>            //通过代理方法传入对应item的高度。
</span><span class='line'>            
</span><span class='line'>            CGFloat itemHeight = [((id&lt;BGWaterFlowLayoutDelegate&gt;)self.collectionView.delegate) collectionView:self.collectionView layout:self heightForItemAtIndexPath:indexPath];
</span><span class='line'>            
</span><span class='line'>            //通过layoutAttributesForCellWithIndexPath:方法来创建cell的布局属性对象。
</span><span class='line'>            
</span><span class='line'>            UICollectionViewLayoutAttributes *itemAttributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];
</span><span class='line'>            //计算item的布局属性
</span><span class='line'>            itemAttributes.frame = CGRectMake(x, y+self.contentInset.top+self.headerHeight, self.itemWidth, itemHeight);
</span><span class='line'>            //计算当前列高,verticalItemSpacing代表项与项之间的垂直间隔。
</span><span class='line'>            firstModel.height += (itemHeight + self.verticalItemSpacing);
</span><span class='line'>            //保存新的列高，并进行排序：从后往前查找，查找到高度比它小的对象，就插入到该对象之后。
</span><span class='line'>            [self sortArrayByHeight:columnInfoArray];
</span><span class='line'>            
</span><span class='line'>     //保存计算好的item布局属性
</span><span class='line'>     cellLayoutInfoDic[indexPath] = itemAttributes;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //保存局部布局属性字典到全局字典中
</span><span class='line'>    self.cellLayoutInfoDic = [cellLayoutInfoDic copy];
</span><span class='line'>    
</span><span class='line'>    //按照前面的排序逻辑，列高数组中的最后一个元素，就是高度最大的一列。
</span><span class='line'>    BGWaterFlowModel *lastModel = columnInfoArray.lastObject;
</span><span class='line'>    
</span><span class='line'>    //如有上拉刷新需求的则需要提供尾视图布局属性。
</span><span class='line'>    demo中的footerHeight属性可设置是否显示尾视图（是否计算尾视图的布局属性）。
</span><span class='line'>    
</span><span class='line'>    if(self.footerHeight &gt; 0){
</span><span class='line'>        self.footerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionFooter withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];
</span><span class='line'>        //计算尾视图的布局属性
</span><span class='line'>        self.footerLayoutAttributes.frame = CGRectMake(0, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom, self.collectionView.frame.size.width, self.footerHeight);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //直接计算出collectionView的contentSize
</span><span class='line'>    self.contentSize = CGSizeMake(self.collectionView.frame.size.width, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom+self.footerHeight);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p><strong>好吧，这么一大坨代码看到就头疼了，来张图帮助理解一下！图糙理不糙，理解万岁</strong>
<img src="http://ww4.sinaimg.cn/mw690/7f266405jw1ey25ujzticj218a0xmjww.jpg" alt="" /></p>

<p><strong>这样看上去是不是更清晰了？</strong></p>

<ul>
<li><strong>重写"collectionViewContentSize"方法返回collectionView的内容高度。</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (CGSize)collectionViewContentSize{
</span><span class='line'>  //返回计算好的collectionView内容高度
</span><span class='line'>    return self.contentSize;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>重写"layoutAttributesForElementsInRect"方法返回指定矩形区域中的cell或者其他类型视图布局属性。</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect {
</span><span class='line'>
</span><span class='line'>  //返回一组已经计算好的布局属性。
</span><span class='line'>  
</span><span class='line'>    NSMutableArray *attributesArrs = [NSMutableArray array];
</span><span class='line'>    [self.cellLayoutInfoDic enumerateKeysAndObjectsUsingBlock:^(NSIndexPath *indexPath,
</span><span class='line'>                                                                UICollectionViewLayoutAttributes *attributes,
</span><span class='line'>                                                                BOOL *stop) { 
</span><span class='line'>        //遍历布局属性保存字典，添加布局属性至数组中                                                       
</span><span class='line'>        if (CGRectIntersectsRect(rect, attributes.frame)) {
</span><span class='line'>            [attributesArrs addObject:attributes];
</span><span class='line'>        }
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    //如果有头视图或者尾视图则需要添加头视图与尾视图的布局属性
</span><span class='line'>    
</span><span class='line'>    if (self.headerLayoutAttributes && CGRectIntersectsRect(rect, self.headerLayoutAttributes.frame)) {
</span><span class='line'>        [attributesArrs addObject:self.headerLayoutAttributes];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    
</span><span class='line'>    if (self.footerLayoutAttributes && CGRectIntersectsRect(rect, self.footerLayoutAttributes.frame)) {
</span><span class='line'>        [attributesArrs addObject:self.footerLayoutAttributes];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return attributesArrs;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>结语：</h4>

<p><a href = "https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/index.html#//apple_ref/occ/cl/UICollectionViewLayout">UICollectionViewLayout</a>相关的内容姿势非常多，相关文章也非常多。本文介绍的瀑布流布局也只是其中的冰山一角，很多东西官方文档中已经介绍的非常详细了。所以，还是建议多看官方文档。本文主要注重项目的实用性，在后面就直接上代码了，可能在理论方面还是有所欠缺，对于不足的地方，希望大家多提建议，一起交流学习，一起进步。如果文中有看不懂的地方，还请您留言。我会及时进行回复。最后，本文的Demo就在于方便徒手撸代码的人使用。你懂的。后期会不断的更新优化，进一步的完善。敬请期待&hellip;</p>

<p>点击此处下载本文的Demo:<a href = 'https://github.com/yangshebing/BGWaterFlowView'><strong>BGWaterFlowView</strong></a></p>

<p>Demo使用方式详见:<a href = "https://github.com/yangshebing/BGWaterFlowView/blob/master/README.md"><strong>README.md</strong></a></p>

<p>Demo运行瀑布流效果截图如下所示:</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey0z6x4xf9j20ku12aqb5.jpg"/ width = "375" height = "677" align = "center"></p>

<h6>参考博客地址：</h6>

<ul>
<li><a href = "http://objccn.io/issue-3-3/">自定义 Collection View 布局</a></li>
</ul>


<p>转载请注明出处</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS绘制虚线方式总结]]></title>
    <link href="http://yangshebing.github.io/blog/2015/10/12/ioshui-zhi-xu-xian-fang-shi-zong-jie/"/>
    <updated>2015-10-12T23:44:28+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/10/12/ioshui-zhi-xu-xian-fang-shi-zong-jie</id>
    <content type="html"><![CDATA[<h3>一、iOS中绘制虚线常见的几种方式：</h3>

<p>1、重写drawRect方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)drawRect:(CGRect)rect
</span><span class='line'>{
</span><span class='line'>    [super drawRect:rect];
</span><span class='line'>CGContextRef currentContext = UIGraphicsGetCurrentContext();
</span><span class='line'>//设置虚线颜色
</span><span class='line'>    CGContextSetStrokeColorWithColor(currentContext, [UIColor BlackColor].CGColor);
</span><span class='line'>    //设置虚线宽度
</span><span class='line'>    CGContextSetLineWidth(currentContext, 1);
</span><span class='line'>    //设置虚线绘制起点
</span><span class='line'>    CGContextMoveToPoint(currentContext, 0, 0);
</span><span class='line'>    //设置虚线绘制终点
</span><span class='line'>    CGContextAddLineToPoint(currentContext, self.frame.origin.x + self.frame.size.width, 0);
</span><span class='line'>    //设置虚线排列的宽度间隔:下面的arr中的数字表示先绘制3个点再绘制1个点
</span><span class='line'>    CGFloat arr[] = {3,1};
</span><span class='line'>    //下面最后一个参数“2”代表排列的个数。
</span><span class='line'>    CGContextSetLineDash(currentContext, 0, arr, 2);
</span><span class='line'>    CGContextDrawPath(currentContext, kCGPathStroke);
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>2、采用CAShapeLayer方式绘制虚线</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CAShapeLayer *shapeLayer = [CAShapeLayer layer];
</span><span class='line'>[shapeLayer setBounds:self.bounds];
</span><span class='line'>[shapeLayer setPosition:CGPointMake(self.frame.size.width / 2.0, self.frame.size.height)];
</span><span class='line'>[shapeLayer setFillColor:[UIColor clearColor].CGColor];
</span><span class='line'>//设置虚线颜色
</span><span class='line'>shapeLayer setStrokeColor:[UIColor BlackColor].CGColor];
</span><span class='line'>//设置虚线宽度
</span><span class='line'>[shapeLayer setLineWidth:self.frame.size.height];
</span><span class='line'>[shapeLayer setLineJoin:kCALineJoinRound];
</span><span class='line'>//设置虚线的线宽及间距
</span><span class='line'> [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:3], [NSNumber numberWithInt:1], nil]];
</span><span class='line'> //创建虚线绘制路径
</span><span class='line'> CGMutablePathRef path = CGPathCreateMutable();
</span><span class='line'> //设置虚线绘制路径起点
</span><span class='line'> CGPathMoveToPoint(path, NULL, 0, 0);
</span><span class='line'> //设置虚线绘制路径终点
</span><span class='line'> CGPathAddLineToPoint(path, NULL, self.frame.size.width, 0);
</span><span class='line'> //设置虚线绘制路径
</span><span class='line'> [shapeLayer setPath:path];
</span><span class='line'> CGPathRelease(path);
</span><span class='line'> //添加虚线
</span><span class='line'> [self.layer addSublayer:shapeLayer];
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<h5>关于这种方式已经有人整理出了一个非常好用的类方法，具体请参看文章末尾的参考博客地址：“iOS绘制虚线方法【原创】”一文，此方法使用起来非常简单方便。</h5>

<h6><strong><font color="red">注意：下面非完整代码，如有需要，请自行前往该博文中直接复制使用。</font></strong></h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> ** lineView:       需要绘制成虚线的view
</span><span class='line'> ** lineLength:     虚线的宽度
</span><span class='line'> ** lineSpacing:    虚线的间距
</span><span class='line'> ** lineColor:      虚线的颜色
</span><span class='line'> **/
</span><span class='line'> 
</span><span class='line'>+ (void)drawDashLine:(UIView *)lineView lineLength:(int)lineLength lineSpacing:(int)lineSpacing lineColor:(UIColor *)lineColor
</span><span class='line'>{
</span><span class='line'>    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
</span><span class='line'>    .....
</span><span class='line'>    [shapeLayer setStrokeColor:lineColor.CGColor];
</span><span class='line'>    ......
</span><span class='line'>    [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:lineLength], [NSNumber numberWithInt:lineSpacing], nil]];
</span><span class='line'>  　......
</span><span class='line'>    [lineView.layer addSublayer:shapeLayer];
</span><span class='line'>    
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>3、经济实惠型：采用贴图的方式绘制虚线（需要设计师切图配合）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIImageView *imgDashLineView =[[UIImageView alloc] initWithFrame:CGRectMake(15, 200, self.view.frame.size.width - 30, 1)];
</span><span class='line'>
</span><span class='line'>[imgDashLineView setBackgroundColor:[UIColor colorWithPatternImage:[UIImage imageNamed:@"xuxian.png"]]];
</span><span class='line'>
</span><span class='line'>[self.view addSubview:imgDashLineView];
</span></code></pre></td></tr></table></div></figure>


<p>在以上这几种方式中我个人比较偏爱最后一种，简单粗暴。</p>

<p>以上内容部分来自于网络，本着分享的学习精神，如有涉及侵权问题，请及时告知。欢迎一起探讨学习，有问题请留言。我将会在第一时间对你的问题进行回复。如需转载，请注明出处。</p>

<h6>参考博客地址：</h6>

<ul>
<li>1、<a href="http://blog.it985.com/14080.html">iOS绘制虚线方法【原创】</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于GitHub搭建Octopress个人技术博客(Mac版)]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/17/test/"/>
    <updated>2015-09-17T23:42:42+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/17/test</id>
    <content type="html"><![CDATA[<h6>作为一名屌逼的程序猿，肯定是要有一个屌逼的技术博客。在交流学习的同时，顺便见证自己成长的心路历程。废话不多说，直接进入正题。编程讲究的四门功课，“说，学，逗，唱”。不会就学嘛！没有就找嘛！网上相关的文章简直太多了！其中原理就不多说，我且按照我搭建的顺序写一下步骤吧！</h6>

<p><strong>注意事项：在搭建之前，检查MAC电脑是否已经安装了Git和Ruby 1.9.3及以上版本。（Mac默认均已自带，ruby请自行检查版本：ruby &ndash;version，如果缺少，当自行下载）</strong></p>

<h4>一、开始安装octopress</h4>

<!--more-->


<p>1、将Octopress从github上clone到本地</p>

<pre><code class="`">git clone git://github.com/imathis/octopress.git octopress
cd octopress
</code></pre>

<p>2、安装Octopress</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem install bundler
</span><span class='line'>bundle install
</span><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>


<p>如果当你执行“bundle install”这步失败了，请更改一下本地octopress文件夹下Gemfile文件当中的源（路径：/Users/用户名/octopress/Gemfile），将文件中的<code>source "https://rubygems.org"</code>更换成 <code>source "http://ruby.taobao.org/"</code>,然后保存文件再重新执行bundle install及其后续操作。</p>

<p>3、部署GitHub Pages
在CitHub中新建一个名为username.github.io的仓库（username为你的GitHub用户名）。</p>

<ul>
<li>开始配置GitHub Pages</li>
</ul>


<p>在终端继续输入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages</span></code></pre></td></tr></table></div></figure>


<p>在Repository url后面粘贴username.github.io仓库对应的url地址</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Enter the read/write url for your repository
</span><span class='line'>(For example, 'git@github.com:your_username/your_username.github.io.git)
</span><span class='line'>           or 'https://github.com/your_username/your_username.github.io')
</span><span class='line'>Repository url: </span></code></pre></td></tr></table></div></figure>


<p>把上面代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>https://github.com/your_username/your_username.github.io”
</span><span class='line'>或者
</span><span class='line'>“git@github.com:your_username/your_username.github.io.git</span></code></pre></td></tr></table></div></figure>


<p>中的your_username替换成自己GitHub用户名即可。（两种地址，前者是HTTPS地址，后者是SSH地址，任选一个粘贴即可）</p>

<p>现在可以开始生成自己的第一篇博客并部署放至GitHub上。
在终端输入以下命令：生成一篇新的博客</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post['test']</span></code></pre></td></tr></table></div></figure>


<p>其中test是默认的博客标题（当然博客的标题可以在markdown文件里面更改）。当然你也可以输入rake new_post命令，按照终端的提示输入博客的标题。生成完成的文章内容在octopress/source/_posts目录下。文件名为时间＋标题名，如“2015-09-17-test.markdown”。可以用markdown工具（本文用的markdown工具为“Mou”）进行编辑与修改。</p>

<p>接下来在终端输入rake generate命令生成静态文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate</span></code></pre></td></tr></table></div></figure>


<p>在部署到GitHub上之前，你可以在本地预览一下博客的效果。
先在终端输入rake preview命令，生成预览blog。然后在浏览器中输入<code>http://localhost:4000</code>查看博客的预览效果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake preview</span></code></pre></td></tr></table></div></figure>


<p>在终端退出预览效果：ctrl+c</p>

<p>确认效果之后，开始部署至GitHub。rake deploy命令会将octopress/public目录下的文件上传至仓库的master分支。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<p>最后一步，将Octopress的源码提交至GitHub</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m 'commit source file'
</span><span class='line'>git push origin source</span></code></pre></td></tr></table></div></figure>


<p>完工，屌逼的第一篇博客就已经发布到GitHub Pages上了。你现在可以输入:username.github.io在线查看自己的博客了（如：yangshebing.github.io）。</p>

<p>至于其中的相关原理分析我就不一一赘述了。请参看文章末尾的参考文章链接或者自行网上搜索。</p>

<h4>二、简单的配置Octopress</h4>

<h6>1、修改Octopress的配置文件（路径：octopress/_config.yml）</h6>

<ul>
<li>设置博客的标题，子标题以及作者相关信息。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>title: 杨社兵的技术博客
</span><span class='line'>subtitle: 业精于勤荒于嬉，行成于思毁于随.
</span><span class='line'>author: 杨社兵</span></code></pre></td></tr></table></div></figure>


<ul>
<li>删除twitter相关信息（GFW造成页面加载慢）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Twitter
</span><span class='line'>twitter_user:
</span><span class='line'>twitter_tweet_button: true</span></code></pre></td></tr></table></div></figure>


<ul>
<li>修改source/_includes目录下的head.html文件：将<code>//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.jst</code>替换成<code>http://cdn.staticfile.org/jquery/1.9.1/jquery.min.jst</code>（解决页面加载过慢问题）</li>
<li>修改source/_includes/custom目录下的自定义head.html文件，去掉google自定义字体（解决页面加载过慢问题）</li>
</ul>


<h6>2、添加统计工具（百度统计）</h6>

<p>去<a href="http://tongji.baidu.com">百度统计</a>官网申请一个账号，在管理界面选择“代码获取”，复制代码至<code>source/_includes/custom/footer.html</code>文件中。</p>

<h6>3、自定义博客导航栏</h6>

<p>部署好博客之后，你会发现导航栏上默认的只有两项：Blog、Archives，无法满足我们的需求。比如我们想在导航栏上添加一个选项为“关于我”。</p>

<p>打开“/source/_includes/custom”目录的navigation.html文件进行编辑：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*&lt;ul class="main-navigation"&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://yangshebing.github.io/"&gt;我的博客&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://yangshebing.github.io/blog/archives"&gt;所有文章&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://weibo.com/yangshebing" target="_blank"&gt;新浪微博&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://yangshebing.github.io/about"&gt;关于我&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span></code></pre></td></tr></table></div></figure>


<p>接下来在终端输入rake new_page命令，生成一个index.markdown文件，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_page['about']</span></code></pre></td></tr></table></div></figure>


<p>它的默认保存路径是：“source/about/index.markdown”，编辑index.markdown文件，即可定制“关于我”页面内容。</p>

<h6>4、关于博客的评论和分享到微博功能，请参考末尾文章链接《象写程序一样写博客：搭建基于github的博客》一文。</h6>

<p>参考文章链接：</p>

<p>（1）<a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/" target="_blank">象写程序一样写博客：搭建基于github的博客</a></p>

<p>（2）<a href="http://matrixzk.github.io/blog/20141020/octopress-setup-and-analysis/#section" target="_blank">使用 Octopress 2.0 搭建基于 Github Pages 个人博客的详细过程及原理分析</a></p>

<p>（3）<a href="http://www.jianshu.com/p/0ac2ac1a8e45" target="_blank">octopress博客搭建和个性化配置</a></p>

<p>（4）<a href="https://liuchungui.github.io/blog/2015/09/11/macdian-nao-shang-da-jian-octopressbo-ke/" target="_blank">Mac电脑上搭建octopress博客</a></p>

<p>（5）<a href="http://www.cnblogs.com/sawyerzhu/p/3710374.html" target="_blank">Mac环境下octopress个人博客搭建</a></p>

<p>（6）<a href="http://foggry.com/blog/2014/04/28/custom-your-octopress-blog/" target="_blank">自定义你的Octopress博客</a></p>

<p>（7）<a href="http://blog.devtang.com/blog/2014/06/02/use-gitcafe-to-host-blog/" target="_blank">将博客从GitHub迁移到GitCafe</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中点击状态栏让滑动视图回到顶部]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/13/arcticle/"/>
    <updated>2015-09-13T23:28:31+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/13/arcticle</id>
    <content type="html"><![CDATA[<h6>在产品开发过程中，有时候会有这种需求，需要点击状态栏让滑动视图（UIScrollView）或者表视图（UITableView）返回到顶部，让用户可以更快的浏览最新的信息。</h6>

<h6>这个时候我们需要设置滑动视图的scrollsToTop属性，让它决定点击状态栏是否返回顶部。</h6>

<!--more-->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// When the user taps the status bar, 
</span><span class='line'>the scroll view beneath the touch which is closest to the status bar will be scrolled to top,
</span><span class='line'> but only if its scrollsToTop property is YES, 
</span><span class='line'> its delegate does not return NO from shouldScrollViewScrollToTop,
</span><span class='line'>  and it is not already at the top. 
</span><span class='line'>// On iPhone, we execute this gesture only if there’s one on-screen scroll view with scrollsToTop == YES.
</span><span class='line'> If more than one is found, none will be scrolled.
</span><span class='line'>@property(nonatomic) BOOL scrollsToTop; // default is YES.</span></code></pre></td></tr></table></div></figure>


<h6>设置这个属性，可以让点击状态栏不返回顶部。如果我们需要让它点击状态栏回到顶部，我们可以把这个属性值设置为YES（默认为YES）。按正常情况来说，这个时候点击状态栏是可以返回到顶部。但是点击状态栏还是没有反应怎么办？</h6>

<h6>解决方法如下：</h6>

<h6>按照上面官方文档的说法，只有把当前主控制器需要设置的那个scrollview找到并把它的scrollsToTop属性设置为YES，然后再把其他scrollview的scrollsToTop属性设置为NO 。这样它才会响应这个事件。其中的原理非常简单，如果当前主控制器中有2个scrollview，系统压根就不知道你想要其中的哪个scrollview滑动到顶部。</h6>

<h6>举个栗子：</h6>

<ul>
<li>假设当前控制器中有三个表视图（UITableView）或者滑动视图(UIScrollView)要切换，把当前显示的滑动视图scrollsToTop属性设置为YES,其他滑动视图的scrollsToTop属性设置为NO即可。</li>
</ul>


<p><strong>注意：如果当前滑动视图中存在子视图也是滑动视图的情况，那么它子视图中的滑动视图scrollsToTop属性也要设置为NO，不然它仍然会造成点击状态栏无法响应返回到顶部操作。</strong></p>

<h6>参考博客地址：</h6>

<ul>
<li><a href="http://blog.sina.com.cn/s/blog_463dc5b90101k9ib.html">点击状态栏不返回顶部问题</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift语言编程]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/12/swift/"/>
    <updated>2015-09-12T12:53:21+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/12/swift</id>
    <content type="html"><![CDATA[<h4>Swift语言基础学习</h4>

<ul>
<li>导入系统类库头文件（swift中称之为模块）</li>
</ul>


<p><code>
import UIKit
</code></p>

<ul>
<li>定义一个常量</li>
</ul>


<p><code>
let a = 5
</code></p>

<ul>
<li>定义一个变量</li>
</ul>


<p><code>
var str = "Hello, World!"
</code></p>

<ul>
<li>swift中打印输出</li>
</ul>


<p><code>
print("Hi,Girl!");
</code></p>

<p><strong>注意事项：如果在一行内想要写多条语句时需要用分号隔开，一行内写一句代码分号可加可不加（不推荐加）</strong></p>

<!--more-->


<p><code>
//一行内多句代码
let dog = "ddd";print(dog)
</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//一行内一句代码
</span><span class='line'>let my = "我的"
</span><span class='line'>let age = 20
</span><span class='line'>let sex = "male"
</span><span class='line'>print(my)
</span><span class='line'>print(age)
</span><span class='line'>print(sex)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>一次性定义多个变量</li>
</ul>


<p><code>
var a = 0.0, b = 0.0, c = 0.0
</code></p>

<ul>
<li>定义变量并赋初值</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var a : Float = 5;
</span><span class='line'>var userName = "yangshebing"</span></code></pre></td></tr></table></div></figure>


<ul>
<li>字符串插值方式：相当于占位符输出</li>
</ul>


<p><code>
print("the user name is \(userName)”)
</code></p>

<ul>
<li>定义一个指定类型的变量</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var name : String
</span><span class='line'>name = "yangshebing";
</span><span class='line'>print(name);</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：在Swift中支持多行注释嵌套</strong></p>

<ul>
<li>定义一个数组</li>
</ul>


<p>最简单粗暴的方法：</p>

<p><code>
let array = ["a", "b", "c"]
</code></p>

<p>常规写法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let array1: [String] = ["A", "B", "C"]
</span><span class='line'>let array2: Array&lt;String&gt; = ["A", "B", "D”]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>整数和浮点数之间转换</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let num = 3
</span><span class='line'>let pointNum = 0.14159
</span><span class='line'>let pi = Double(num) + pointNum
</span><span class='line'>let numPi = Int(pi)
</span><span class='line'>//Float转换成Int类型时，实型值总是会被缩短，意味着4.75将会变成4, -3.9将会变成-3
</span><span class='line'>print(numPi)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>自定义类型别名</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typealias MyIntType = Int
</span><span class='line'>let num : MyIntType = 10</span></code></pre></td></tr></table></div></figure>


<ul>
<li>布尔</li>
</ul>


<p>Swift 有一个基本布尔类型，称之为Bool。它提供了两个布尔常量值:true和false</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let isMore = true
</span><span class='line'>let isRainy = false</span></code></pre></td></tr></table></div></figure>


<ul>
<li>布尔类型在if语句中的使用</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let isApple = true
</span><span class='line'>if isApple {
</span><span class='line'>    println("this is Apple")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>使用布尔类型应当注意事项：Swift的类型安全机制会防止non-Boolean代替Bool值，比如下面的代码就会报编译时错误：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let num = 1
</span><span class='line'>if num {
</span><span class='line'>  //这个例子编译的时候会报错，但是在Objective-C语言中不会。
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>正确使用的方式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let number = 1
</span><span class='line'>if number == 1 {
</span><span class='line'>    println("this is one")
</span><span class='line'>    //这个编译成功
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>另外，这里提一下：在Swift中判断两个对象是否相等是使用”===“”!=="</p>

<ul>
<li>Swift中元组的使用</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//定义一个元组
</span><span class='line'>let salaryCombination = （10000, "one month"）
</span><span class='line'>//它代表的是一个（Int, String）类型的元组</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//分解元组
</span><span class='line'>let (salary, month) = salaryCombination
</span><span class='line'>print("The salary is \(salary)")
</span><span class='line'>print("The month is \(month)")
</span><span class='line'>//你如果只需要元组的一部分值，你也可以这样写
</span><span class='line'>let (salary,_)
</span><span class='line'>print(the salary is \(salary))</span></code></pre></td></tr></table></div></figure>


<ul>
<li>元组取值方式总结</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>方式一
</span><span class='line'>let firstSalary = (10000, "one month")
</span><span class='line'>let (salary1,month1) = firstSalary
</span><span class='line'>let secondSalary = (20000,"two month")
</span><span class='line'>let (salary2, month2) = secondSalary
</span><span class='line'>print("一月收入month1: \(salary1)")
</span><span class='line'>print("二月收入month2: \(salary2)”)
</span><span class='line'>
</span><span class='line'>//方式二
</span><span class='line'>let firstSalary = (10000, "one month")
</span><span class='line'>let (salary1,month1) = firstSalary
</span><span class='line'>let secondSalary = (20000,"two month")
</span><span class='line'>let (salary2, month2) = secondSalary
</span><span class='line'>//输出元组中的第0个元素， firstSalary.0：firstSalary代表元组名，0代表下标
</span><span class='line'>print("一月的收入month1: \(firstSalary.0)")
</span><span class='line'>print("二月的收入month2: \(secondSalary.0)”)
</span><span class='line'>
</span><span class='line'>//方式三
</span><span class='line'>let firstSalary = (salary : 10000,month : "one month")
</span><span class='line'>let (salary1,month1) = firstSalary
</span><span class='line'>let secondSalary = (salary :20000,month : "two month")
</span><span class='line'>let (salary2, month2) = secondSalary
</span><span class='line'>//输出元组中的第0个元素， firstSalary.salary：firstSalary代表元组名，salary代表元组元素的名字
</span><span class='line'>print("一月的收入month1: \(firstSalary.salary)")
</span><span class='line'>print("二月的收入month2: \(secondSalary.salary)")</span></code></pre></td></tr></table></div></figure>


<h4>本文参考文章资料：</h4>

<ul>
<li>《The Swift Programming Language》</li>
</ul>


<p><strong>欢迎共同学习进步，本着分享的精神，只是为了让你学习起来更加轻松。</strong></p>

<p><strong>如需转载，请注明出处</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态限制UITextField或UITextView用户输入中英文混编字数统计]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/12/test/"/>
    <updated>2015-09-12T11:31:37+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/12/test</id>
    <content type="html"><![CDATA[<p><strong>动态限制用户输入字数，这个在很多app中都会涉及，由于NSString的Length属性获取的长度中英文都是一个字节，不满足一个汉字两个字节、一个字符一个字节的需求。网上的方法大致是以下两种：</strong></p>

<h6>1、使用Unicode编码把OC中的NSString字符串转换成C的字符串。然后对字符串遍历进行统计长度。</h6>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>-  (int)convertToInt:(NSString*)strtemp {  
</span><span class='line'>    int strlength = 0;
</span><span class='line'>    char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding];
</span><span class='line'>    for (int i=0 ; i&lt;[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding];i++) {
</span><span class='line'>        if (*p) {
</span><span class='line'>            p++;
</span><span class='line'>            strlength++;
</span><span class='line'>        }
</span><span class='line'>        else {
</span><span class='line'>            p++;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return strlength;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h6>2、直接计算OC中的NSString字符串中单词的个数</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSInteger)countWordWithStr:(NSString *)s
</span><span class='line'>{
</span><span class='line'>    NSInteger i,n=[s length],l=0,a=0,b=0;
</span><span class='line'>    unichar c;
</span><span class='line'>    for(i=0;i&lt;n;i++){
</span><span class='line'>        c=[s characterAtIndex:i];
</span><span class='line'>        if(isblank(c)){
</span><span class='line'>            b++;
</span><span class='line'>        }else if(isascii(c)){
</span><span class='line'>            a++;
</span><span class='line'>        }else{
</span><span class='line'>            l++;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    if(a==0 && l==0) return 0;
</span><span class='line'>    return l+(NSInteger)ceilf((float)(a+b)/2.0);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>以上资料均为网上整理得来，仅供学习交流使用。有关于此类问题，欢迎在最下方留言一起探讨优化学习。</strong></p>

<h6>参考博客地址：</h6>

<ul>
<li>1、<a href="http://mobilesolutions.blog.163.com/blog/static/18922417620116133910181/">统计含中英文混编的NSString 字符串长度 </a></li>
<li>2、<a href="http://blog.csdn.net/toss156/article/details/8993270">【IOS】IOS开发常用函数</a></li>
<li>3、<a href="http://code.qtuba.com/article-60968.html">iOS - 推断输入字符串长度函数</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
