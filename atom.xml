<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[杨社兵的技术博客]]></title>
  <link href="http://yangshebing.github.io/atom.xml" rel="self"/>
  <link href="http://yangshebing.github.io/"/>
  <updated>2016-05-01T22:54:35+08:00</updated>
  <id>http://yangshebing.github.io/</id>
  <author>
    <name><![CDATA[杨社兵]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS面试题系列之常见算法]]></title>
    <link href="http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-chang-jian-suan-fa/"/>
    <updated>2016-04-24T23:59:06+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-chang-jian-suan-fa</id>
    <content type="html"><![CDATA[<h4>iOS面试中熟悉常见算法</h4>

<p>1、    对以下一组数据进行降序排序（冒泡排序）。“24，17，85，13，9，54，76，45，5，63”</p>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main(int argc, char *argv[]) {
</span><span class='line'>  int array[10] = {24, 17, 85, 13, 9, 54, 76, 45, 5, 63};
</span><span class='line'>      int num = sizeof(array)/sizeof(int);
</span><span class='line'>      for(int i = 0; i &lt; num-1; i++) {
</span><span class='line'>          for(int j = 0; j &lt; num - 1 - i; j++) {
</span><span class='line'>                  if(array[j] &lt; array[j+1]) {
</span><span class='line'>                          int tmp = array[j];
</span><span class='line'>                              array[j] = array[j+1];
</span><span class='line'>                              array[j+1] = tmp;
</span><span class='line'>                          }
</span><span class='line'>                  }
</span><span class='line'>          }
</span><span class='line'>  
</span><span class='line'>  for(int i = 0; i &lt; num; i++) {
</span><span class='line'>          printf("%d", array[i]);
</span><span class='line'>              if(i == num-1) {
</span><span class='line'>                  printf("\n");
</span><span class='line'>                  }
</span><span class='line'>              else {
</span><span class='line'>                  printf(" ");
</span><span class='line'>                  }
</span><span class='line'>          }
</span><span class='line'>  }
</span></code></pre></td></tr></table></div></figure>


<p>2、    对以下一组数据进行升序排序（选择排序）。“86, 37, 56, 29, 92, 73, 15, 63, 30, 8”</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>void sort(int a[],int n)
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>    int i, j, index;
</span><span class='line'>    
</span><span class='line'>    for(i = 0; i &lt; n - 1; i++) {
</span><span class='line'>        
</span><span class='line'>        index = i;
</span><span class='line'>        
</span><span class='line'>        for(j = i + 1; j &lt; n; j++) {
</span><span class='line'>        
</span><span class='line'>            if(a[index] &gt; a[j]) {
</span><span class='line'>            
</span><span class='line'>                index = j;
</span><span class='line'>                
</span><span class='line'>            }
</span><span class='line'>            
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        if(index != i) {
</span><span class='line'>        
</span><span class='line'>            int temp = a[i];
</span><span class='line'>            
</span><span class='line'>            a[i] = a[index];
</span><span class='line'>            
</span><span class='line'>            a[index] = temp;
</span><span class='line'>            
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int main(int argc, const char * argv[]) {
</span><span class='line'>
</span><span class='line'>    int numArr[10] = {86, 37, 56, 29, 92, 73, 15, 63, 30, 8};
</span><span class='line'>    
</span><span class='line'>    sort(numArr, 10);
</span><span class='line'>    
</span><span class='line'>    for (int i = 0; i &lt; 10; i++) {
</span><span class='line'>    
</span><span class='line'>        printf("%d, ", numArr[i]);
</span><span class='line'>        
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    printf("\n");
</span><span class='line'>    
</span><span class='line'>    return 0;
</span><span class='line'>    
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>3、    快速排序算法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void sort(int *a, int left, int right) {
</span><span class='line'>if(left &gt;= right) {
</span><span class='line'>return ;
</span><span class='line'>}
</span><span class='line'>int i = left;
</span><span class='line'>int j = right;
</span><span class='line'>int key = a[left];
</span><span class='line'>while (i &lt; j) {
</span><span class='line'>while (i &lt; j && key &gt;= a[j]) {
</span><span class='line'>j--;
</span><span class='line'>}
</span><span class='line'>a[i] = a[j];
</span><span class='line'>while (i &lt; j && key &lt;= a[i]) {
</span><span class='line'>  i++;
</span><span class='line'>  }
</span><span class='line'>a[j] = a[i];
</span><span class='line'>}
</span><span class='line'>a[i] = key;
</span><span class='line'>sort(a, left, i-1);
</span><span class='line'>sort(a, i+1, right);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>4、    归并排序</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void merge(int sourceArr[], int tempArr[], int startIndex, int midIndex, int endIndex) {
</span><span class='line'>    int i = startIndex;
</span><span class='line'>        int j = midIndex + 1;
</span><span class='line'>        int k = startIndex;
</span><span class='line'>        while (i != midIndex + 1 && j != endIndex + 1) {
</span><span class='line'>            if (sourceArr[i] &gt;= sourceArr[j]) {
</span><span class='line'>                    tempArr[k++] = sourceArr[j++];
</span><span class='line'>                    } else {
</span><span class='line'>                    tempArr[k++] = sourceArr[i++];
</span><span class='line'>                     }
</span><span class='line'>            }        while (i != midIndex + 1) {
</span><span class='line'>            tempArr[k++] = sourceArr[i++];
</span><span class='line'>            }        while (j != endIndex + 1) {
</span><span class='line'>            tempArr[k++] = sourceArr[j++];
</span><span class='line'>            }        for (i = startIndex; i &lt;= endIndex; i++) {
</span><span class='line'>            sourceArr[i] = tempArr[i];
</span><span class='line'>            }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>void sort(int souceArr[], int tempArr[], int startIndex, int endIndex) {
</span><span class='line'>    int midIndex;
</span><span class='line'>        if (startIndex &lt; endIndex) {
</span><span class='line'>            midIndex = (startIndex + endIndex) / 2;
</span><span class='line'>                sort(souceArr, tempArr, startIndex, midIndex);
</span><span class='line'>                sort(souceArr, tempArr, midIndex + 1, endIndex);
</span><span class='line'>                merge(souceArr, tempArr, startIndex, midIndex, endIndex);
</span><span class='line'>            }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>int main(int argc, const char * argv[]) {
</span><span class='line'>    int numArr[10] = {86, 37, 56, 29, 92, 73, 15, 63, 30, 8};
</span><span class='line'>        int tempArr[10];
</span><span class='line'>        sort(numArr, tempArr, 0, 9);
</span><span class='line'>        for (int i = 0; i &lt; 10; i++) {
</span><span class='line'>            printf("%d, ", numArr[i]);
</span><span class='line'>            }
</span><span class='line'>        printf("\n");
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'></span></code></pre></td></tr></table></div></figure>


<p>5、    实现二分查找算法（编程语言不限）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int bsearchWithoutRecursion(int array[],int low,int high,int target) {
</span><span class='line'>while(low &lt;= high) {
</span><span class='line'>int mid = (low + high) / 2;
</span><span class='line'>if(array[mid] &gt; target)
</span><span class='line'>high = mid - 1;
</span><span class='line'>else if(array[mid] &lt; target)
</span><span class='line'>low = mid + 1;
</span><span class='line'>else  //findthetarget
</span><span class='line'>return mid;
</span><span class='line'>}
</span><span class='line'>//the array does not contain the target
</span><span class='line'>return -1;
</span><span class='line'>}
</span><span class='line'>----------------------------------------
</span><span class='line'>递归实现
</span><span class='line'>int binary_search(const int arr[],int low,int high,int key){
</span><span class='line'>int mid=low + (high - low) / 2;
</span><span class='line'>if(low &gt; high)
</span><span class='line'>return -1;
</span><span class='line'>else{
</span><span class='line'>if(arr[mid] == key)
</span><span class='line'>  return mid;
</span><span class='line'>else if(arr[mid] &gt; key)
</span><span class='line'>return binary_search(arr, low, mid-1, key);
</span><span class='line'>else
</span><span class='line'>return binary_search(arr, mid+1, high, key);
</span><span class='line'>}
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>6、    如何实现链表翻转（链表逆序）？思路：每次把第二个元素提到最前面来。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h&gt;
</span><span class='line'>#include &lt;stdlib.h&gt;
</span><span class='line'>typedef struct NODE {
</span><span class='line'>    struct NODE *next;
</span><span class='line'>        int num;
</span><span class='line'>    }node;
</span><span class='line'>
</span><span class='line'>node *createLinkList(int length) {
</span><span class='line'>    if (length &lt;= 0) {
</span><span class='line'>            return NULL;
</span><span class='line'>            }
</span><span class='line'>        node *head,*p,*q;
</span><span class='line'>        int number = 1;
</span><span class='line'>        head = (node *)malloc(sizeof(node));
</span><span class='line'>        head-&gt;num = 1;
</span><span class='line'>        head-&gt;next = head;
</span><span class='line'>        p = q = head;
</span><span class='line'>        while (++number &lt;= length) {
</span><span class='line'>            p = (node *)malloc(sizeof(node));
</span><span class='line'>                p-&gt;num = number;
</span><span class='line'>                p-&gt;next = NULL;
</span><span class='line'>                q-&gt;next = p;
</span><span class='line'>                q = p;
</span><span class='line'>            }
</span><span class='line'>        return head;}
</span><span class='line'>
</span><span class='line'>void printLinkList(node *head) {
</span><span class='line'>    if (head == NULL) {
</span><span class='line'>            return;
</span><span class='line'>            }
</span><span class='line'>        node *p = head;
</span><span class='line'>        while (p) {
</span><span class='line'>            printf("%d ", p-&gt;num);
</span><span class='line'>                p = p -&gt; next;
</span><span class='line'>            }
</span><span class='line'>        printf("\n");
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>node *reverseFunc1(node *head) {
</span><span class='line'>    if (head == NULL) {
</span><span class='line'>            return head;
</span><span class='line'>        
</span><span class='line'>            }
</span><span class='line'>    
</span><span class='line'>        node *p,*q;
</span><span class='line'>        p = head;
</span><span class='line'>        q = NULL;
</span><span class='line'>        while (p) {
</span><span class='line'>            node *pNext = p -&gt; next;
</span><span class='line'>                p -&gt; next = q;
</span><span class='line'>                q = p;
</span><span class='line'>                p = pNext;
</span><span class='line'>            }
</span><span class='line'>        return q;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>int main(int argc, const char * argv[]) {
</span><span class='line'>    node *head = createLinkList(7);
</span><span class='line'>        if (head) {
</span><span class='line'>            printLinkList(head);
</span><span class='line'>                node *reHead = reverseFunc1(head);
</span><span class='line'>                printLinkList(reHead);
</span><span class='line'>                free(reHead);    
</span><span class='line'>    }
</span><span class='line'>        free(head);
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span></code></pre></td></tr></table></div></figure>


<p>7、    实现一个字符串“how are you”的逆序输出（编程语言不限）。如给定字符串为“hello world”,输出结果应当为“world hello”。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int spliterFunc(char *p) {
</span><span class='line'>    char c[100][100];
</span><span class='line'>        int i = 0;
</span><span class='line'>        int j = 0;
</span><span class='line'>    
</span><span class='line'>        while (*p != '\0') {
</span><span class='line'>            if (*p == ' ') {
</span><span class='line'>                    i++;
</span><span class='line'>                        j = 0;
</span><span class='line'>                    } else {
</span><span class='line'>                    c[i][j] = *p;
</span><span class='line'>                        j++;
</span><span class='line'>                    }
</span><span class='line'>                p++;    
</span><span class='line'>    
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>        for (int k = i; k &gt;= 0; k--) {
</span><span class='line'>            printf("%s", c[k]);
</span><span class='line'>                if (k &gt; 0) {
</span><span class='line'>                    printf(" ");
</span><span class='line'>                    } else {
</span><span class='line'>                    printf("\n");
</span><span class='line'>                      }
</span><span class='line'>            }    return 0;
</span><span class='line'>    
</span><span class='line'>    }
</span><span class='line'></span></code></pre></td></tr></table></div></figure>


<p>8、    给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？如“abaccddeeef”,字符是b,输出应该是2。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>char *strOutPut(char *);
</span><span class='line'>
</span><span class='line'>int compareDifferentChar(char, char *);
</span><span class='line'>
</span><span class='line'>int main(int argc, const char * argv[]) {    
</span><span class='line'>        char *inputStr = "abaccddeeef";
</span><span class='line'>        char *outputStr = strOutPut(inputStr);
</span><span class='line'>        printf("%c \n", *outputStr);
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>char *strOutPut(char *s) {
</span><span class='line'>    char str[100];
</span><span class='line'>        char *p = s;
</span><span class='line'>        int index = 0;
</span><span class='line'>        while (*s != '\0') {
</span><span class='line'>            if (compareDifferentChar(*s, p) == 1) {
</span><span class='line'>                    str[index] = *s;
</span><span class='line'>                        index++;
</span><span class='line'>                    }
</span><span class='line'>                s++;
</span><span class='line'>            }
</span><span class='line'>        return &str;}
</span><span class='line'>
</span><span class='line'>int compareDifferentChar(char c, char *s) {
</span><span class='line'>    int i = 0;
</span><span class='line'>        while (*s != '\0' && i&lt;= 1) {
</span><span class='line'>            if (*s == c) {
</span><span class='line'>                    i++;
</span><span class='line'>                    }
</span><span class='line'>                s++;    }
</span><span class='line'>        if (i == 1) {
</span><span class='line'>            return 1;
</span><span class='line'>            } else {
</span><span class='line'>            return 0;
</span><span class='line'>            }
</span><span class='line'>    }
</span></code></pre></td></tr></table></div></figure>


<p>9、    二叉树的先序遍历为FBACDEGH,中序遍历为：ABDCEFGH,请写出这个二叉树的后序遍历结果。
<strong>ADECBHGF</strong></p>

<ul>
<li>先序+中序遍历还原二叉树：先序遍历是：ABDEGCFH 中序遍历是：DBGEACHF</li>
</ul>


<p>首先从先序得到第一个为A，就是二叉树的根，回到中序，可以将其分为三部分：</p>

<p>左子树的中序序列DBGE，根A，右子树的中序序列CHF
接着将左子树的序列回到先序可以得到B为根，这样回到左子树的中序再次将左子树分割为三部分：
左子树的左子树D，左子树的根B，左子树的右子树GE
同样地，可以得到右子树的根为C
类似地将右子树分割为根C，右子树的右子树HF，注意其左子树为空
如果只有一个就是叶子不用再进行了，刚才的GE和HF再次这样运作，就可以将二叉树还原了。</p>

<p>10、   打印2-100之间的素数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main(int argc, const char * argv[]) {
</span><span class='line'>    for (int i = 2; i &lt; 100; i++) {
</span><span class='line'>            int r = isPrime(i);
</span><span class='line'>                if (r == 1) {
</span><span class='line'>                    printf("%ld ", i);
</span><span class='line'>                    }
</span><span class='line'>            }
</span><span class='line'>        return 0;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>int isPrime(int n){
</span><span class='line'>    int i, s;
</span><span class='line'>        for(i = 2; i &lt;= sqrt(n); i++)
</span><span class='line'>            if(n % i == 0)  return 0;
</span><span class='line'>            return 1;
</span><span class='line'>    }
</span></code></pre></td></tr></table></div></figure>


<p>11、   求两个整数的最大公约数。</p>

<pre><code>int gcd(int a, int b) {
    int temp = 0;
        if (a &lt; b) {
            temp = a;
                a = b;
                b = temp;
            }        while (b != 0) {
            temp = a % b;
                a = b;
                b = temp;
            }
        return a;
    }
</code></pre>

<p><strong>本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！</strong></p>

<p><strong>如需转载，请注明出处</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS面试题系列之UI相关]]></title>
    <link href="http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-uiji-chu/"/>
    <updated>2016-04-24T23:58:39+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-uiji-chu</id>
    <content type="html"><![CDATA[<p>1、    简述app启动周期。
打开应用程序，它先会执行main函数，再执行UIApplicationMain函数。初始化
UIApplication，设置代理对象，开启事件循环，调用代理方法进行事件处理。首先会调
用application:didFinishLaunchingWithOptions:代理方法。接下来会调用
applicationDidBecomeActive:代理方法。监听系统事件，结束程序。当程序正常退
出UIApplicationMain函数才会返回。
监听系统事件：锁屏后app会调用：applicationWillResignActive:代理方法。然后接着调用
applicationDidEnterBackground:方法。解锁后app会调用：applicationWillEnterForeground:代理方法。接着调用
applicationDidBecomeActive代理方法。杀死进程会调用：applicationWillTerminate:代理方法。接听电话：先调用applicationWillResignActive:代理方法。挂断电话后会直接进入
应用调：applicationDidBecomeActive:代理方法。出现内存警告会调用：applicationDidReceiveMemoryWarning:代理方法</p>

<p>2、    简单的说说UIApplication的作用及继承关系。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（1）UIApplication是继承UIResponder的。UIApplication是整个应用程序的核
</span><span class='line'>
</span><span class='line'>心。每一个程序在运行期必须有UIApplication(或子类)的一个实例（有且只有一
</span><span class='line'>
</span><span class='line'>个），通过[UIApplication shareApplication]可以得到这个单例实例。
</span><span class='line'>
</span><span class='line'>（2）UIApplication帮助管理应用程序的生命周期，通过delegate来履行任务。
</span><span class='line'>
</span><span class='line'>（3）UIApplication可以接收事件，把所有用户事件都放入队列，逐个处理。它会发送
</span><span class='line'>
</span><span class='line'>当前事件给一个合适的目标控件进行处理。他还将部分事件转给delegate对象来处理。
</span><span class='line'>
</span><span class='line'>delegate可以处理的事件包括：应用程序的生命周期事件（如程序启动与关闭）、系统事
</span><span class='line'>
</span><span class='line'>件（如来电）。
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>3、    简述推送消息原理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（1）应用程序注册接收远程通知的时候，系统会发送请求到APNS服务器。APNS服务器收
</span><span class='line'>到请求后会根据请求所带的key值生成一个独一无二的deviceToken。然后APNS服务器会把deviceToken包装成NSData对象发送到对应请求的App上。接下来APP把deviceToken发送给我们自己的服务器（Provider）。服务器接收到deviceToken后进行存储等相关处理。服务器会把推送给用户的消息发送至APNS服务器，最后APNS服务器再发送通知给app。（2）有关于deviceToken变化问题：重新安装或卸载应用程序，deviceToken不会发生变化。系统升级deviceToken可能会发生变化。抹掉所有内容和设置，重置设备后，deviceToken会变化（3）注册远程通知方法注册远程通知：一般在app启动完成的时候注册远程通知，注册方法一般在didFinishLaunchingWithOptions：代理方法中处理注册远程通知回调方法：注册成功会回调didRegisterForRometoNotificationsWithDeviceToken:其中的deviceToken参数就是APNS服务器返回的token。注册失败会回调didFailToRegisterForRemoteNotificationsWithError:（4）处理接收到的远程通知消息程序启动时，app从Terminate状态进入Foreground状态时，会根据didFinishLaunchingWithOptions:代理方法中的luanchOptions参数来获取userInfo。判断是否有推送消息。方式如下：   // userInfo为收到远程通知的内容NSDictionary*userInfo=launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey];if (userInfo) {   // 有推送的消息，处理推送的消息  }如果app处于Background状态时，只有用户点击了通知消息才会调用didReceiveRemoteNotification:，如果当前app处于Foreground状态，会直接调用该方法。
</span></code></pre></td></tr></table></div></figure>


<p>4、    简单说下UITableView、UIButton、UIWindow控件的继承关系。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（1）UITableView的继承关系：UITableView继承UIScrollView。UIScrollView继承UIView。UIView继承UIResponder。UIResponder继承NSObject。（2）UIButton的继承关系：UIButton继承UIControl，UIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。（3）UIWindow继承UIView。
</span></code></pre></td></tr></table></div></figure>


<p>5、    UIView与UIButton有什么区别？UISwitch呢？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIView继承自UIResponder，它能响应某个动作。UIButton继承UIControl。它不仅可以响应某个动作，还能为某个对象添加对应的动作加以响应。UIButton也能实现UISwitch的功能，它们的区别是分发的事件不一样。
</span></code></pre></td></tr></table></div></figure>


<p>6、    简述UIControl的继承关系，它用来做什么？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。它能为某个特定对象添加事件。能进行事件分发。
</span></code></pre></td></tr></table></div></figure>


<p>7、    简述UIViewController中view的生命周期。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>先调用loadView方法，再调用viewDidLoad方法，调用viewWillAppear方法，调用viewWillLayoutSubviews方法，调用viewDidLayoutSubviews方法，再调用viewDidApper方法。控制器消失的时候先调用viewWillDisappear方法，再调用viewDidDisapper方法。最后调用dealloc方法。当出现内存警告的时候会调用didReceiveMemoryWarning方法。
</span></code></pre></td></tr></table></div></figure>


<p>8、    简述UITableView的代理方法调用顺序。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>先调用numberOfSectionsInTableView:方法，numberOfRowsInSection:heightForRowAtIndexPath:cellForRowAtIndexPath:
</span></code></pre></td></tr></table></div></figure>


<p>9、    你在用CollectionView的时候有没有遇到什么问题？问题是怎么解决的？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>刷新的时候会闪烁。在刷新的时候会默认附加一个隐式的fade动画。可以通过取消动画来达到取消闪烁的目的。
</span></code></pre></td></tr></table></div></figure>


<p>10、   简述UIResponder类的作用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIResponder类主要是为那些需要响应并处理事件的对象定义了一组接口。这些事件包括：触摸事件、运动事件、远程控制事件（如耳机控制音视频播放）。当用户触发某一事件时，UIKit会创建一个UIEvent事件对象，事件对象会加入到一个FIFO先进先出的队列中。UIApplication对象处理事件时，会从队列头部取出一个事件对象进行分发。
</span></code></pre></td></tr></table></div></figure>


<p>11、   如何监听View的触摸事件？事件如何传递？简述视图的响应者链。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>可以通过View类的touchesBegan、touchesMoved、touchesEnded、touchesCancelled方法监听视图的触摸。当触摸一个视图对象时，系统会捕捉此事件，并给这个事件创建一个UIEvent对象，将此对象加入当前应用程序的事件队列中，然后由UIApplication对象从队列中取出来进行事件分发，首先会分发给UIWindow对象，然后由UIWindow对象分发给触摸的视图对象，即第一响应者对象。响应者链：当事件交给第一响应者处理，如果第一响应者不处理，事件就会沿着响应者链向上传递，交给下一个响应者。一般来说，第一响应者是一个视图对象或者是其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象，然后是它的父视图对象，以此类推，直到顶层视图。接下来会沿着顶层视图到UIWindow对象，再到UIApplication对象。如果整个过程都没有响应这个事件，该事件就会被丢弃，一般情况下，在响应者链中只要有对象处理事件，事件就会停止传递。有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。
</span></code></pre></td></tr></table></div></figure>


<p>12、   CALayer与UIView有什么区别？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（1）UIView是iOS系统中界面元素的继承。所有的界面元素都继承自它，他本身完全是由CoreAnimation来实现的。它真正的绘图部分，是由一个叫CALayer的类来管理。UIView本身更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，如frame,bounds等，实际上内部都是在访问它所包含的CALayer的相关属性。（2）UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示。（3）UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer。（4）CALayer坐标系统与UIView有点不一样，它多了一个anchorPoint的属性。（5）UIView的layer树形在系统内部，被系统维护着三份copy。逻辑树，动画树，显示树。（6）CALayer默认修改属性支持隐式动画（7）View可以接受并处理事件，Layer不可以。
</span></code></pre></td></tr></table></div></figure>


<p>13、   如何优化UITableView?</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（1）复用单元格（2）使用不透明的视图，单元格中少使用动画。（3）图片使用异步加载，设置图片加载的并发数。（4）滑动时不加载图片，停止滑动时再加载。（5）图片和文字可以直接drawRect（6）如果cell是动态行高，计算缓存单元格高度（7）尽量少reloadData，只reloadRowsAtIndexPaths（8）cell高度固定直接用rowHeight属性设置高度。
</span><span class='line'></span></code></pre></td></tr></table></div></figure>


<p>14、   简述加载到控制器上的根视图创建与加载时机。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>视图控制器的根视图加载是在UIViewController的loadView方法中。当视图控制中的loadView方法被调用时，会先通过NSBundle加载，通过控制器的类名作为xib文件名加载xib文件，如果存在，加载View为根视图，如果不存在，则自动创建一个View作为根视图。
</span><span class='line'></span></code></pre></td></tr></table></div></figure>


<p>15、   简述UITableView中cell的复用机制。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UITableView会创建屏幕显示单元格个数（N）+1个单元格，当滑动到第N+2个单元格时就会复用第1个单元格。UITableView中还有单元格复用池的概念。当tableView调用初始化单元格协议方法获取单元格时，它会根据你设定的reuse identifier先去复用池中查找可用的复用单元格，找到则复用该单元格，没找到这创建一个新的单元格对象。
</span></code></pre></td></tr></table></div></figure>


<p><strong>本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！</strong></p>

<p><strong>如需转载，请注明出处</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS面试题系列之Objective-C基础]]></title>
    <link href="http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-zhi-objective-cji-chu/"/>
    <updated>2016-04-24T23:58:04+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-zhi-objective-cji-chu</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native iOS 开发环境搭建]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/21/react-native-ios-kai-fa-huan-jing-da-jian/"/>
    <updated>2016-01-21T01:07:09+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/21/react-native-ios-kai-fa-huan-jing-da-jian</id>
    <content type="html"><![CDATA[<h4>一、React Native基础环境搭建</h4>

<p>1、安装<a href="http://brew.sh">Homebrew</a></p>

<p>打开终端输入：
<code>
ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
</code></p>

<p>2、安装<a href="https://github.com/creationix/nvm#installation">nvm</a>方法</p>

<p>通过脚本安装方式，在终端执行：
<code>
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.1/install.sh | bash
</code></p>

<p>激活nvm,在安装脚本执行完之后，在终端执行:
<code>
. ~/.nvm/nvm.sh
</code></p>

<p>nvm其他安装方式详见<a href="https://github.com/creationix/nvm#installation">安装向导</a></p>

<p>3、默认安装最新版本的Node.js并且设置好命令行的环境变量
<code>
nvm install node &amp;&amp; nvm alias default node
</code></p>

<p>可以输入node命令启动Node.js环境，npm(node package manager)文档传送门:<a href="https://docs.npmjs.com">&ldquo;点击此处&rdquo;</a></p>

<p>4、安装watchman</p>

<p>在终端输入：
<code>
brew install watchman
</code></p>

<p>到此处React Native基础环境搭建基本完成，推荐经常运行<code>brew update &amp;&amp; brew upgrade</code>命令保持你的程序是最新的。</p>

<h4>二、iOS开发环境</h4>

<!--more-->


<p>1、iOS开发环境：（默认读者已经安装<strong>Xcode7.0或以上版本</strong>，没有可自行前往AppStore下载）</p>

<ul>
<li>使用npm（node包管理工具）安装react-native-cli(此处应注意权限问题，如果遇到权限问题，请在下面的命令前加上sudo)</li>
</ul>


<p><code>
npm install -g react-native-cli
</code></p>

<ul>
<li>初始化工程（下面的语句中千万不要加sudo，后果自负）</li>
</ul>


<p><code>
react-native init ReactNativeProject（工程名）
</code></p>

<p>在初始化的过程中，如果进度缓慢，推荐你将npm仓库源换成国内镜像：(翻墙用户请忽略)
在终端输入：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>npm config set registry https://registry.npm.taobao.org
</span><span class='line'>npm config set disturl https://npm.taobao.org/dist</span></code></pre></td></tr></table></div></figure>


<p>2、使用Xcode运行调试程序</p>

<ul>
<li>查找ReactNativeProject文件目录</li>
</ul>


<p>按住快捷键<code>Command+Shift+G</code>，在弹出的“前往文件夹”对话框中输入路径<code>/Users/yangshebing/ReactNativeProject</code>（yangshebing表示电脑用户名，请自行更改）,点击前往。在文件目中的ios文件夹下找到“ReactNativeProject.xcodeproj”工程文件。如图所示：（有关终端查找该文件目录方法，请自行到文章末尾的参考文章中寻找）
<img src="http://ww4.sinaimg.cn/large/7f266405jw1f0651k88wij216s0oa42t.jpg" alt="" /></p>

<ul>
<li>运行ReactNativeProject工程</li>
</ul>


<p>使用Xcode打开“ReactNativeProject.xcodeproj”工程文件，按住快捷键"Command+R"运行此项目，运行成功后便可在模拟器上看到效果。</p>

<ul>
<li>编辑index.ios.js文件修改界面</li>
</ul>


<p>笔者编辑index.ios.js文件工具是Vim，每当编辑完index.ios.js文件并保存之后，在模拟器(Simulator)中，按<code>Command+R</code>可刷新界面查看改变后的效果。</p>

<p>下面我们也试着稍微修改一下index.ios.js文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * Sample React Native App
</span><span class='line'> * https://github.com/facebook/react-native
</span><span class='line'> */
</span><span class='line'>'use strict';
</span><span class='line'>import React, {
</span><span class='line'>  AppRegistry,
</span><span class='line'>  Component,
</span><span class='line'>  StyleSheet,
</span><span class='line'>  //添加Image全局变量
</span><span class='line'>  Image,
</span><span class='line'>  Text,
</span><span class='line'>  View
</span><span class='line'>} from 'react-native';
</span><span class='line'>
</span><span class='line'>class ReactNativeProject extends Component {
</span><span class='line'>  render() {
</span><span class='line'>    return (
</span><span class='line'>      &lt;View style={styles.container}&gt;
</span><span class='line'>      //添加文本展示
</span><span class='line'>        &lt;Text style={styles.welcome}&gt;
</span><span class='line'>          美女
</span><span class='line'>        &lt;/Text&gt;
</span><span class='line'>        //添加图片展示
</span><span class='line'>        &lt;Image 
</span><span class='line'>        source= 
</span><span class='line'>        //这里需要指定图片的大小
</span><span class='line'>        style={styles.picture} /&gt;
</span><span class='line'>      &lt;/View&gt;
</span><span class='line'>    );
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>const styles = StyleSheet.create({
</span><span class='line'>  container: {
</span><span class='line'>    flex: 1,
</span><span class='line'>    justifyContent: 'center',
</span><span class='line'>    alignItems: 'center',
</span><span class='line'>    backgroundColor: '#F5FCFF',
</span><span class='line'>  },
</span><span class='line'>  //这里可以设置文本的字体，对齐方式等
</span><span class='line'>  welcome: {
</span><span class='line'>    fontSize: 20,
</span><span class='line'>    textAlign: 'center',
</span><span class='line'>    margin: 10,
</span><span class='line'>  },
</span><span class='line'>  //新增图片style，设置图片大小
</span><span class='line'>  picture: {
</span><span class='line'>    width: 80,
</span><span class='line'>    height: 150,
</span><span class='line'>  },
</span><span class='line'>});
</span><span class='line'>
</span><span class='line'>AppRegistry.registerComponent('ReactNativeProject', () =&gt; ReactNativeProject);</span></code></pre></td></tr></table></div></figure>


<p>刷新后运行效果如下图所示：
<img src="http://ww3.sinaimg.cn/mw690/7f266405jw1f06flkcxxgj20ku12a3zr.jpg" alt="" /></p>

<ul>
<li>真机运行调试项目</li>
</ul>


<p>在<code>ReactNativeProject</code>工程中找到AppDelegate.m文件，将<code>localhost</code>替换成自己电脑的IP地址。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//  jsCodeLocation = [NSURL URLWithString:@"http://localhost:8081/index.ios.bundle?platform=ios&dev=true"];
</span><span class='line'>
</span><span class='line'>  jsCodeLocation = [NSURL URLWithString:@"http://192.168.31.168:8081/index.ios.bundle?platform=ios&dev=true"];</span></code></pre></td></tr></table></div></figure>


<p>替换完成之后再次运行程序，这个时候可以通过摇晃设备唤出开发菜单。</p>

<ul>
<li>禁用开发菜单</li>
</ul>


<p>在打包提交市场前，需要禁用开发菜单。禁用开发菜单方法如下：
打开工程，选择<code>Product → Scheme → Edit Scheme</code>或使用快捷键“Command + &lt;”,在弹出的窗口中选择左边的Run菜单项。更改“Build Configuration” 设置项为“Release”。
<img src="http://ww1.sinaimg.cn/large/7f266405jw1f06e3sf5qjj21ds0s0tc2.jpg" alt="" /></p>

<h4>三、参考资料地址：</h4>

<ul>
<li><a href="https://facebook.github.io/react-native/docs/tutorial.html">React Native开发指南英文版（官方）</a></li>
<li><a href="http://reactnative.cn/docs/getting-started.html#content">React Native开发指南中文版</a></li>
<li><a href="http://www.cnblogs.com/meteoric_cry/p/4862314.html">React Native入门遇到的一些问题</a></li>
</ul>


<p><strong>此文仅供学习交流，转载请注明出处！</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift内存管理（ARC）之循环引用]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/15/swiftnei-cun-guan-li-(arc)zhi-xun-huan-yin-yong/"/>
    <updated>2016-01-15T01:37:31+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/15/swiftnei-cun-guan-li-(arc)zhi-xun-huan-yin-yong</id>
    <content type="html"><![CDATA[<p>Swift中是采用自动引用计数(ARC，AutomaticReferenceCounting)机制来对内存进行管理的。</p>

<h4>一、简述ARC如何工作：</h4>

<p>每当你每创建一个新的对象，它便会分配一块内存来存储该对象的相关信息。当你不再需要这个对象的时候，它就会自动释放这个对象，避免它再占用内存空间。当然，如果该对象只要至少存在一个引用就不会被释放。另外，你如果访问了一个已经被释放的对象，则很有可能会出现崩溃（野指针）。
拿《The Swift Programming Language》里面的例子来套一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//创建一个Cat类，自带常量name属性
</span><span class='line'>class Cat {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) {
</span><span class='line'>    //初始化name属性
</span><span class='line'>        self.name = name;
</span><span class='line'>        print("\(name) 对象已经被初始化")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(name) 对象释放成功！")
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>接下来定义三个变量类型为:Cat?用来对一个新的Cat对象建立多个引用。因为变量是一个可选类型（是Cat?而不是Cat）， 他们会自动给变量初始化为nil，所有当前它不需要引用一个Cat对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var cat1: Cat?
</span><span class='line'>var cat2: Cat?
</span><span class='line'>var cat3: Cat?</span></code></pre></td></tr></table></div></figure>


<p>创建一个新的Cat对象，并对之前定义的三个变量进行赋值操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat1 = Cat(name: "jack")
</span><span class='line'>//输出：jack 对象已经被初始化
</span></code></pre></td></tr></table></div></figure>


<p>当你调用Cat类构造器，它会输出："jack 对象已经被初始化"。这就代表已经完成了对象初始化操作。接下来，一个新的Cat对象被赋值给了 cat1变量，从而建立了cat1对新Cat实例对象的强引用。因此，它存在了至少一个强引用。这个新的Cat对象就不会被释放。
如果你把同一个Cat实例对象赋值给另外两个变量，它则又多建立了两个强引用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//通过赋值对Cat实例对象建立强引用
</span><span class='line'>cat2 = cat1
</span><span class='line'>cat3 = cat1</span></code></pre></td></tr></table></div></figure>


<p>此时这个Cat实例对象已经有三个强引用了。
如果你用把其中两个变量赋值为nil的方式来打破这些强引用，对象是不会被释放的。因为它还存在一个强引用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//通过把置nil来打破cat1,cat2对Cat实例对象的强引用
</span><span class='line'>cat1 = nil
</span><span class='line'>cat2 = nil</span></code></pre></td></tr></table></div></figure>


<p>只有直到对象所有的引用被打破，ARC才会释放该对象</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//打破最后一个强引用
</span><span class='line'>cat3 = nil
</span><span class='line'>//输出：jack 对象释放成功！</span></code></pre></td></tr></table></div></figure>


<p>当最后一个强引用被打破后，这个Cat对象被成功释放，输出：jack 对象释放成功！</p>

<h4>二、循环引用</h4>

<p>1、什么是循环引用？
简单的来说就是两个对象互相持有对方，使对方处于活跃状态不被释放，从而导致了循环引用。套个例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//创建一个Cat类，拥有一个String类型的name属性与一个可选类型的dog属性。
</span><span class='line'>class Cat {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name;
</span><span class='line'>        print("\(name) 对象已经被初始化")
</span><span class='line'>    }
</span><span class='line'>    var dog: Dog?
</span><span class='line'>    
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(name) 对象释放成功！")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//创建一个Dog类，拥有一个String类型的type属性与一个可选类型的jack属性。
</span><span class='line'>class Dog {
</span><span class='line'>    let type: String
</span><span class='line'>    init(type: String) {
</span><span class='line'>        self.type = type
</span><span class='line'>        print("\(type) 对象已经被初始化")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    var cat: Cat?
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(type) 对象释放成功")
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>定义两个变量并初始化</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var jack: Cat?
</span><span class='line'>var tom: Dog?
</span><span class='line'>
</span><span class='line'>jack = Cat(name: "jack")
</span><span class='line'>//print:jack 对象已经被初始化
</span><span class='line'>tom = Dog(type: "red")
</span><span class='line'>//print:red 对象已经被初始化</span></code></pre></td></tr></table></div></figure>


<p>建立强引用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>jack!.dog = tom
</span><span class='line'>tom!.cat = jack</span></code></pre></td></tr></table></div></figure>


<p>通过把对象置nil打破强引用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>jack = nil
</span><span class='line'>tom = nil</span></code></pre></td></tr></table></div></figure>


<p>这个地方Cat对象和Dog对象都不会被释放，因为他们两个之间还存在强引用。</p>

<ul>
<li><p>解决循环引用办法
  Swift提供了两种方法来解决循环引用问题：</p>

<p>  （1）弱引用（weak）</p>

<p>  （2）无主引用（unowned）</p></li>
</ul>


<p>声明变量或属性时，在前面加上"weak"关键词表示它是一个弱引用。如果确定访问属性或函数的时候该对象不会被释放，也可以用无主引用（unowned）来取代。unowned跟Objective-C中的unsafe_unretained类似。它与weak的区别在于weak在引用的对象被释放后，会自动置nil。所以它必须声明成可选类型（？）。而unowned在引用对象被释放后不会自动置nil(因为非可选类型的变量不能被设置成nil)，而是保留对原有对象的无效引用，一旦对象被释放，再访问该对象的属性或函数就会造成崩溃。官方建议是当你在可以确定访问属性或函数所属对象不会被释放时，使用unowned。否则，还是使用weak吧！</p>

<p>解决上面代码的循环引用问题，可做如下修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Dog {
</span><span class='line'>    let type: String
</span><span class='line'>    init(type: String) {
</span><span class='line'>        self.type = type
</span><span class='line'>        print("\(type) 对象已经被初始化")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    weak var jack: Cat
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(type) 对象释放成功")
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>jack = nil
</span><span class='line'>tom = nil</span></code></pre></td></tr></table></div></figure>


<p>2、常见的循环引用问题：</p>

<p>（1）delegate
在项目中我们经常会用到代理模式，在Objective-C中我们一般在delegate前面加上weak关键词，表示它是一个弱引用。从而达到打破循环引用的效果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//在前面加上@objc是指定这里的代码属于Objective-C的代码，因为Swift中协议可以用于class、struct、enum。对于基本数据类型，它不是对象，没有引用计数这个概念，因此无法使用weak关键词。  Objective-C中的协议只适用于类，所以这里需要加上@objc。
</span><span class='line'>@objc protocol AClassDelegate {
</span><span class='line'>    func wash()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class A {
</span><span class='line'>    weak var delegate: AClassDelegate!
</span><span class='line'>    func cry() {
</span><span class='line'>        
</span><span class='line'>    }
</span><span class='line'>    func play() {
</span><span class='line'>        delegate.wash()
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class B: AClassDelegate {
</span><span class='line'>    
</span><span class='line'>    func feed() {
</span><span class='line'>        let nurse = A()
</span><span class='line'>        nurse.delegate = self
</span><span class='line'>        nurse.cry()
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    @objc func wash() {
</span><span class='line'>        print("begin wash and sleep")
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>（2）Block(闭包)中的循环引用
Block(闭包)的循环引用在于它会持有所有引用的元素。比如我们在Block(闭包)中访问了self，那么它就持有了self。这样一来就形成了一个环：self持有Block(闭包)，Block(闭包)持有self。下面我们举个栗子加以说明：类A中有个闭包，我们在闭包中访问了self的name属性。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class A {
</span><span class='line'>    let name: String
</span><span class='line'>    lazy var wash: Void -&gt;Void = {
</span><span class='line'>        var name = self.name + " nurse"
</span><span class='line'>        print("wash room is \(name)")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>        print("\(self.name) 创建了")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(self.name) 释放了")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class B {
</span><span class='line'>    func play() {
</span><span class='line'>        var nurse: A?
</span><span class='line'>        nurse = A(name: "jack")
</span><span class='line'>        nurse?.wash()
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var baby: B?
</span><span class='line'>baby = B()
</span><span class='line'>baby?.play()
</span><span class='line'>
</span><span class='line'>输出结果：
</span><span class='line'>jack 创建了
</span><span class='line'>wash room is jack nurse</span></code></pre></td></tr></table></div></figure>


<p> 因为wash是self的一个属性，所以wash被self持有。这个时候我们又在闭包中访问了self的name属性，所以它又在闭包中持有了self。这样便导致了循环引用。为了解决闭包中的循环引用问题，Swift中提供了一个叫”闭包捕获列表”的解决方案。</p>

<ul>
<li>定义一个捕获列表</li>
</ul>


<p> 捕获列表中的每一项都是一个用weak或 unowned关键字与一个实例对象的引用（如self）或者是一个用初始化值的变量（如delegate = self.delegate!）搭配成对，配对之间用逗号隔开，最后用方括号括起来。如下所示：</p>

<pre><code class="`">
  lazy var someClosure:(Int, String) -&gt; String = {
        [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in

    }
</code></pre>

<p> 如果闭包中没有指定参数列表或者返回类型，可直接把捕获列表放置在闭包开始的地方（花括号后面）然后紧跟着是"in"关键词，示例代码如下：</p>

<pre><code class="``">  lazy var someClosure:Void -&gt; String = {
        [unowned self, weak delegate = self.delegate!]  in

    }
</code></pre>

<ul>
<li>解决Block(闭包)中的循环引用，ClassA中的Block(闭包)代码可做以下修改：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lazy var wash:Void -&gt;Void = { [weak self] in
</span><span class='line'>//这个地方使用self!.name而不是self.name。是因为weak修饰，self有可能为nil，如果是unowned修饰，这个地方应该是self.name。因为unowned修饰的self永远不可能为空。
</span><span class='line'>        var name = self!.name + " nurse"
</span><span class='line'>        print("wash room is \(name)")
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'> 输出结果：
</span><span class='line'>jack 创建了
</span><span class='line'>wash room is jack nurse
</span><span class='line'>jack 释放了</span></code></pre></td></tr></table></div></figure>


<h4>参考资料及文章</h4>

<ul>
<li><a herf="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/">《The Swift Programming Language》</a></li>
<li><a href="http://swifter.tips/retain-cycle/">内存管理，WEAK 和 UNOWNED </a></li>
<li><a href="http://skyfly.xyz/2015/12/18/Swift/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Swift学习笔记-内存管理</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中UITableView的用法(自定义UITableView和UITableViewCell)]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/04/swiftzhong-uitableviewde-yong-fa-zi-ding-yi-uitableviewhe-uitableviewcell/"/>
    <updated>2016-01-04T21:23:33+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/04/swiftzhong-uitableviewde-yong-fa-zi-ding-yi-uitableviewhe-uitableviewcell</id>
    <content type="html"><![CDATA[<p>一、自定义表视图（UITableView）</p>

<!--more-->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>import UIKit
</span><span class='line'>class HomeTableView: UITableView, UITableViewDataSource, UITableViewDelegate {
</span><span class='line'>//表视图的数据源：dataList
</span><span class='line'>    var dataList = [AnyObject]()
</span><span class='line'>//单元格的标识符：homeCellId
</span><span class='line'>    let identify = "homeCellId"
</span><span class='line'>    //重写表视图初始化方法
</span><span class='line'>    override init(frame: CGRect, style: UITableViewStyle) {
</span><span class='line'>        super.init(frame:frame, style:style)
</span><span class='line'>        //调用初始化子视图方法
</span><span class='line'>        initSubviews()
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    required init?(coder aDecoder: NSCoder) {
</span><span class='line'>        fatalError("init(coder:) has not been implemented")
</span><span class='line'>    }
</span><span class='line'>    //初始化表视图的子视图方法
</span><span class='line'>    func initSubviews () {
</span><span class='line'>    //设置数据源代理
</span><span class='line'>        dataSource = self;
</span><span class='line'>   //设置表视图代理
</span><span class='line'>        delegate = self;
</span><span class='line'>        //注册单元格class方式
</span><span class='line'>        registerClass(HomeCell.self, forCellReuseIdentifier: identify)
</span><span class='line'>       //设置表视图的分割线显示风格
</span><span class='line'>        separatorStyle = .None;
</span><span class='line'>        //注册单元格xib方式
</span><span class='line'>        //registerNib(UINib(nibName: "HomeCell", bundle: nil), forCellReuseIdentifier:identify)
</span><span class='line'>    }
</span><span class='line'>   //实现表视图返回组数代理方法：不实现默认为1
</span><span class='line'>    func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int {
</span><span class='line'>        return 1;
</span><span class='line'>    }
</span><span class='line'>//实现表视图返回行数代理方法
</span><span class='line'>    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
</span><span class='line'>        return dataList.count;
</span><span class='line'>    }
</span><span class='line'>    //实现表视图返回单元格代理方法
</span><span class='line'>    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
</span><span class='line'>    //取单元格
</span><span class='line'>        let cell = tableView.dequeueReusableCellWithIdentifier(identify) as! HomeCell
</span><span class='line'>        //设置单元格的选中风格
</span><span class='line'>        cell.selectionStyle = .None;
</span><span class='line'>        cell.titleStr = dataList[indexPath.row] as? String
</span><span class='line'>        return cell
</span><span class='line'>    }
</span><span class='line'>    //选中单元格的代理方法
</span><span class='line'>    func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
</span><span class='line'>        print("the indexpath row is \(indexPath.row)")
</span><span class='line'>    }
</span><span class='line'>    //返回单元格高度的代理方法
</span><span class='line'>    func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat {
</span><span class='line'>        return 80;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>二、自定义单元格（UITableViewCell）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import UIKit
</span><span class='line'>
</span><span class='line'>class HomeCell: UITableViewCell {
</span><span class='line'>//定义子视图变量
</span><span class='line'>    var imgView: UIImageView!
</span><span class='line'>    var titleLabel: UILabel!
</span><span class='line'>    var button: UIButton!
</span><span class='line'>    var titleStr: String?
</span><span class='line'>    // 重写单元格初始化方法
</span><span class='line'>    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {
</span><span class='line'>        super.init(style: style, reuseIdentifier: reuseIdentifier);
</span><span class='line'>        //调用单元格初始化方法
</span><span class='line'>        initSubviews()
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    required init?(coder aDecoder: NSCoder) {
</span><span class='line'>        fatalError("init(coder:)has not been implemented")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    override func awakeFromNib() {
</span><span class='line'>        super.awakeFromNib()
</span><span class='line'>        // Initialization code
</span><span class='line'>    }
</span><span class='line'>    //单元格子视图初始化方法
</span><span class='line'>    func initSubviews () {
</span><span class='line'>        imgView = UIImageView(frame: CGRectMake(0, 0, 30, 30))
</span><span class='line'>        imgView.image = UIImage(named: "exam.png")
</span><span class='line'>        contentView.addSubview(imgView);
</span><span class='line'>        
</span><span class='line'>        titleLabel = UILabel(frame: CGRectMake(0, 0, frame.size.width, frame.size.height))
</span><span class='line'>        titleLabel.textAlignment = .Left;
</span><span class='line'>        titleLabel.textColor = UIColor.lightGrayColor();
</span><span class='line'>        titleLabel.font = UIFont.systemFontOfSize(15);
</span><span class='line'>        titleLabel.text = "心灵鸡汤，每天一起干"
</span><span class='line'>        contentView.addSubview(titleLabel)
</span><span class='line'>        
</span><span class='line'>        button = UIButton(type: .Custom)
</span><span class='line'>        button.frame = CGRectMake(0, 0, frame.size.width, frame.size.height)
</span><span class='line'>        button.setTitle("关注", forState: .Normal)
</span><span class='line'>        button.setTitleColor(UIColor.whiteColor(), forState: .Normal)
</span><span class='line'>        button.backgroundColor = UIColor.grayColor()
</span><span class='line'>        contentView.addSubview(button)
</span><span class='line'>    }
</span><span class='line'>    //重写单元格布局子视图方法
</span><span class='line'>    override func layoutSubviews() {
</span><span class='line'>        super.layoutSubviews()
</span><span class='line'>        titleLabel.text = titleStr
</span><span class='line'>      //...
</span><span class='line'>      //布局单元格子视图
</span><span class='line'>      //...
</span><span class='line'>    override func setSelected(selected: Bool, animated: Bool) {
</span><span class='line'>        super.setSelected(selected, animated: animated)
</span><span class='line'>        // Configure the view for the selected state
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发之基础控件（Swift版）]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/02/ioskai-fa-zhi-ji-chu-kong-jian-(swiftban-)/"/>
    <updated>2016-01-02T11:08:19+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/02/ioskai-fa-zhi-ji-chu-kong-jian-(swiftban-)</id>
    <content type="html"><![CDATA[<p>  1、文本（UILabel）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  let titleLabel = UILabel(frame: CGRectMake(0, 0, view.frame.size.width, view.frame.size.height))
</span><span class='line'>        //设置titleLabel的文本对齐方式：左：.Left, 中:.Center, 右:.Right
</span><span class='line'>        titleLabel.textAlignment = .Center
</span><span class='line'>        //设置titleLabel的文本颜色
</span><span class='line'>        titleLabel.textColor = UIColor.lightGrayColor()
</span><span class='line'>        //设置titleLabel文字的字体为系统字体，大小为15
</span><span class='line'>        titleLabel.font = UIFont.systemFontOfSize(15)
</span><span class='line'>        //设置titleLabel文字的字体为"Helvetica", 大小为15
</span><span class='line'>        titleLabel.font = UIFont(name: "Helvetica", size: 15)
</span><span class='line'>        titleLabel.text = "心灵鸡汤，每天一起干"
</span><span class='line'>        //titleLabel字体大小自适应宽度，根据指定宽度titleLabel自动调整字体显示大小
</span><span class='line'>        titleLabel.adjustsFontSizeToFitWidth = true
</span><span class='line'>        //指定titleLabel的显示行数，0代表自动折行
</span><span class='line'>        titleLabel.numberOfLines = 1
</span><span class='line'>        //获取系统所有字体名称
</span><span class='line'>        let fontFamily = UIFont.familyNames()
</span><span class='line'>        print(fontFamily)
</span><span class='line'>        view.addSubview(titleLabel)</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>2、按钮（UIButton）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//按钮类型：常见的两种如下
</span><span class='line'>         /**
</span><span class='line'>         *.Custom:自定义类型
</span><span class='line'>         *.System:系统类型（iOS7.0）
</span><span class='line'>         **/
</span><span class='line'>        let followButton = UIButton(type: .Custom)
</span><span class='line'>        followButton.frame = CGRectMake(100, 100, 100, 50)
</span><span class='line'>        //设置按钮在特定状态下的文本显示，常见的有：
</span><span class='line'>        /**
</span><span class='line'>         *.Normal:按钮常规显示状态
</span><span class='line'>         *.Selected:按钮选中显示状态
</span><span class='line'>         *.Highlighted:按钮高亮显示状态
</span><span class='line'>         *.Disabled:按钮关闭状态显示
</span><span class='line'>        **/
</span><span class='line'>        followButton.setTitle("关注", forState: .Normal)
</span><span class='line'>        //设置按钮在特定状态下的文本色值显示
</span><span class='line'>        followButton.setTitleColor(UIColor.whiteColor(), forState: .Normal)
</span><span class='line'>        //设置按钮在特定状态下的图片显示
</span><span class='line'>        followButton.setImage(UIImage(named: "back"), forState: .Normal)
</span><span class='line'>        followButton.setImage(UIImage(named: "select"), forState: .Disabled)
</span><span class='line'>        //设置按钮显示文本的字体大小
</span><span class='line'>        followButton.titleLabel?.font = UIFont.systemFontOfSize(15)
</span><span class='line'>        //设置按钮选中状态
</span><span class='line'>        followButton.selected = true
</span><span class='line'>        //设置按钮是否打开状态
</span><span class='line'>        followButton.enabled = true
</span><span class='line'>        //设置是否响应用户touch事件
</span><span class='line'>        followButton.userInteractionEnabled = true
</span><span class='line'>        //设置按钮的背景颜色
</span><span class='line'>        followButton.backgroundColor = UIColor.grayColor()
</span><span class='line'>        //关闭按钮处于高亮状态图片变暗显示状态
</span><span class='line'>        followButton.adjustsImageWhenHighlighted = false
</span><span class='line'>        //设置按钮图片的内部填充
</span><span class='line'>        followButton.imageEdgeInsets = UIEdgeInsetsMake(10, 10, 10, 10)
</span><span class='line'>        //设置按钮文本的内部填充
</span><span class='line'>        followButton.titleEdgeInsets = UIEdgeInsetsMake(10, 10, 10, 10)
</span><span class='line'>        //为按钮添加点击事件
</span><span class='line'>        followButton.addTarget(self, action: "followAction", forControlEvents: .TouchUpInside)
</span><span class='line'>        view.addSubview(followButton)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>按钮点击事件响应方法：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func followAction(sender: UIButton) {
</span><span class='line'>    print("关注")
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>3、图片展示视图（UIImageView）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let imgView = UIImageView(frame: CGRectMake(0, 0, view.frame.size.width, view.frame.size.height))
</span><span class='line'>        //设置图片视图显示图片
</span><span class='line'>        imgView.image = UIImage(named: "exam.png")
</span><span class='line'>        //设置图片视图高亮状态显示图片
</span><span class='line'>        imgView.highlightedImage = UIImage(named: "exam1.png")
</span><span class='line'>        //设置图片视图内容展示模式：常见的几种内容展示模式
</span><span class='line'>        /**
</span><span class='line'>        *.ScaleToFill:缩放图片填满整个图片视图
</span><span class='line'>        *.ScaleAspectFit:缩放内容以适应原图尺寸，没有铺满的地方保持透明
</span><span class='line'>        *.ScaleAspectFill:按钮高亮显示状态
</span><span class='line'>        **/
</span><span class='line'>        imgView.contentMode = .ScaleAspectFit
</span><span class='line'>        //设置图片视图是否高亮显示
</span><span class='line'>        imgView.highlighted = true
</span><span class='line'>        //设置是否响应用户touch事件,默认为false
</span><span class='line'>        imgView.userInteractionEnabled = true
</span><span class='line'>        //播放一组图片
</span><span class='line'>        let img1 = UIImage(named: "play1.png")!
</span><span class='line'>        let img2 = UIImage(named: "play2.png")!
</span><span class='line'>        let img3 = UIImage(named: "play3.png")!
</span><span class='line'>        let images = [img1, img2, img3]
</span><span class='line'>        //设置需要播放的一组图片
</span><span class='line'>        imgView.animationImages = images
</span><span class='line'>        //设置播放持续时间
</span><span class='line'>        imgView.animationDuration = 1
</span><span class='line'>        //设置播放重复次数
</span><span class='line'>        imgView.animationRepeatCount = 20
</span><span class='line'>        //开始播放
</span><span class='line'>        imgView.startAnimating()
</span><span class='line'>        //停止播放
</span><span class='line'>        imgView.stopAnimating()
</span><span class='line'>        
</span><span class='line'>        view.addSubview(imgView);</span></code></pre></td></tr></table></div></figure>


<p>4、文字输入框（UITextField）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let textField = UITextField(frame: CGRectMake(20, 100, 100,30))
</span><span class='line'>        //设置文本编辑框显示文字
</span><span class='line'>        textField.text = "将编程进行到底"
</span><span class='line'>        //设置文本编辑框占位文字
</span><span class='line'>        textField.placeholder = "客官，你想不想要？"
</span><span class='line'>        //设置文本编辑框的边框显示类型
</span><span class='line'>        textField.borderStyle = .RoundedRect
</span><span class='line'>        //设置文本编辑框的文字字体
</span><span class='line'>        textField.font = UIFont.systemFontOfSize(15)
</span><span class='line'>        //设置文本编辑框的文本颜色
</span><span class='line'>        textField.textColor = UIColor.blackColor()
</span><span class='line'>        //设置文本编辑框输入文本时首字母是否自动大写
</span><span class='line'>        textField.autocapitalizationType = .None
</span><span class='line'>        //设置文本编辑框清除按钮显示模式
</span><span class='line'>        textField.clearButtonMode = .WhileEditing
</span><span class='line'>        //设置文本编辑框的文本对齐方式
</span><span class='line'>        textField.textAlignment = .Center
</span><span class='line'>        //设置文本编辑框返回键显示类型
</span><span class='line'>        textField.returnKeyType = .Search
</span><span class='line'>        //设置是否为安全文本输入状态
</span><span class='line'>        textField.secureTextEntry = true
</span><span class='line'>        //设置输入键盘类型
</span><span class='line'>        textField.keyboardType = .NumberPad
</span><span class='line'>        //设置文本编辑框的代理
</span><span class='line'>        textField.delegate = self
</span><span class='line'>        //唤起键盘，让文本编辑框成为第一响应者
</span><span class='line'>        textField.becomeFirstResponder()
</span><span class='line'>        view.addSubview(textField)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>UITextFiled代理方法（UITextFiledDelegate）:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//将要开始编辑代理方法,此方法会在键盘弹出之前调用
</span><span class='line'>    func textFieldShouldBeginEditing(textField: UITextField) -&gt; Bool {
</span><span class='line'>        return true
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //已经开始编辑代理方法，此方法会在键盘弹出之后调用
</span><span class='line'>    func textFieldDidBeginEditing(textField: UITextField) {
</span><span class='line'>        print(textField.text)
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //当return按钮被点击时调用
</span><span class='line'>    func textFieldShouldReturn(textField: UITextField) -&gt; Bool {
</span><span class='line'>        //收起键盘，注销文本编辑框为第一响应者
</span><span class='line'>        textField.resignFirstResponder()
</span><span class='line'>        return true
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //将要结束编辑代理方法，此方法会在收起键盘的时候调用
</span><span class='line'>    func textFieldShouldEndEditing(textField: UITextField) -&gt; Bool {
</span><span class='line'>        return true
</span><span class='line'>    }
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<p>5、开关控件（UISwitch）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    let sliderControl = UISlider(frame: CGRectMake(30, 200, 100, 30))
</span><span class='line'>    //设置滑动条控件最大值
</span><span class='line'>    sliderControl.maximumValue = 10
</span><span class='line'>    //设置滑动条控件最小值
</span><span class='line'>    sliderControl.minimumValue = 1
</span><span class='line'>    //设置滑动条控件初始值
</span><span class='line'>    sliderControl.value = 5
</span><span class='line'>    //设置滑动条控件最大值方向颜色显示
</span><span class='line'>    sliderControl.maximumTrackTintColor = UIColor.redColor()
</span><span class='line'>    //设置滑动条控件最小值方向颜色显示
</span><span class='line'>    sliderControl.minimumTrackTintColor = UIColor.brownColor()
</span><span class='line'>    //设置滑动条控件拖动按钮颜色
</span><span class='line'>    sliderControl.thumbTintColor = UIColor.blueColor()
</span><span class='line'>    //设置滑动条控件最大值方向图片显示：正常状态
</span><span class='line'>    sliderControl.setMaximumTrackImage(UIImage(named: "slidermax.png"), forState: .Normal)
</span><span class='line'>    //设置滑动条控件最小值方向图片显示：正常状态
</span><span class='line'>    sliderControl.setMinimumTrackImage(UIImage(named: "slidermin.png"), forState: .Normal)
</span><span class='line'>    //设置滑动条控件拖动按钮显示图片：正常状态
</span><span class='line'>    sliderControl.setThumbImage(UIImage(named: "thumb.png"), forState: .Normal)
</span><span class='line'>    //为滑动条控件添加：值改变触发事件
</span><span class='line'>    sliderControl.addTarget(self, action: "sliderAction:", forControlEvents: .ValueChanged)
</span><span class='line'>    view.addSubview(sliderControl)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>开关值改变事件响应方法：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sliderAction(sliderControl: UISlider) {
</span><span class='line'>        print("the slider value is \(sliderControl.value)")
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>6、加载指示器视图（UIActivityIndicatorView）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let activityControl = UIActivityIndicatorView(frame: CGRectMake(100, 200, 30, 30))
</span><span class='line'>        //设置加载指示器视图的风格
</span><span class='line'>        activityControl.activityIndicatorViewStyle = .Gray
</span><span class='line'>        //设置加载指示器视图的背景颜色
</span><span class='line'>        activityControl.backgroundColor = UIColor.redColor()
</span><span class='line'>        //开始动画
</span><span class='line'>        activityControl.startAnimating()
</span><span class='line'>        //停止动画
</span><span class='line'>        activityControl.stopAnimating()
</span><span class='line'>        view.addSubview(activityControl)</span></code></pre></td></tr></table></div></figure>


<p>7、分段控件视图（UISegmentedControl）:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let items = ["全部", "电影", "新闻", "科技"]
</span><span class='line'>        let segmentedControl = UISegmentedControl(items: items)
</span><span class='line'>        segmentedControl.frame = CGRectMake(30, 200, 180, 30)
</span><span class='line'>        //设置分段控件颜色
</span><span class='line'>        segmentedControl.tintColor = UIColor.redColor()
</span><span class='line'>        //设置分段控件默认选中索引
</span><span class='line'>        segmentedControl.selectedSegmentIndex = 1
</span><span class='line'>        //为分段控件添加值改变响应事件
</span><span class='line'>        segmentedControl.addTarget(self, action: "segmentControlAction:", forControlEvents: .ValueChanged)
</span><span class='line'>        view.addSubview(segmentedControl)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>分段控件值改变事件响应方法：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func segmentControlAction(segmentedControl: UISegmentedControl) {
</span><span class='line'>        if segmentedControl.selectedSegmentIndex == 0 {
</span><span class='line'>
</span><span class='line'>        } else if segmentedControl.selectedSegmentIndex == 1 {
</span><span class='line'>
</span><span class='line'>        } else if segmentedControl.selectedSegmentIndex == 2{
</span><span class='line'>
</span><span class='line'>        } else {
</span><span class='line'>
</span><span class='line'>        }
</span><span class='line'>       print("the segmented Control selected Index is \(segmentedControl.selectedSegmentIndex)")
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>8、页面控件（UIPageControl）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let pageControl = UIPageControl(frame: CGRectMake(30, 200, 180, 30))
</span><span class='line'>        //设置页面控件的背景颜色
</span><span class='line'>        pageControl.backgroundColor = UIColor.brownColor()
</span><span class='line'>        //设置总页数
</span><span class='line'>        pageControl.numberOfPages = 4
</span><span class='line'>        //设置当前页数
</span><span class='line'>        pageControl.currentPage = 1
</span><span class='line'>        //设置页面控件指示器颜色
</span><span class='line'>        pageControl.pageIndicatorTintColor = UIColor.redColor()
</span><span class='line'>        //设置页面控件当前页面指示器颜色
</span><span class='line'>        pageControl.currentPageIndicatorTintColor = UIColor.blueColor()
</span><span class='line'>        //添加页面控件点击响应事件
</span><span class='line'>        pageControl.addTarget(self, action: "changeAction:", forControlEvents: .TouchUpInside)
</span><span class='line'>        view.addSubview(pageControl)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>页面控件点击响应事件：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func changeAction(pageControl: UIPageControl) {   
</span><span class='line'>  print("the current select page is :\(pageControl.currentPage)")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>9、警告视图控制器（UIAlertController）：(UIAlertView 与 UIActionSheet在iOS8.0之后就弃用了，推荐使用UIAlertController)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    /**
</span><span class='line'>     * .Alert
</span><span class='line'>     * .ActionSheet
</span><span class='line'>     */
</span><span class='line'>    let alertCtrl = UIAlertController(title: "提示信息", message: "确定返回吗？", preferredStyle: .Alert)
</span><span class='line'>    //初始化警告动作
</span><span class='line'>    let cancelAction = UIAlertAction(title: "取消", style: .Cancel) { (action) -&gt; Void in
</span><span class='line'>        //...
</span><span class='line'>        //添加相应处理代码
</span><span class='line'>        //...
</span><span class='line'>        //把UIAlertController从父视图控制器中移除，防止内存泄漏
</span><span class='line'>        alertCtrl.removeFromParentViewController()
</span><span class='line'>    }
</span><span class='line'>    let okAction = UIAlertAction(title: "立即返回", style: .Default) { (action) -&gt; Void in
</span><span class='line'>        //...
</span><span class='line'>        //添加相应处理代码
</span><span class='line'>        //...
</span><span class='line'>        //把UIAlertController从父视图控制器中移除，防止内存泄漏
</span><span class='line'>        alertCtrl.removeFromParentViewController()
</span><span class='line'>    }
</span><span class='line'>    //添加动作
</span><span class='line'>    alertCtrl.addAction(cancelAction)
</span><span class='line'>    alertCtrl.addAction(okAction)
</span><span class='line'>    //弹出警告视图控制器
</span><span class='line'>    self.presentViewController(alertCtrl, animated: true, completion: nil)</span></code></pre></td></tr></table></div></figure>


<p>10、 进度条视图（UIProgressView）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> let progressView = UIProgressView(progressViewStyle: .Bar)
</span><span class='line'>    progressView.frame = CGRectMake(30, 200, 180, 30)
</span><span class='line'>    //设置默认进度
</span><span class='line'>    progressView.progress = 0.3
</span><span class='line'>    //设置进度条加载过的颜色
</span><span class='line'>    progressView.progressTintColor = UIColor.redColor()
</span><span class='line'>    //设置进度条未加载过的颜色
</span><span class='line'>    progressView.trackTintColor = UIColor.blueColor()
</span><span class='line'>    //设置进度条加载过的图片展示
</span><span class='line'>    progressView.progressImage = UIImage(named: "progress.png")
</span><span class='line'>    //设置进度条未加载过的图片展示
</span><span class='line'>    progressView.trackImage = UIImage(named: "track.png")
</span><span class='line'>    view.addSubview(progressView)</span></code></pre></td></tr></table></div></figure>


<p>11、 工具条控件（UIToolBar）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    let toolBar = UIToolbar(frame: CGRectMake(30, 200, 180, 49))
</span><span class='line'>    //设置工具条展示风格
</span><span class='line'>    toolBar.barStyle = .Default
</span><span class='line'>    //添加工具条按钮
</span><span class='line'>    let item = UIBarButtonItem(barButtonSystemItem: .Done, target: self, action: "itemButtonAction")
</span><span class='line'>    let item1 = UIBarButtonItem(barButtonSystemItem: .Edit, target: self, action: "itemButtonAction")
</span><span class='line'>    //固定间距工具条按钮
</span><span class='line'>    let item2 = UIBarButtonItem(barButtonSystemItem: .FixedSpace, target: self, action: "itemButtonAction")
</span><span class='line'>    item2.width = 30
</span><span class='line'>    let customButton = UIButton(type: .DetailDisclosure)
</span><span class='line'>    customButton.addTarget(self, action: "itemButtonAction", forControlEvents: .TouchUpInside)
</span><span class='line'>    //自定义按钮为工具条按钮
</span><span class='line'>    let item3 = UIBarButtonItem(customView: customButton)
</span><span class='line'>    let items = [item, item1, item2, item3]
</span><span class='line'>    //设置工具条要显示的所有按钮
</span><span class='line'>    toolBar.items = items
</span><span class='line'>    view.addSubview(toolBar)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>工具条按钮点击响应事件：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func itemButtonAction() {
</span><span class='line'>        print("tool bar button")
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015年终总结]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/01/2015nian-zhong-zong-jie/"/>
    <updated>2016-01-01T13:26:26+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/01/2015nian-zhong-zong-jie</id>
    <content type="html"><![CDATA[<h4>总结：</h4>

<p>回首过去一年，好像没有什么能说出口的成绩，专业没啥进步。在公司做了两款App，上半年主要开发的是一款叫“在线等”的手机应用，这是一款解决人们选择困难症的应用，经过重重困难，最终上线。没啥成绩可言。下半年主要研发的是一款叫“斗图神器”的应用，由于Android版早就开发好了，所以iOS版开发起来就快很多了。总的来说成绩还不错，其中也有点小波折。<!--more-->现在已经提交过3，4版了。目前“斗图神器”项目已经引入了全新的Swift语言与Objective-C语言混编。目的是拥抱Swift，它才是未来。这对我们来说是好事，有项目环境学习新语言就更快了。现在我还是处于Swift 初级入门阶段，明年希望能进一步提高吧！在学习方面，搭建了自己的<a href="http://yangshebing.github.io"><strong>个人技术博客</strong></a>，另外还写了几篇质量不高的博文，在github上放了几个质量不高的demo。买了手机和电脑，这也算专业学习上的投入吧。生活上，除了每天写写代码，并没有什么其他变化。4月份去了一趟泰山，7月份去了一次十渡，10月份游了半个北京（虽然来北京久了，却很少出去）顺带去了一趟天津。今年最大的事情就是拔了一颗智齿和一颗蛀牙，花了不少钱，现在都没弄好！折腾了半条命（太背），一直不太顺。其次就是大病没犯，小病不断，北京这边雾霾比较严重。咽炎也挺折腾人的。本来年底是计划上线一款自己的app,由于各种借口各种拖最终没能实现，也没啥可遗憾的，主要是自己没有努力。其实还计划学习一门除专业外的语言，这个计划也耽搁了！计划内的写一个插件，现在也还没开动！专业书今年没有仔细读过，其实应该多读几本。扩展书籍就读过《高效能人士的7个习惯》与《从0到1》。总而言之就是读的书还是太少，平常大部分时间是在网上看别人的博客学习，看官方文档，不会的就自己用google搜索。人丑就要多读书。越来越不会说话了，已经想不起还有什么要说的了，那就先写到这吧！共勉！
2016的计划与展望：</p>

<h4>计划：</h4>

<ul>
<li>1、  读10本以上的专业相关的书籍，扩展阅读书籍不少于5本。</li>
<li>2、  学一门专业外的语言</li>
<li>3、  在github上开源5个项目（高质量）</li>
<li>4、  博客不少于50篇博文（高质量）</li>
<li>5、  找个女盆友</li>
<li>6、  福利计划：去国外旅游一次（条件如下）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if plan five implement {
</span><span class='line'>      implement plan six
</span><span class='line'>} else {
</span><span class='line'>      nothing happened
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>展望：</h4>

<p>马上迎来全新的2016年，又是一个全新的开始。时间匆匆，趁着年轻就要好好努力，物尽其用。希望在新的一年里，事业蒸蒸日上，身体健健康康（身体是革命的本钱，是实现计划的基石），愿家人幸福安康。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS FFmpeg编译及kxmovie、iFrameExtractor调试详解（无障碍阅读，绝对是你想要的）]]></title>
    <link href="http://yangshebing.github.io/blog/2015/11/16/ios-ffmpegbian-yi-ji-kxmovie,-iframeextractordiao-shi-xiang-jie-(wu-zhang-ai-yue-du-,jue-dui-shi-ni-xiang-yao-de-)/"/>
    <updated>2015-11-16T01:44:27+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/11/16/ios-ffmpegbian-yi-ji-kxmovie,-iframeextractordiao-shi-xiang-jie-(wu-zhang-ai-yue-du-,jue-dui-shi-ni-xiang-yao-de-)</id>
    <content type="html"><![CDATA[<p><strong>特此声明：本文是通过网上收集整理加上自己亲自实验得来的。感谢所有网上分享的辛勤劳动者，本文仅供iOS学习使用。在学习的过程中，如果有问题或者不清楚的地方，欢迎留言，我们共同探讨互相学习。欢迎批评指正。</strong></p>

<p><strong>如需转载，请注明出处：<a href = "http://blog.csdn.net/yangshebing21/article/details/43986913"><a href="http://blog.csdn.net/yangshebing21/article/details/43986913">http://blog.csdn.net/yangshebing21/article/details/43986913</a></a></strong></p>

<h4>开发环境：最新 ffmpeg-2.5.4/iOS SDK8.1/Xcode6.1/OS X Yosemite版本10.10.2</h4>

<h3>一、编译ffmpeg库</h3>

<h4>编译调试ffmpeg库的步骤：</h4>

<p><strong>开发环境：ffmpeg-2.5.4/Xcode6.1</strong></p>

<h4>（一）、下载ffmpeg源码：</h4>

<p>请点击此链接<a href = "http://ffmpeg.org/download.html"><a href="http://ffmpeg.org/download.html">http://ffmpeg.org/download.html</a></a></p>

<p> <font color = "red"><b>注：我的ffmpeg-2.5.4是解压放至Desktop的</b></font></p>

<h4>（二）、调试编译ffmpeg源码</h4>

<p> 1、安装yasm:
 <!--more--></p>

<p> 方法一:</p>

<p> 在终端输入</p>

<pre><code class="`"> sudo curlhttp://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz &gt;yasm.tar.gz
</code></pre>

<p>方法二：</p>

<p>（1）Download yasm sourcecode from：
  <a href = "http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz"><a href="http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz">http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz</a></a></p>

<p>（2）Unpack tar xvzfyasm-1.2.0.tar.gz</p>

<p>（3）cd yasm-1.2.0</p>

<p>（4）Configure and build:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./configure && make -j 4 &&sudo make install</span></code></pre></td></tr></table></div></figure>


<p>2、下载pearl脚本文件：gas-preprocessor.pl：</p>

<p>下载地址： <a href = "https://github.com/libav/gas-preprocessor"><a href="https://github.com/libav/gas-preprocessor">https://github.com/libav/gas-preprocessor</a></a></p>

<p>（1）拷贝gas-preprocessor.pl文件到 /usr/bin 目录下。</p>

<p>如果找不到/usr/bin目录，直接使用”Finder—>前往—> 前往文件夹—>/usr/bin”或者使用快捷键“shift+command+G”前往文件夹，到指定目录下粘贴gas-preprocessor.pl文件</p>

<p>（2）修改gas-preprocessor.pl文件的读写权限，使用 chmod a+rwxgas-preprocessor.pl</p>

<p>用终端命令cd定位到 gas-preprocessor.pl文件夹下执行：<code>chmod a+rwxgas-preprocessor.pl</code>命令</p>

<p>3、下载build-shell.sh脚本文件：</p>

<p>下载地址：<a href = "https://github.com/kewlbear/FFmpeg-iOS-build-script"><a href="https://github.com/kewlbear/FFmpeg-iOS-build-script">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></a></p>

<p>（1）下载解压build-shell.sh文件</p>

<p>（2）定位至build-shell.sh文件夹执行build-shell.sh脚本文件</p>

<p>使用方式有4种，我们可以根据特定的使用环境来执行对应的脚本，一般我们就直接执行：<code>./build-ffmpeg.sh</code></p>

<ul>
<li>To build everything:</li>
</ul>


<p><strong><code>./build-ffmpeg.sh</code></strong></p>

<ul>
<li>To build arm64 libraries：</li>
</ul>


<p><strong><code>./build-ffmpeg.sh arm64</code></strong></p>

<ul>
<li>To build fat libraries for armv7 and x86_64 (64-bit simulator)：</li>
</ul>


<p><strong><code>./build-ffmpeg.sh armv7 x86_64</code></strong></p>

<ul>
<li>To build fat libraries from separately built thin libraries:</li>
</ul>


<p><strong><code>./build-ffmpeg.sh lipo</code></strong></p>

<p>注：我的build-shell.sh是解压放至Desktop的，以上四种shell脚本的使用方式来自<a href = "https://github.com/kewlbear/FFmpeg-iOS-build-script"><a href="https://github.com/kewlbear/FFmpeg-iOS-build-script">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></a>，后面几种方式大家可以自己去尝试。</p>

<p>4、脚本执行完成之后，会在桌面上生成三个文件夹：“FFmpeg-iOS”“scratch”和”thin”文件夹</p>

<p>scratch文件夹里面是单独编译的库，FFmpeg-iOS文件夹里面是合并编译的库。在使用的过程中，我们主要会用到FFmpeg-iOS 文件夹下的“include”文件夹和"lib"文件夹中的文件。</p>

<h3>二、在工程中使用FFmpeg，网上成熟的有kxmovie。</h3>

<p>1、下载kxmovie工程进行测试：</p>

<p>下载地址： <a href = "https://github.com/kolyvan/kxmovie"><a href="https://github.com/kolyvan/kxmovie">https://github.com/kolyvan/kxmovie</a></a></p>

<p>把FFmpeg编译出来的.a文件添加到工程中。</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37q81fp5j205r09xwfq.jpg" alt="" /></p>

<p>在使用的时候得注意添加下面的动态链接库文件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>libz.dylib
</span><span class='line'>libbz2.dylib
</span><span class='line'>libiconv.dylib</span></code></pre></td></tr></table></div></figure>


<p><strong>运行工程</strong></p>

<p>以下是在编译运行工程中可能会报的错误：</p>

<p>注意：如果在FFmpeg编译的时候出现“ffmpeg yasm not found，use &ndash;disable for a crippled build”，原因是 yasm是汇编编译器，因为FFmpeg中为了提高效率用到了汇编指令，解决这个问题有两种方法，一是下载一个yasm.exe安装在mingw/bin下面；二是不使用汇编指令，在配置上加上 即 ./configure &ndash;disable-yash 。(这就是为什么前面提到了要安装yasm)
成功通过编译（这里是指FFmpeg编译成静态库文件）</p>

<p>通过后会生成一个compiled(FFmpeg-iOS)的文件夹，里面有include和lib两个文件夹，这两个文件夹都要拷贝至工程目录下面。include是静态链接库要用到的头文件，lib是存放静态链接库的文件，然后把这些文件存放在项目里面即可，一定要把文件也copy进去，然后在项目的build settings中的header search paths字段加入include文件的路径 如：“$(SRCROOT)/ffmpeg/include” 前面的复选框选不选都可以；再在library search paths字段中加入a文件的路径 如：“$(SRCROOT)/ffmpeg/lib” 。否则可能会出现libavformat/avformat.h file not found 的错误。（出现这个错误是指编译kxmovie工程找不到相应的头文件）</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37rw3nknj20m207wwgg.jpg" alt="" /></p>

<p>上面图示：在工程目录下有个“FFmpeg”的文件夹，分别把编译FFmpeg完成后产生的“ FFmpeg-iOS ”文件夹中的“include”和”lib”文件夹拷贝至”FFmpeg”文件夹中，include文件夹中存放的是头文件，lib文件夹中存放的是.a静态库文件。最后就是在工程目录下的FFmpeg文件夹包含“include”和”lib”两个文件夹。设置Header Search Paths和Library Search Paths时直接include和lib两个文件夹拖上去，自动显示路径。</p>

<p><img src="http://ww4.sinaimg.cn/large/7f266405jw1ey37subv8hj20gu06omye.jpg" alt="" /></p>

<p>如果还出现找不到 avformat_open_input 的错误（我的没有出现过这个错误），说明你的ffmpeg还是太新了，之前的那个方法名已经改成了这个名字，把avformat_open_input改成av_open_input_file 就可以了。其他错误请自行谷歌或者留言，我们共同探讨。
上面报错总结文章来自：<a href="http://www.dnetzj.com/Content/267.html">http://www.dnetzj.com/Content/267.html</a></p>

<p>最后一步，别忘了安装kxmovie.xcworkspace的cocoapods</p>

<p><strong><code>pod install --verbose --no-repo-update</code></strong></p>

<p>否则会报链接错误</p>

<p>以上kxmovie工程编译调试完毕，模拟器真机都通过测试。目前没有进一步的去研究这个工程，发现播放的视频质量有点粗糙。有时间再做进一步的研究。</p>

<h3>三、iFrameExtractor-master（iFrameExtractor）工程编译和运行</h3>

<p>（1）运行iFrameExtractor-master工程，与上面kxmovie工程操作一样，把FFmpeg文件夹拷贝至工程目录下:
       (工程目录下本来是没有FFmpeg文件夹的)</p>

<p><img src="http://ww1.sinaimg.cn/large/7f266405jw1ey37tiypu8j20gx07b75s.jpg" alt="" /></p>

<p>iFrameExtractor-master下载地址：<a href="https://github.com/lajos/iFrameExtractor">https://github.com/lajos/iFrameExtractor</a></p>

<p>(2)设置好Header Search Paths和Library Search Paths</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37u3v6q5j20kj02x0ts.jpg" alt="" /></p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37v057v9j20kg07p40a.jpg" alt="" /></p>

<p>（3）最后还是会报链接错误：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Undefined symbols for architecture i386:
</span><span class='line'>"_iconv", referenced from:      
</span><span class='line'>    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)  
</span><span class='line'>"_iconv_close", referenced from:
</span><span class='line'>    _avcodec_open2 in libavcodec.a(utils.o)
</span><span class='line'>    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)
</span><span class='line'>"_iconv_open", referenced from:
</span><span class='line'>    _avcodec_open2 in libavcodec.a(utils.o)
</span><span class='line'>    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)
</span><span class='line'>ld: symbol(s) not found for architecture i386
</span><span class='line'>clang: error: linker command failed with exit code 1 (use -v to see invocation)</span></code></pre></td></tr></table></div></figure>


<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37vhigjfj20fq0a8djf.jpg" alt="" /></p>

<p><strong>解决办法："TARGETS" - > &ldquo;BuildSettings&rdquo; - > &ldquo;Other Linker Flags&rdquo; 添加other Linker Flags 项：-liconv</strong></p>

<p><img src="http://ww1.sinaimg.cn/large/7f266405jw1ey37wvjqv1j20dl01s74f.jpg" alt="" /></p>

<p>此报错问题出自：<a href = "http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851"><a href="http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851">http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851</a></a></p>

<p>至此完成iFrameExtractor-master工程编译和运行</p>

<h3>本文参考文章资料：</h3>

<ul>
<li><a href = "http://blog.csdn.net/oqqQuZi1234567/article/details/43152689">iOS－－kxmovie之FFmpeg编译和使用</a></li>
<li><a href = "http://www.th7.cn/Program/Ruby/201502/385491.shtml">iOS ffmpeg kxmovie 编译 调试</a></li>
</ul>


<p><strong>欢迎共同学习进步，本着分享的精神，只是为了让你学习起来更加轻松。</strong></p>

<p><strong>如需转载，请注明出处：<a href = "http://blog.csdn.net/yangshebing21/article/details/43986913"><a href="http://blog.csdn.net/yangshebing21/article/details/43986913">http://blog.csdn.net/yangshebing21/article/details/43986913</a></a></strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UICollectionView（纯代码方式）实现带上下拉刷新的瀑布流式（WaterFlow）布局]]></title>
    <link href="http://yangshebing.github.io/blog/2015/11/03/waterflow/"/>
    <updated>2015-11-03T22:40:32+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/11/03/waterflow</id>
    <content type="html"><![CDATA[<p>瀑布流（WaterFlow）是项目开发过程中的常见布局，有关于瀑布流（WaterFlow）的实现方式：在UICollectionView未出现之前，瀑布流的实现多半是采用UIScrollView或是UITableView。对于我们这种用惯了表视图的人来说，UICollectionView倒略显陌生。有关于UICollectionView的介绍我就不一一赘述，因为一两句话也很难说清楚。网上有很多优秀的文章专门对其进行了一系列的解说，另有苹果官方文档可以查阅。本文主要是介绍如何采用纯代码的方式利用UICollectionView实现带上下拉刷新的瀑布流式（WaterFlow）布局。废话少说，直接入题。</p>

<!--more-->


<h4>一、UICollectionView集成上下拉刷新</h4>

<p>（1）简单的介绍UICollectionView</p>

<p>UICollectionView和UITableView很相似，如果你对表视图非常熟悉，上手的速度也会快很多。使用它时需要相应的设置DataSource（UICollectionViewDataSoure)数据源协议和Delegate（UICollectionViewDelegate)事件协议，并实现相应的协议方法。它与UITableView不同的地方是它有UICollectionViewLayout，可以通过它的子类来定制布局。系统默认的布局方式是UICollectionViewDelegateFlowLayout，实现相应的协议（UICollectionViewDelegateFlowLayout）方法，便可达到默认布局效果。</p>

<p>UICollectionViewCell与UITableViewCell的使用也差不多，一样的有ReuseIdentifier,可以复用。使用UICollectionViewCell时，需要先注册，然后再出列使用。至于注册并出列使用Cell的具体方式，请自行下载文章末尾的BGWaterFlowView或者自行Google。</p>

<p>（2）集成上下拉刷新方式</p>

<p>一般UITableView添加上下拉刷新的方式，是把下拉或者上拉刷新视图的UI放置UITableView的表头属性(tableHeaderView)或者表尾属性（tableFooterView）。但是，在UICollectionView中没有这两个属性。那么我们该如何来集成上下拉刷新呢？这就得说到
UICollectionView布局中的三种显示内容视图：Cells、Supplementary views、Decoration views。(关于这三种视图的介绍可以去官网查阅相关文档，上面有详细的解释)。我们一般是把上下拉刷新的UI放置在Supplementary views（官方解释：它能显示数据但是不同于Cells。不像Cell,Supplementary views是不能被用户选定的。相反，你可以用它去实现类似于给一个指定的section或者整个CollectionView添加页眉和页脚视图这样的功能）上面，其实，Supplementary views就和TableView的section头视图和尾视图差不多。但是用法却大不相同。在自定义瀑布流布局中一定要把它也计算进去，不然显示就会有异常。</p>

<ul>
<li><strong>注册头视图和尾视图单元格类型</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//注册头视图：kind代表Supplementary视图类型，UICollectionElementKindSectionHeader表示组头
</span><span class='line'>
</span><span class='line'>[self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"bGCollectionHeaderView"];
</span><span class='line'>
</span><span class='line'>//注册尾视图：UICollectionElementKindSectionHeader表示组尾
</span><span class='line'>
</span><span class='line'>    [self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"bGCollectionFooterView"];
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>实现自定义组视图viewForSupplementaryElementOfKind代理方法</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath {
</span><span class='line'>
</span><span class='line'>  //kind代表Supplementary视图类型：头或尾视图（header OR footer）
</span><span class='line'>  
</span><span class='line'>    if([kind isEqual:UICollectionElementKindSectionHeader]) {
</span><span class='line'>        UICollectionReusableView *collectionHeaderView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"bGCollectionHeaderView" forIndexPath:indexPath];
</span><span class='line'>        
</span><span class='line'>        //初始化下拉刷新或者自定义页眉视图UI界面
</span><span class='line'>        ...
</span><span class='line'>        
</span><span class='line'>        return collectionHeaderView;
</span><span class='line'>    } else if([kind isEqual:UICollectionElementKindSectionFooter]) {
</span><span class='line'>        UICollectionReusableView *collectionFooterView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"bGCollectionFooterView" forIndexPath:indexPath];
</span><span class='line'>        
</span><span class='line'>        //初始化上拉刷新或者自定义页脚视图UI界面
</span><span class='line'>        ...
</span><span class='line'>        
</span><span class='line'>        return collectionFooterView;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return nil;
</span><span class='line'>}
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<p>完成以上两步，集成上下拉刷新的功能总算完成了。接下来你可以运行一下工程，看结果是否符合预期。如果你CollectionView使用的是系统的UICollectionViewFlowLayout布局，一定要返回组头或者组尾的高度，否则就会出现组头或者组尾无法显示（本文的下拉刷新视图所在的组头不返回高度不受影响，是因为它的纵坐标（y值）本来就是负数）。另外，还有一点需要注意的是，如果你的CollectionView中存在多组，最好是把上下拉刷新所在的组头或者组尾与其他组（section）的组头或组尾分开，相应的需要多注册一个组头或者组尾视图，分情况进行判断(这部分如果还有问题，可以在文章末尾留言，我会及时回复)。</p>

<h4>二、自定义瀑布流（WaterFlow）式布局</h4>

<p>（1）简单的介绍UICollectionView布局形式</p>

<p>一般来讲，UICollectionView的布局形式分为两种：</p>

<ul>
<li><p>布局与内容独立，其布局不需要根据显示的单元格内容来计算。Cell的显示顺序与内容顺序一致。Cell排满一行则换至下一行继续排列。系统的UICollectionViewFlowLayout就是这样。</p></li>
<li><p>布局需要计算内容，本文的瀑布流Demo局部正是如此。UICollectionViewFlowLayout系统布局在换行的时候，由于每个item高度不同，从而导致布局错乱，无法满足你的需求。所以，这个时候你需要计算每个item的高度，最终用来确定item显示的位置。</p></li>
</ul>


<p>从上述内容我们可以看出，一般如果布局需要计算内容的时候，我们就不应该直接使用UICollectionViewFlowLayout布局了，而是应该子类化一个UICollectionViewLayout，从而达到私人定制的目的。</p>

<p>（2）创建自定义布局</p>

<p><a href = "https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/CreatingCustomLayouts/CreatingCustomLayouts.html#//apple_ref/doc/uid/TP40012334-CH5-SW1">官方文档</a>中有提到，在布局的过程中，CollectionView会调用布局对象的具体方法。这些方法有机会使你计算这些项的位置以及给CollectionView提供它所需要的主要信息。其他的方法也有可能会被调用，但是在布局的过程中这些方法总是会按照以下的顺序调用：</p>

<ol>
<li>使用"prepareLayout"方法去执行一些CollectionView所需要的布局信息的预先计算操作。</li>
<li>使用"collectionViewContentSize"方法去返回根据你最初计算的整个内容区域的总体大小。</li>
<li>使用"layoutAttributesForElementsInRect:&ldquo;方法来返回指定区域的单元格与视图属性。</li>
</ol>


<p>下面我们通过Demo来详细的讲解一下如何自定义瀑布流，废话不多说，直接上代码（本文采用的Demo为<strong>BGWaterFlowView</strong>,<strong>GitHub传送门</strong>：<a href = 'https://github.com/yangshebing/BGWaterFlowView'>请点击这里</a>）：</p>

<ul>
<li><strong>重写"prepareLayout"方法计算布局信息。</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)prepareLayout{
</span><span class='line'>    [super prepareLayout];
</span><span class='line'>    ...
</span><span class='line'>    
</span><span class='line'>    //计算每个显示项的宽度，horizontalItemSpacing代表项与项之间的水平间隔， 
</span><span class='line'>    columnNum代表总列数，contentInset代表上下左右的内填充。详见下图说明
</span><span class='line'>    
</span><span class='line'>    self.itemWidth = (self.collectionView.frame.size.width - (self.horizontalItemSpacing * (self.columnNum - 1)) - self.contentInset.left - self.contentInset.right) / self.columnNum;
</span><span class='line'>    
</span><span class='line'>    //如有下拉刷新需求的则需要提供头视图（Supplementary view）布局属性。
</span><span class='line'>    demo中的headerHeight属性可设置是否显示头视图（是否计算头视图的布局属性）。
</span><span class='line'>    
</span><span class='line'>    if(self.headerHeight &gt; 0){
</span><span class='line'>    
</span><span class='line'>    //通过layoutAttributesForSupplementaryViewOfKind:withIndexPath:方法来创建Supplementary视图布局属性对象，kind用来区分Supplementary视图类型（header或者footer）。
</span><span class='line'>    
</span><span class='line'>        self.headerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionHeader withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];
</span><span class='line'>        
</span><span class='line'>        //修改布局参数frame属性
</span><span class='line'>        
</span><span class='line'>        self.headerLayoutAttributes.frame = CGRectMake(0, 0, self.collectionView.frame.size.width, self.headerHeight);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //初始化保存布局属性的字典
</span><span class='line'>    NSMutableDictionary *cellLayoutInfoDic = [NSMutableDictionary dictionary];
</span><span class='line'>    //初始化列高数组
</span><span class='line'>    NSMutableArray *columnInfoArray = [self columnInfoArray];
</span><span class='line'>    NSInteger numSections = [self.collectionView numberOfSections];
</span><span class='line'>    for(NSInteger section = 0; section &lt; numSections; section++)  {
</span><span class='line'>        NSInteger numItems = [self.collectionView numberOfItemsInSection:section];
</span><span class='line'>        for(NSInteger item = 0; item &lt; numItems; item++){
</span><span class='line'>            //获取列高最小的model，以它的高作为y坐标
</span><span class='line'>            BGWaterFlowModel *firstModel = columnInfoArray.firstObject;
</span><span class='line'>            CGFloat y = firstModel.height;
</span><span class='line'>            CGFloat x = self.contentInset.left + (self.horizontalItemSpacing + self.itemWidth) * firstModel.column;
</span><span class='line'>            
</span><span class='line'>            NSIndexPath *indexPath = [NSIndexPath indexPathForItem:item inSection:section];
</span><span class='line'>            
</span><span class='line'>            //通过代理方法传入对应item的高度。
</span><span class='line'>            
</span><span class='line'>            CGFloat itemHeight = [((id&lt;BGWaterFlowLayoutDelegate&gt;)self.collectionView.delegate) collectionView:self.collectionView layout:self heightForItemAtIndexPath:indexPath];
</span><span class='line'>            
</span><span class='line'>            //通过layoutAttributesForCellWithIndexPath:方法来创建cell的布局属性对象。
</span><span class='line'>            
</span><span class='line'>            UICollectionViewLayoutAttributes *itemAttributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];
</span><span class='line'>            //计算item的布局属性
</span><span class='line'>            itemAttributes.frame = CGRectMake(x, y+self.contentInset.top+self.headerHeight, self.itemWidth, itemHeight);
</span><span class='line'>            //计算当前列高,verticalItemSpacing代表项与项之间的垂直间隔。
</span><span class='line'>            firstModel.height += (itemHeight + self.verticalItemSpacing);
</span><span class='line'>            //保存新的列高，并进行排序：从后往前查找，查找到高度比它小的对象，就插入到该对象之后。
</span><span class='line'>            [self sortArrayByHeight:columnInfoArray];
</span><span class='line'>            
</span><span class='line'>     //保存计算好的item布局属性
</span><span class='line'>     cellLayoutInfoDic[indexPath] = itemAttributes;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //保存局部布局属性字典到全局字典中
</span><span class='line'>    self.cellLayoutInfoDic = [cellLayoutInfoDic copy];
</span><span class='line'>    
</span><span class='line'>    //按照前面的排序逻辑，列高数组中的最后一个元素，就是高度最大的一列。
</span><span class='line'>    BGWaterFlowModel *lastModel = columnInfoArray.lastObject;
</span><span class='line'>    
</span><span class='line'>    //如有上拉刷新需求的则需要提供尾视图布局属性。
</span><span class='line'>    demo中的footerHeight属性可设置是否显示尾视图（是否计算尾视图的布局属性）。
</span><span class='line'>    
</span><span class='line'>    if(self.footerHeight &gt; 0){
</span><span class='line'>        self.footerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionFooter withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];
</span><span class='line'>        //计算尾视图的布局属性
</span><span class='line'>        self.footerLayoutAttributes.frame = CGRectMake(0, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom, self.collectionView.frame.size.width, self.footerHeight);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //直接计算出collectionView的contentSize
</span><span class='line'>    self.contentSize = CGSizeMake(self.collectionView.frame.size.width, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom+self.footerHeight);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p><strong>好吧，这么一大坨代码看到就头疼了，来张图帮助理解一下！图糙理不糙，理解万岁</strong>
<img src="http://ww4.sinaimg.cn/mw690/7f266405jw1ey25ujzticj218a0xmjww.jpg" alt="" /></p>

<p><strong>这样看上去是不是更清晰了？</strong></p>

<ul>
<li><strong>重写"collectionViewContentSize"方法返回collectionView的内容高度。</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (CGSize)collectionViewContentSize{
</span><span class='line'>  //返回计算好的collectionView内容高度
</span><span class='line'>    return self.contentSize;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>重写"layoutAttributesForElementsInRect"方法返回指定矩形区域中的cell或者其他类型视图布局属性。</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect {
</span><span class='line'>
</span><span class='line'>  //返回一组已经计算好的布局属性。
</span><span class='line'>  
</span><span class='line'>    NSMutableArray *attributesArrs = [NSMutableArray array];
</span><span class='line'>    [self.cellLayoutInfoDic enumerateKeysAndObjectsUsingBlock:^(NSIndexPath *indexPath,
</span><span class='line'>                                                                UICollectionViewLayoutAttributes *attributes,
</span><span class='line'>                                                                BOOL *stop) { 
</span><span class='line'>        //遍历布局属性保存字典，添加布局属性至数组中                                                       
</span><span class='line'>        if (CGRectIntersectsRect(rect, attributes.frame)) {
</span><span class='line'>            [attributesArrs addObject:attributes];
</span><span class='line'>        }
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    //如果有头视图或者尾视图则需要添加头视图与尾视图的布局属性
</span><span class='line'>    
</span><span class='line'>    if (self.headerLayoutAttributes && CGRectIntersectsRect(rect, self.headerLayoutAttributes.frame)) {
</span><span class='line'>        [attributesArrs addObject:self.headerLayoutAttributes];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    
</span><span class='line'>    if (self.footerLayoutAttributes && CGRectIntersectsRect(rect, self.footerLayoutAttributes.frame)) {
</span><span class='line'>        [attributesArrs addObject:self.footerLayoutAttributes];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return attributesArrs;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>结语：</h4>

<p><a href = "https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/index.html#//apple_ref/occ/cl/UICollectionViewLayout">UICollectionViewLayout</a>相关的内容姿势非常多，相关文章也非常多。本文介绍的瀑布流布局也只是其中的冰山一角，很多东西官方文档中已经介绍的非常详细了。所以，还是建议多看官方文档。本文主要注重项目的实用性，在后面就直接上代码了，可能在理论方面还是有所欠缺，对于不足的地方，希望大家多提建议，一起交流学习，一起进步。如果文中有看不懂的地方，还请您留言。我会及时进行回复。最后，本文的Demo就在于方便徒手撸代码的人使用。你懂的。后期会不断的更新优化，进一步的完善。敬请期待&hellip;</p>

<p>点击此处下载本文的Demo:<a href = 'https://github.com/yangshebing/BGWaterFlowView'><strong>BGWaterFlowView</strong></a></p>

<p>Demo使用方式详见:<a href = "https://github.com/yangshebing/BGWaterFlowView/blob/master/README.md"><strong>README.md</strong></a></p>

<p>Demo运行瀑布流效果截图如下所示:</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey0z6x4xf9j20ku12aqb5.jpg"/ width = "375" height = "677" align = "center"></p>

<h6>参考博客地址：</h6>

<ul>
<li><a href = "http://objccn.io/issue-3-3/">自定义 Collection View 布局</a></li>
</ul>


<p>转载请注明出处</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS绘制虚线方式总结]]></title>
    <link href="http://yangshebing.github.io/blog/2015/10/12/ioshui-zhi-xu-xian-fang-shi-zong-jie/"/>
    <updated>2015-10-12T23:44:28+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/10/12/ioshui-zhi-xu-xian-fang-shi-zong-jie</id>
    <content type="html"><![CDATA[<h3>一、iOS中绘制虚线常见的几种方式：</h3>

<p>1、重写drawRect方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)drawRect:(CGRect)rect
</span><span class='line'>{
</span><span class='line'>    [super drawRect:rect];
</span><span class='line'>CGContextRef currentContext = UIGraphicsGetCurrentContext();
</span><span class='line'>//设置虚线颜色
</span><span class='line'>    CGContextSetStrokeColorWithColor(currentContext, [UIColor BlackColor].CGColor);
</span><span class='line'>    //设置虚线宽度
</span><span class='line'>    CGContextSetLineWidth(currentContext, 1);
</span><span class='line'>    //设置虚线绘制起点
</span><span class='line'>    CGContextMoveToPoint(currentContext, 0, 0);
</span><span class='line'>    //设置虚线绘制终点
</span><span class='line'>    CGContextAddLineToPoint(currentContext, self.frame.origin.x + self.frame.size.width, 0);
</span><span class='line'>    //设置虚线排列的宽度间隔:下面的arr中的数字表示先绘制3个点再绘制1个点
</span><span class='line'>    CGFloat arr[] = {3,1};
</span><span class='line'>    //下面最后一个参数“2”代表排列的个数。
</span><span class='line'>    CGContextSetLineDash(currentContext, 0, arr, 2);
</span><span class='line'>    CGContextDrawPath(currentContext, kCGPathStroke);
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>2、采用CAShapeLayer方式绘制虚线</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CAShapeLayer *shapeLayer = [CAShapeLayer layer];
</span><span class='line'>[shapeLayer setBounds:self.bounds];
</span><span class='line'>[shapeLayer setPosition:CGPointMake(self.frame.size.width / 2.0, self.frame.size.height)];
</span><span class='line'>[shapeLayer setFillColor:[UIColor clearColor].CGColor];
</span><span class='line'>//设置虚线颜色
</span><span class='line'>shapeLayer setStrokeColor:[UIColor BlackColor].CGColor];
</span><span class='line'>//设置虚线宽度
</span><span class='line'>[shapeLayer setLineWidth:self.frame.size.height];
</span><span class='line'>[shapeLayer setLineJoin:kCALineJoinRound];
</span><span class='line'>//设置虚线的线宽及间距
</span><span class='line'> [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:3], [NSNumber numberWithInt:1], nil]];
</span><span class='line'> //创建虚线绘制路径
</span><span class='line'> CGMutablePathRef path = CGPathCreateMutable();
</span><span class='line'> //设置虚线绘制路径起点
</span><span class='line'> CGPathMoveToPoint(path, NULL, 0, 0);
</span><span class='line'> //设置虚线绘制路径终点
</span><span class='line'> CGPathAddLineToPoint(path, NULL, self.frame.size.width, 0);
</span><span class='line'> //设置虚线绘制路径
</span><span class='line'> [shapeLayer setPath:path];
</span><span class='line'> CGPathRelease(path);
</span><span class='line'> //添加虚线
</span><span class='line'> [self.layer addSublayer:shapeLayer];
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<h5>关于这种方式已经有人整理出了一个非常好用的类方法，具体请参看文章末尾的参考博客地址：“iOS绘制虚线方法【原创】”一文，此方法使用起来非常简单方便。</h5>

<h6><strong><font color="red">注意：下面非完整代码，如有需要，请自行前往该博文中直接复制使用。</font></strong></h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> ** lineView:       需要绘制成虚线的view
</span><span class='line'> ** lineLength:     虚线的宽度
</span><span class='line'> ** lineSpacing:    虚线的间距
</span><span class='line'> ** lineColor:      虚线的颜色
</span><span class='line'> **/
</span><span class='line'> 
</span><span class='line'>+ (void)drawDashLine:(UIView *)lineView lineLength:(int)lineLength lineSpacing:(int)lineSpacing lineColor:(UIColor *)lineColor
</span><span class='line'>{
</span><span class='line'>    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
</span><span class='line'>    .....
</span><span class='line'>    [shapeLayer setStrokeColor:lineColor.CGColor];
</span><span class='line'>    ......
</span><span class='line'>    [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:lineLength], [NSNumber numberWithInt:lineSpacing], nil]];
</span><span class='line'>  　......
</span><span class='line'>    [lineView.layer addSublayer:shapeLayer];
</span><span class='line'>    
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>3、经济实惠型：采用贴图的方式绘制虚线（需要设计师切图配合）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIImageView *imgDashLineView =[[UIImageView alloc] initWithFrame:CGRectMake(15, 200, self.view.frame.size.width - 30, 1)];
</span><span class='line'>
</span><span class='line'>[imgDashLineView setBackgroundColor:[UIColor colorWithPatternImage:[UIImage imageNamed:@"xuxian.png"]]];
</span><span class='line'>
</span><span class='line'>[self.view addSubview:imgDashLineView];
</span></code></pre></td></tr></table></div></figure>


<p>在以上这几种方式中我个人比较偏爱最后一种，简单粗暴。</p>

<p>以上内容部分来自于网络，本着分享的学习精神，如有涉及侵权问题，请及时告知。欢迎一起探讨学习，有问题请留言。我将会在第一时间对你的问题进行回复。如需转载，请注明出处。</p>

<h6>参考博客地址：</h6>

<ul>
<li>1、<a href="http://blog.it985.com/14080.html">iOS绘制虚线方法【原创】</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于GitHub搭建Octopress个人技术博客(Mac版)]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/17/test/"/>
    <updated>2015-09-17T23:42:42+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/17/test</id>
    <content type="html"><![CDATA[<h6>作为一名屌逼的程序猿，肯定是要有一个屌逼的技术博客。在交流学习的同时，顺便见证自己成长的心路历程。废话不多说，直接进入正题。编程讲究的四门功课，“说，学，逗，唱”。不会就学嘛！没有就找嘛！网上相关的文章简直太多了！其中原理就不多说，我且按照我搭建的顺序写一下步骤吧！</h6>

<p><strong>注意事项：在搭建之前，检查MAC电脑是否已经安装了Git和Ruby 1.9.3及以上版本。（Mac默认均已自带，ruby请自行检查版本：ruby &ndash;version，如果缺少，当自行下载）</strong></p>

<h4>一、开始安装octopress</h4>

<!--more-->


<p>1、将Octopress从github上clone到本地</p>

<pre><code class="`">git clone git://github.com/imathis/octopress.git octopress
cd octopress
</code></pre>

<p>2、安装Octopress</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem install bundler
</span><span class='line'>bundle install
</span><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>


<p>如果当你执行“bundle install”这步失败了，请更改一下本地octopress文件夹下Gemfile文件当中的源（路径：/Users/用户名/octopress/Gemfile），将文件中的<code>source "https://rubygems.org"</code>更换成 <code>source "http://ruby.taobao.org/"</code>,然后保存文件再重新执行bundle install及其后续操作。</p>

<p>3、部署GitHub Pages
在CitHub中新建一个名为username.github.io的仓库（username为你的GitHub用户名）。</p>

<ul>
<li>开始配置GitHub Pages</li>
</ul>


<p>在终端继续输入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages</span></code></pre></td></tr></table></div></figure>


<p>在Repository url后面粘贴username.github.io仓库对应的url地址</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Enter the read/write url for your repository
</span><span class='line'>(For example, 'git@github.com:your_username/your_username.github.io.git)
</span><span class='line'>           or 'https://github.com/your_username/your_username.github.io')
</span><span class='line'>Repository url: </span></code></pre></td></tr></table></div></figure>


<p>把上面代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>https://github.com/your_username/your_username.github.io”
</span><span class='line'>或者
</span><span class='line'>“git@github.com:your_username/your_username.github.io.git</span></code></pre></td></tr></table></div></figure>


<p>中的your_username替换成自己GitHub用户名即可。（两种地址，前者是HTTPS地址，后者是SSH地址，任选一个粘贴即可）</p>

<p>现在可以开始生成自己的第一篇博客并部署放至GitHub上。
在终端输入以下命令：生成一篇新的博客</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post['test']</span></code></pre></td></tr></table></div></figure>


<p>其中test是默认的博客标题（当然博客的标题可以在markdown文件里面更改）。当然你也可以输入rake new_post命令，按照终端的提示输入博客的标题。生成完成的文章内容在octopress/source/_posts目录下。文件名为时间＋标题名，如“2015-09-17-test.markdown”。可以用markdown工具（本文用的markdown工具为“Mou”）进行编辑与修改。</p>

<p>接下来在终端输入rake generate命令生成静态文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate</span></code></pre></td></tr></table></div></figure>


<p>在部署到GitHub上之前，你可以在本地预览一下博客的效果。
先在终端输入rake preview命令，生成预览blog。然后在浏览器中输入<code>http://localhost:4000</code>查看博客的预览效果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake preview</span></code></pre></td></tr></table></div></figure>


<p>在终端退出预览效果：ctrl+c</p>

<p>确认效果之后，开始部署至GitHub。rake deploy命令会将octopress/public目录下的文件上传至仓库的master分支。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<p>最后一步，将Octopress的源码提交至GitHub</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m 'commit source file'
</span><span class='line'>git push origin source</span></code></pre></td></tr></table></div></figure>


<p>完工，屌逼的第一篇博客就已经发布到GitHub Pages上了。你现在可以输入:username.github.io在线查看自己的博客了（如：yangshebing.github.io）。</p>

<p>至于其中的相关原理分析我就不一一赘述了。请参看文章末尾的参考文章链接或者自行网上搜索。</p>

<h4>二、简单的配置Octopress</h4>

<h6>1、修改Octopress的配置文件（路径：octopress/_config.yml）</h6>

<ul>
<li>设置博客的标题，子标题以及作者相关信息。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>title: 杨社兵的技术博客
</span><span class='line'>subtitle: 业精于勤荒于嬉，行成于思毁于随.
</span><span class='line'>author: 杨社兵</span></code></pre></td></tr></table></div></figure>


<ul>
<li>删除twitter相关信息（GFW造成页面加载慢）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Twitter
</span><span class='line'>twitter_user:
</span><span class='line'>twitter_tweet_button: true</span></code></pre></td></tr></table></div></figure>


<ul>
<li>修改source/_includes目录下的head.html文件：将<code>//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.jst</code>替换成<code>http://cdn.staticfile.org/jquery/1.9.1/jquery.min.jst</code>（解决页面加载过慢问题）</li>
<li>修改source/_includes/custom目录下的自定义head.html文件，去掉google自定义字体（解决页面加载过慢问题）</li>
</ul>


<h6>2、添加统计工具（百度统计）</h6>

<p>去<a href="http://tongji.baidu.com">百度统计</a>官网申请一个账号，在管理界面选择“代码获取”，复制代码至<code>source/_includes/custom/footer.html</code>文件中。</p>

<h6>3、自定义博客导航栏</h6>

<p>部署好博客之后，你会发现导航栏上默认的只有两项：Blog、Archives，无法满足我们的需求。比如我们想在导航栏上添加一个选项为“关于我”。</p>

<p>打开“/source/_includes/custom”目录的navigation.html文件进行编辑：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*&lt;ul class="main-navigation"&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://yangshebing.github.io/"&gt;我的博客&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://yangshebing.github.io/blog/archives"&gt;所有文章&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://weibo.com/yangshebing" target="_blank"&gt;新浪微博&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://yangshebing.github.io/about"&gt;关于我&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span></code></pre></td></tr></table></div></figure>


<p>接下来在终端输入rake new_page命令，生成一个index.markdown文件，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_page['about']</span></code></pre></td></tr></table></div></figure>


<p>它的默认保存路径是：“source/about/index.markdown”，编辑index.markdown文件，即可定制“关于我”页面内容。</p>

<h6>4、关于博客的评论和分享到微博功能，请参考末尾文章链接《象写程序一样写博客：搭建基于github的博客》一文。</h6>

<p>参考文章链接：</p>

<p>（1）<a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/" target="_blank">象写程序一样写博客：搭建基于github的博客</a></p>

<p>（2）<a href="http://matrixzk.github.io/blog/20141020/octopress-setup-and-analysis/#section" target="_blank">使用 Octopress 2.0 搭建基于 Github Pages 个人博客的详细过程及原理分析</a></p>

<p>（3）<a href="http://www.jianshu.com/p/0ac2ac1a8e45" target="_blank">octopress博客搭建和个性化配置</a></p>

<p>（4）<a href="https://liuchungui.github.io/blog/2015/09/11/macdian-nao-shang-da-jian-octopressbo-ke/" target="_blank">Mac电脑上搭建octopress博客</a></p>

<p>（5）<a href="http://www.cnblogs.com/sawyerzhu/p/3710374.html" target="_blank">Mac环境下octopress个人博客搭建</a></p>

<p>（6）<a href="http://foggry.com/blog/2014/04/28/custom-your-octopress-blog/" target="_blank">自定义你的Octopress博客</a></p>

<p>（7）<a href="http://blog.devtang.com/blog/2014/06/02/use-gitcafe-to-host-blog/" target="_blank">将博客从GitHub迁移到GitCafe</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中点击状态栏让滑动视图回到顶部]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/13/arcticle/"/>
    <updated>2015-09-13T23:28:31+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/13/arcticle</id>
    <content type="html"><![CDATA[<h6>在产品开发过程中，有时候会有这种需求，需要点击状态栏让滑动视图（UIScrollView）或者表视图（UITableView）返回到顶部，让用户可以更快的浏览最新的信息。</h6>

<h6>这个时候我们需要设置滑动视图的scrollsToTop属性，让它决定点击状态栏是否返回顶部。</h6>

<!--more-->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// When the user taps the status bar, 
</span><span class='line'>the scroll view beneath the touch which is closest to the status bar will be scrolled to top,
</span><span class='line'> but only if its scrollsToTop property is YES, 
</span><span class='line'> its delegate does not return NO from shouldScrollViewScrollToTop,
</span><span class='line'>  and it is not already at the top. 
</span><span class='line'>// On iPhone, we execute this gesture only if there’s one on-screen scroll view with scrollsToTop == YES.
</span><span class='line'> If more than one is found, none will be scrolled.
</span><span class='line'>@property(nonatomic) BOOL scrollsToTop; // default is YES.</span></code></pre></td></tr></table></div></figure>


<h6>设置这个属性，可以让点击状态栏不返回顶部。如果我们需要让它点击状态栏回到顶部，我们可以把这个属性值设置为YES（默认为YES）。按正常情况来说，这个时候点击状态栏是可以返回到顶部。但是点击状态栏还是没有反应怎么办？</h6>

<h6>解决方法如下：</h6>

<h6>按照上面官方文档的说法，只有把当前主控制器需要设置的那个scrollview找到并把它的scrollsToTop属性设置为YES，然后再把其他scrollview的scrollsToTop属性设置为NO 。这样它才会响应这个事件。其中的原理非常简单，如果当前主控制器中有2个scrollview，系统压根就不知道你想要其中的哪个scrollview滑动到顶部。</h6>

<h6>举个栗子：</h6>

<ul>
<li>假设当前控制器中有三个表视图（UITableView）或者滑动视图(UIScrollView)要切换，把当前显示的滑动视图scrollsToTop属性设置为YES,其他滑动视图的scrollsToTop属性设置为NO即可。</li>
</ul>


<p><strong>注意：如果当前滑动视图中存在子视图也是滑动视图的情况，那么它子视图中的滑动视图scrollsToTop属性也要设置为NO，不然它仍然会造成点击状态栏无法响应返回到顶部操作。</strong></p>

<h6>参考博客地址：</h6>

<ul>
<li><a href="http://blog.sina.com.cn/s/blog_463dc5b90101k9ib.html">点击状态栏不返回顶部问题</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift语言编程]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/12/swift/"/>
    <updated>2015-09-12T12:53:21+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/12/swift</id>
    <content type="html"><![CDATA[<h4>Swift语言基础学习</h4>

<ul>
<li>导入系统类库头文件（swift中称之为模块）</li>
</ul>


<p><code>
import UIKit
</code></p>

<ul>
<li>定义一个常量</li>
</ul>


<p><code>
let a = 5
</code></p>

<ul>
<li>定义一个变量</li>
</ul>


<p><code>
var str = "Hello, World!"
</code></p>

<ul>
<li>swift中打印输出</li>
</ul>


<p><code>
print("Hi,Girl!");
</code></p>

<p><strong>注意事项：如果在一行内想要写多条语句时需要用分号隔开，一行内写一句代码分号可加可不加（不推荐加）</strong></p>

<!--more-->


<p><code>
//一行内多句代码
let dog = "ddd";print(dog)
</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//一行内一句代码
</span><span class='line'>let my = "我的"
</span><span class='line'>let age = 20
</span><span class='line'>let sex = "male"
</span><span class='line'>print(my)
</span><span class='line'>print(age)
</span><span class='line'>print(sex)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>一次性定义多个变量</li>
</ul>


<p><code>
var a = 0.0, b = 0.0, c = 0.0
</code></p>

<ul>
<li>定义变量并赋初值</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var a : Float = 5;
</span><span class='line'>var userName = "yangshebing"</span></code></pre></td></tr></table></div></figure>


<ul>
<li>字符串插值方式：相当于占位符输出</li>
</ul>


<p><code>
print("the user name is \(userName)”)
</code></p>

<ul>
<li>定义一个指定类型的变量</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var name : String
</span><span class='line'>name = "yangshebing";
</span><span class='line'>print(name);</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：在Swift中支持多行注释嵌套</strong></p>

<ul>
<li>定义一个数组</li>
</ul>


<p>最简单粗暴的方法：</p>

<p><code>
let array = ["a", "b", "c"]
</code></p>

<p>常规写法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let array1: [String] = ["A", "B", "C"]
</span><span class='line'>let array2: Array&lt;String&gt; = ["A", "B", "D”]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>整数和浮点数之间转换</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let num = 3
</span><span class='line'>let pointNum = 0.14159
</span><span class='line'>let pi = Double(num) + pointNum
</span><span class='line'>let numPi = Int(pi)
</span><span class='line'>//Float转换成Int类型时，实型值总是会被缩短，意味着4.75将会变成4, -3.9将会变成-3
</span><span class='line'>print(numPi)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>自定义类型别名</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typealias MyIntType = Int
</span><span class='line'>let num : MyIntType = 10</span></code></pre></td></tr></table></div></figure>


<ul>
<li>布尔</li>
</ul>


<p>Swift 有一个基本布尔类型，称之为Bool。它提供了两个布尔常量值:true和false</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let isMore = true
</span><span class='line'>let isRainy = false</span></code></pre></td></tr></table></div></figure>


<ul>
<li>布尔类型在if语句中的使用</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let isApple = true
</span><span class='line'>if isApple {
</span><span class='line'>    println("this is Apple")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>使用布尔类型应当注意事项：Swift的类型安全机制会防止non-Boolean代替Bool值，比如下面的代码就会报编译时错误：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let num = 1
</span><span class='line'>if num {
</span><span class='line'>  //这个例子编译的时候会报错，但是在Objective-C语言中不会。
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>正确使用的方式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let number = 1
</span><span class='line'>if number == 1 {
</span><span class='line'>    println("this is one")
</span><span class='line'>    //这个编译成功
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>另外，这里提一下：在Swift中判断两个对象是否相等是使用”===“”!=="</p>

<ul>
<li>Swift中元组的使用</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//定义一个元组
</span><span class='line'>let salaryCombination = （10000, "one month"）
</span><span class='line'>//它代表的是一个（Int, String）类型的元组</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//分解元组
</span><span class='line'>let (salary, month) = salaryCombination
</span><span class='line'>print("The salary is \(salary)")
</span><span class='line'>print("The month is \(month)")
</span><span class='line'>//你如果只需要元组的一部分值，你也可以这样写
</span><span class='line'>let (salary,_)
</span><span class='line'>print(the salary is \(salary))</span></code></pre></td></tr></table></div></figure>


<ul>
<li>元组取值方式总结</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>方式一
</span><span class='line'>let firstSalary = (10000, "one month")
</span><span class='line'>let (salary1,month1) = firstSalary
</span><span class='line'>let secondSalary = (20000,"two month")
</span><span class='line'>let (salary2, month2) = secondSalary
</span><span class='line'>print("一月收入month1: \(salary1)")
</span><span class='line'>print("二月收入month2: \(salary2)”)
</span><span class='line'>
</span><span class='line'>//方式二
</span><span class='line'>let firstSalary = (10000, "one month")
</span><span class='line'>let (salary1,month1) = firstSalary
</span><span class='line'>let secondSalary = (20000,"two month")
</span><span class='line'>let (salary2, month2) = secondSalary
</span><span class='line'>//输出元组中的第0个元素， firstSalary.0：firstSalary代表元组名，0代表下标
</span><span class='line'>print("一月的收入month1: \(firstSalary.0)")
</span><span class='line'>print("二月的收入month2: \(secondSalary.0)”)
</span><span class='line'>
</span><span class='line'>//方式三
</span><span class='line'>let firstSalary = (salary : 10000,month : "one month")
</span><span class='line'>let (salary1,month1) = firstSalary
</span><span class='line'>let secondSalary = (salary :20000,month : "two month")
</span><span class='line'>let (salary2, month2) = secondSalary
</span><span class='line'>//输出元组中的第0个元素， firstSalary.salary：firstSalary代表元组名，salary代表元组元素的名字
</span><span class='line'>print("一月的收入month1: \(firstSalary.salary)")
</span><span class='line'>print("二月的收入month2: \(secondSalary.salary)")</span></code></pre></td></tr></table></div></figure>


<h4>本文参考文章资料：</h4>

<ul>
<li>《The Swift Programming Language》</li>
</ul>


<p><strong>欢迎共同学习进步，本着分享的精神，只是为了让你学习起来更加轻松。</strong></p>

<p><strong>如需转载，请注明出处</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态限制UITextField或UITextView用户输入中英文混编字数统计]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/12/test/"/>
    <updated>2015-09-12T11:31:37+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/12/test</id>
    <content type="html"><![CDATA[<p><strong>动态限制用户输入字数，这个在很多app中都会涉及，由于NSString的Length属性获取的长度中英文都是一个字节，不满足一个汉字两个字节、一个字符一个字节的需求。网上的方法大致是以下两种：</strong></p>

<h6>1、使用Unicode编码把OC中的NSString字符串转换成C的字符串。然后对字符串遍历进行统计长度。</h6>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>-  (int)convertToInt:(NSString*)strtemp {  
</span><span class='line'>    int strlength = 0;
</span><span class='line'>    char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding];
</span><span class='line'>    for (int i=0 ; i&lt;[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding];i++) {
</span><span class='line'>        if (*p) {
</span><span class='line'>            p++;
</span><span class='line'>            strlength++;
</span><span class='line'>        }
</span><span class='line'>        else {
</span><span class='line'>            p++;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return strlength;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h6>2、直接计算OC中的NSString字符串中单词的个数</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSInteger)countWordWithStr:(NSString *)s
</span><span class='line'>{
</span><span class='line'>    NSInteger i,n=[s length],l=0,a=0,b=0;
</span><span class='line'>    unichar c;
</span><span class='line'>    for(i=0;i&lt;n;i++){
</span><span class='line'>        c=[s characterAtIndex:i];
</span><span class='line'>        if(isblank(c)){
</span><span class='line'>            b++;
</span><span class='line'>        }else if(isascii(c)){
</span><span class='line'>            a++;
</span><span class='line'>        }else{
</span><span class='line'>            l++;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    if(a==0 && l==0) return 0;
</span><span class='line'>    return l+(NSInteger)ceilf((float)(a+b)/2.0);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>以上资料均为网上整理得来，仅供学习交流使用。有关于此类问题，欢迎在最下方留言一起探讨优化学习。</strong></p>

<h6>参考博客地址：</h6>

<ul>
<li>1、<a href="http://mobilesolutions.blog.163.com/blog/static/18922417620116133910181/">统计含中英文混编的NSString 字符串长度 </a></li>
<li>2、<a href="http://blog.csdn.net/toss156/article/details/8993270">【IOS】IOS开发常用函数</a></li>
<li>3、<a href="http://code.qtuba.com/article-60968.html">iOS - 推断输入字符串长度函数</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
