<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[杨社兵的技术博客]]></title>
  <link href="http://yangshebing.github.io/atom.xml" rel="self"/>
  <link href="http://yangshebing.github.io/"/>
  <updated>2015-11-16T23:27:02+08:00</updated>
  <id>http://yangshebing.github.io/</id>
  <author>
    <name><![CDATA[杨社兵]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS FFmpeg编译及kxmovie、iFrameExtractor调试详解（无障碍阅读，绝对是你想要的）]]></title>
    <link href="http://yangshebing.github.io/blog/2015/11/16/ios-ffmpegbian-yi-ji-kxmovie,-iframeextractordiao-shi-xiang-jie-(wu-zhang-ai-yue-du-,jue-dui-shi-ni-xiang-yao-de-)/"/>
    <updated>2015-11-16T01:44:27+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/11/16/ios-ffmpegbian-yi-ji-kxmovie,-iframeextractordiao-shi-xiang-jie-(wu-zhang-ai-yue-du-,jue-dui-shi-ni-xiang-yao-de-)</id>
    <content type="html"><![CDATA[<p><strong>特此声明：本文是通过网上收集整理加上自己亲自实验得来的。感谢所有网上分享的辛勤劳动者，本文仅供iOS学习使用。在学习的过程中，如果有问题或者不清楚的地方，欢迎留言，我们共同探讨互相学习。欢迎批评指正。</strong></p>

<p><strong>如需转载，请注明出处：<a href = "http://blog.csdn.net/yangshebing21/article/details/43986913"><a href="http://blog.csdn.net/yangshebing21/article/details/43986913">http://blog.csdn.net/yangshebing21/article/details/43986913</a></a></strong></p>

<h4>开发环境：最新 ffmpeg-2.5.4/iOS SDK8.1/Xcode6.1/OS X Yosemite版本10.10.2</h4>

<h3>一、编译ffmpeg库</h3>

<h4>编译调试ffmpeg库的步骤：</h4>

<p><strong>开发环境：ffmpeg-2.5.4/Xcode6.1</strong></p>

<p>（一）、下载ffmpeg源码：</p>

<p>请点击此链接<a href = "http://ffmpeg.org/download.html"><a href="http://ffmpeg.org/download.html">http://ffmpeg.org/download.html</a></a></p>

<p> <font color = "red"><b>注：我的ffmpeg-2.5.4是解压放至Desktop的</b></font></p>

<p>（二）、调试编译ffmpeg源码</p>

<p> 1、安装yasm:
 <!--more--></p>

<p> 方法一:</p>

<p> 在终端输入</p>

<pre><code class="`"> sudo curlhttp://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz &gt;yasm.tar.gz
</code></pre>

<p>方法二：</p>

<p>（1）Download yasm sourcecode from：
  <a href = "http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz"><a href="http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz">http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz</a></a></p>

<p>（2）Unpack tar xvzfyasm-1.2.0.tar.gz</p>

<p>（3）cd yasm-1.2.0</p>

<p>（4）Configure and build:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./configure && make -j 4 &&sudo make install</span></code></pre></td></tr></table></div></figure>


<p>2、下载pearl脚本文件：gas-preprocessor.pl：</p>

<p>下载地址： <a href = "https://github.com/libav/gas-preprocessor"><a href="https://github.com/libav/gas-preprocessor">https://github.com/libav/gas-preprocessor</a></a></p>

<p>（1）拷贝gas-preprocessor.pl文件到 /usr/bin 目录下。</p>

<p>如果找不到/usr/bin目录，直接使用”Finder—>前往—> 前往文件夹—>/usr/bin”或者使用快捷键“shift+command+G”前往文件夹，到指定目录下粘贴gas-preprocessor.pl文件</p>

<p>（2）修改gas-preprocessor.pl文件的读写权限，使用 chmod a+rwxgas-preprocessor.pl</p>

<p>用终端命令cd定位到 gas-preprocessor.pl文件夹下执行：<code>chmod a+rwxgas-preprocessor.pl</code>命令</p>

<p>3、下载build-shell.sh脚本文件：</p>

<p>下载地址：<a href = "https://github.com/kewlbear/FFmpeg-iOS-build-script"><a href="https://github.com/kewlbear/FFmpeg-iOS-build-script">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></a></p>

<p>（1）下载解压build-shell.sh文件</p>

<p>（2）定位至build-shell.sh文件夹执行build-shell.sh脚本文件</p>

<p>使用方式有4种，我们可以根据特定的使用环境来执行对应的脚本，一般我们就直接执行：<code>./build-ffmpeg.sh</code></p>

<ul>
<li>To build everything:</li>
</ul>


<p><strong><code>./build-ffmpeg.sh</code></strong></p>

<ul>
<li>To build arm64 libraries：</li>
</ul>


<p><strong><code>./build-ffmpeg.sh arm64</code></strong></p>

<ul>
<li>To build fat libraries for armv7 and x86_64 (64-bit simulator)：</li>
</ul>


<p><strong><code>./build-ffmpeg.sh armv7 x86_64</code></strong></p>

<ul>
<li>To build fat libraries from separately built thin libraries:</li>
</ul>


<p><strong><code>./build-ffmpeg.sh lipo</code></strong></p>

<p>注：我的build-shell.sh是解压放至Desktop的，以上四种shell脚本的使用方式来自<a href = "https://github.com/kewlbear/FFmpeg-iOS-build-script"><a href="https://github.com/kewlbear/FFmpeg-iOS-build-script">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></a>，后面几种方式大家可以自己去尝试。</p>

<p>4、脚本执行完成之后，会在桌面上生成三个文件夹：“FFmpeg-iOS”“scratch”和”thin”文件夹</p>

<p>scratch文件夹里面是单独编译的库，FFmpeg-iOS文件夹里面是合并编译的库。在使用的过程中，我们主要会用到FFmpeg-iOS 文件夹下的“include”文件夹和"lib"文件夹中的文件。</p>

<h3>二、在工程中使用FFmpeg，网上成熟的有kxmovie。</h3>

<p>1、下载kxmovie工程进行测试：</p>

<p>下载地址： <a href = "https://github.com/kolyvan/kxmovie"><a href="https://github.com/kolyvan/kxmovie">https://github.com/kolyvan/kxmovie</a></a></p>

<p>把FFmpeg编译出来的.a文件添加到工程中。</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37q81fp5j205r09xwfq.jpg" alt="" /></p>

<p>在使用的时候得注意添加下面的动态链接库文件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>libz.dylib
</span><span class='line'>libbz2.dylib
</span><span class='line'>libiconv.dylib</span></code></pre></td></tr></table></div></figure>


<p><strong>运行工程</strong></p>

<p>以下是在编译运行工程中可能会报的错误：</p>

<p>注意：如果在FFmpeg编译的时候出现“ffmpeg yasm not found，use &ndash;disable for a crippled build”，原因是 yasm是汇编编译器，因为FFmpeg中为了提高效率用到了汇编指令，解决这个问题有两种方法，一是下载一个yasm.exe安装在mingw/bin下面；二是不使用汇编指令，在配置上加上 即 ./configure &ndash;disable-yash 。(这就是为什么前面提到了要安装yasm)
成功通过编译（这里是指FFmpeg编译成静态库文件）</p>

<p>通过后会生成一个compiled(FFmpeg-iOS)的文件夹，里面有include和lib两个文件夹，这两个文件夹都要拷贝至工程目录下面。include是静态链接库要用到的头文件，lib是存放静态链接库的文件，然后把这些文件存放在项目里面即可，一定要把文件也copy进去，然后在项目的build settings中的header search paths字段加入include文件的路径 如：“$(SRCROOT)/ffmpeg/include” 前面的复选框选不选都可以；再在library search paths字段中加入a文件的路径 如：“$(SRCROOT)/ffmpeg/lib” 。否则可能会出现libavformat/avformat.h file not found 的错误。（出现这个错误是指编译kxmovie工程找不到相应的头文件）</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37rw3nknj20m207wwgg.jpg" alt="" /></p>

<p>上面图示：在工程目录下有个“FFmpeg”的文件夹，分别把编译FFmpeg完成后产生的“ FFmpeg-iOS ”文件夹中的“include”和”lib”文件夹拷贝至”FFmpeg”文件夹中，include文件夹中存放的是头文件，lib文件夹中存放的是.a静态库文件。最后就是在工程目录下的FFmpeg文件夹包含“include”和”lib”两个文件夹。设置Header Search Paths和Library Search Paths时直接include和lib两个文件夹拖上去，自动显示路径。</p>

<p><img src="http://ww4.sinaimg.cn/large/7f266405jw1ey37subv8hj20gu06omye.jpg" alt="" /></p>

<p>如果还出现找不到 avformat_open_input 的错误（我的没有出现过这个错误），说明你的ffmpeg还是太新了，之前的那个方法名已经改成了这个名字，把avformat_open_input改成av_open_input_file 就可以了。其他错误请自行谷歌或者留言，我们共同探讨。
上面报错总结文章来自：<a href="http://www.dnetzj.com/Content/267.html">http://www.dnetzj.com/Content/267.html</a></p>

<p>最后一步，别忘了安装kxmovie.xcworkspace的cocoapods</p>

<p><strong><code>pod install --verbose --no-repo-update</code></strong></p>

<p>否则会报链接错误</p>

<p>以上kxmovie工程编译调试完毕，模拟器真机都通过测试。目前没有进一步的去研究这个工程，发现播放的视频质量有点粗糙。有时间再做进一步的研究。</p>

<h3>三、iFrameExtractor-master（iFrameExtractor）工程编译和运行</h3>

<p>（1）运行iFrameExtractor-master工程，与上面kxmovie工程操作一样，把FFmpeg文件夹拷贝至工程目录下:
       (工程目录下本来是没有FFmpeg文件夹的)</p>

<p><img src="http://ww1.sinaimg.cn/large/7f266405jw1ey37tiypu8j20gx07b75s.jpg" alt="" /></p>

<p>iFrameExtractor-master下载地址：<a href="https://github.com/lajos/iFrameExtractor">https://github.com/lajos/iFrameExtractor</a></p>

<p>(2)设置好Header Search Paths和Library Search Paths</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37u3v6q5j20kj02x0ts.jpg" alt="" /></p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37v057v9j20kg07p40a.jpg" alt="" /></p>

<p>（3）最后还是会报链接错误：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Undefined symbols for architecture i386:
</span><span class='line'>"_iconv", referenced from:      
</span><span class='line'>    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)  
</span><span class='line'>"_iconv_close", referenced from:
</span><span class='line'>    _avcodec_open2 in libavcodec.a(utils.o)
</span><span class='line'>    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)
</span><span class='line'>"_iconv_open", referenced from:
</span><span class='line'>    _avcodec_open2 in libavcodec.a(utils.o)
</span><span class='line'>    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)
</span><span class='line'>ld: symbol(s) not found for architecture i386
</span><span class='line'>clang: error: linker command failed with exit code 1 (use -v to see invocation)</span></code></pre></td></tr></table></div></figure>


<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey37vhigjfj20fq0a8djf.jpg" alt="" /></p>

<p><strong>解决办法："TARGETS" - > &ldquo;BuildSettings&rdquo; - > &ldquo;Other Linker Flags&rdquo; 添加other Linker Flags 项：-liconv</strong></p>

<p><img src="http://ww1.sinaimg.cn/large/7f266405jw1ey37wvjqv1j20dl01s74f.jpg" alt="" /></p>

<p>此报错问题出自：<a href = "http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851"><a href="http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851">http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851</a></a></p>

<p>至此完成iFrameExtractor-master工程编译和运行</p>

<h3>本文参考文章资料：</h3>

<ul>
<li><a href = "http://blog.csdn.net/oqqQuZi1234567/article/details/43152689">iOS－－kxmovie之FFmpeg编译和使用</a></li>
<li><a href = "http://www.th7.cn/Program/Ruby/201502/385491.shtml">iOS ffmpeg kxmovie 编译 调试</a></li>
</ul>


<p><strong>欢迎共同学习进步，本着分享的精神，只是为了让你学习起来更加轻松。</strong></p>

<p><strong>如需转载，请注明出处：<a href = "http://blog.csdn.net/yangshebing21/article/details/43986913"><a href="http://blog.csdn.net/yangshebing21/article/details/43986913">http://blog.csdn.net/yangshebing21/article/details/43986913</a></a></strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UICollectionView（纯代码方式）实现带上下拉刷新的瀑布流式（WaterFlow）布局]]></title>
    <link href="http://yangshebing.github.io/blog/2015/11/03/waterflow/"/>
    <updated>2015-11-03T22:40:32+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/11/03/waterflow</id>
    <content type="html"><![CDATA[<p>瀑布流（WaterFlow）是项目开发过程中的常见布局，有关于瀑布流（WaterFlow）的实现方式：在UICollectionView未出现之前，瀑布流的实现多半是采用UIScrollView或是UITableView。对于我们这种用惯了表视图的人来说，UICollectionView倒略显陌生。有关于UICollectionView的介绍我就不一一赘述，因为一两句话也很难说清楚。网上有很多优秀的文章专门对其进行了一系列的解说，另有苹果官方文档可以查阅。本文主要是介绍如何采用纯代码的方式利用UICollectionView实现带上下拉刷新的瀑布流式（WaterFlow）布局。废话少说，直接入题。</p>

<!--more-->


<h4>一、UICollectionView集成上下拉刷新</h4>

<p>（1）简单的介绍UICollectionView</p>

<p>UICollectionView和UITableView很相似，如果你对表视图非常熟悉，上手的速度也会快很多。使用它时需要相应的设置DataSource（UICollectionViewDataSoure)数据源协议和Delegate（UICollectionViewDelegate)事件协议，并实现相应的协议方法。它与UITableView不同的地方是它有UICollectionViewLayout，可以通过它的子类来定制布局。系统默认的布局方式是UICollectionViewDelegateFlowLayout，实现相应的协议（UICollectionViewDelegateFlowLayout）方法，便可达到默认布局效果。</p>

<p>UICollectionViewCell与UITableViewCell的使用也差不多，一样的有ReuseIdentifier,可以复用。使用UICollectionViewCell时，需要先注册，然后再出列使用。至于注册并出列使用Cell的具体方式，请自行下载文章末尾的BGWaterFlowView或者自行Google。</p>

<p>（2）集成上下拉刷新方式</p>

<p>一般UITableView添加上下拉刷新的方式，是把下拉或者上拉刷新视图的UI放置UITableView的表头属性(tableHeaderView)或者表尾属性（tableFooterView）。但是，在UICollectionView中没有这两个属性。那么我们该如何来集成上下拉刷新呢？这就得说到
UICollectionView布局中的三种显示内容视图：Cells、Supplementary views、Decoration views。(关于这三种视图的介绍可以去官网查阅相关文档，上面有详细的解释)。我们一般是把上下拉刷新的UI放置在Supplementary views（官方解释：它能显示数据但是不同于Cells。不像Cell,Supplementary views是不能被用户选定的。相反，你可以用它去实现类似于给一个指定的section或者整个CollectionView添加页眉和页脚视图这样的功能）上面，其实，Supplementary views就和TableView的section头视图和尾视图差不多。但是用法却大不相同。在自定义瀑布流布局中一定要把它也计算进去，不然显示就会有异常。</p>

<ul>
<li><strong>注册头视图和尾视图单元格类型</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//注册头视图：kind代表Supplementary视图类型，UICollectionElementKindSectionHeader表示组头
</span><span class='line'>
</span><span class='line'>[self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"bGCollectionHeaderView"];
</span><span class='line'>
</span><span class='line'>//注册尾视图：UICollectionElementKindSectionHeader表示组尾
</span><span class='line'>
</span><span class='line'>    [self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"bGCollectionFooterView"];
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>实现自定义组视图viewForSupplementaryElementOfKind代理方法</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath {
</span><span class='line'>
</span><span class='line'>  //kind代表Supplementary视图类型：头或尾视图（header OR footer）
</span><span class='line'>  
</span><span class='line'>    if([kind isEqual:UICollectionElementKindSectionHeader]) {
</span><span class='line'>        UICollectionReusableView *collectionHeaderView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"bGCollectionHeaderView" forIndexPath:indexPath];
</span><span class='line'>        
</span><span class='line'>        //初始化下拉刷新或者自定义页眉视图UI界面
</span><span class='line'>        ...
</span><span class='line'>        
</span><span class='line'>        return collectionHeaderView;
</span><span class='line'>    } else if([kind isEqual:UICollectionElementKindSectionFooter]) {
</span><span class='line'>        UICollectionReusableView *collectionFooterView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"bGCollectionFooterView" forIndexPath:indexPath];
</span><span class='line'>        
</span><span class='line'>        //初始化上拉刷新或者自定义页脚视图UI界面
</span><span class='line'>        ...
</span><span class='line'>        
</span><span class='line'>        return collectionFooterView;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return nil;
</span><span class='line'>}
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<p>完成以上两步，集成上下拉刷新的功能总算完成了。接下来你可以运行一下工程，看结果是否符合预期。如果你CollectionView使用的是系统的UICollectionViewFlowLayout布局，一定要返回组头或者组尾的高度，否则就会出现组头或者组尾无法显示（本文的下拉刷新视图所在的组头不返回高度不受影响，是因为它的纵坐标（y值）本来就是负数）。另外，还有一点需要注意的是，如果你的CollectionView中存在多组，最好是把上下拉刷新所在的组头或者组尾与其他组（section）的组头或组尾分开，相应的需要多注册一个组头或者组尾视图，分情况进行判断(这部分如果还有问题，可以在文章末尾留言，我会及时回复)。</p>

<h4>二、自定义瀑布流（WaterFlow）式布局</h4>

<p>（1）简单的介绍UICollectionView布局形式</p>

<p>一般来讲，UICollectionView的布局形式分为两种：</p>

<ul>
<li><p>布局与内容独立，其布局不需要根据显示的单元格内容来计算。Cell的显示顺序与内容顺序一致。Cell排满一行则换至下一行继续排列。系统的UICollectionViewFlowLayout就是这样。</p></li>
<li><p>布局需要计算内容，本文的瀑布流Demo局部正是如此。UICollectionViewFlowLayout系统布局在换行的时候，由于每个item高度不同，从而导致布局错乱，无法满足你的需求。所以，这个时候你需要计算每个item的高度，最终用来确定item显示的位置。</p></li>
</ul>


<p>从上述内容我们可以看出，一般如果布局需要计算内容的时候，我们就不应该直接使用UICollectionViewFlowLayout布局了，而是应该子类化一个UICollectionViewLayout，从而达到私人定制的目的。</p>

<p>（2）创建自定义布局</p>

<p><a href = "https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/CreatingCustomLayouts/CreatingCustomLayouts.html#//apple_ref/doc/uid/TP40012334-CH5-SW1">官方文档</a>中有提到，在布局的过程中，CollectionView会调用布局对象的具体方法。这些方法有机会使你计算这些项的位置以及给CollectionView提供它所需要的主要信息。其他的方法也有可能会被调用，但是在布局的过程中这些方法总是会按照以下的顺序调用：</p>

<ol>
<li>使用"prepareLayout"方法去执行一些CollectionView所需要的布局信息的预先计算操作。</li>
<li>使用"collectionViewContentSize"方法去返回根据你最初计算的整个内容区域的总体大小。</li>
<li>使用"layoutAttributesForElementsInRect:&ldquo;方法来返回指定区域的单元格与视图属性。</li>
</ol>


<p>下面我们通过Demo来详细的讲解一下如何自定义瀑布流，废话不多说，直接上代码（本文采用的Demo为<strong>BGWaterFlowView</strong>,<strong>GitHub传送门</strong>：<a href = 'https://github.com/yangshebing/BGWaterFlowView'>请点击这里</a>）：</p>

<ul>
<li><strong>重写"prepareLayout"方法计算布局信息。</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)prepareLayout{
</span><span class='line'>    [super prepareLayout];
</span><span class='line'>    ...
</span><span class='line'>    
</span><span class='line'>    //计算每个显示项的宽度，horizontalItemSpacing代表项与项之间的水平间隔， 
</span><span class='line'>    columnNum代表总列数，contentInset代表上下左右的内填充。详见下图说明
</span><span class='line'>    
</span><span class='line'>    self.itemWidth = (self.collectionView.frame.size.width - (self.horizontalItemSpacing * (self.columnNum - 1)) - self.contentInset.left - self.contentInset.right) / self.columnNum;
</span><span class='line'>    
</span><span class='line'>    //如有下拉刷新需求的则需要提供头视图（Supplementary view）布局属性。
</span><span class='line'>    demo中的headerHeight属性可设置是否显示头视图（是否计算头视图的布局属性）。
</span><span class='line'>    
</span><span class='line'>    if(self.headerHeight &gt; 0){
</span><span class='line'>    
</span><span class='line'>    //通过layoutAttributesForSupplementaryViewOfKind:withIndexPath:方法来创建Supplementary视图布局属性对象，kind用来区分Supplementary视图类型（header或者footer）。
</span><span class='line'>    
</span><span class='line'>        self.headerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionHeader withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];
</span><span class='line'>        
</span><span class='line'>        //修改布局参数frame属性
</span><span class='line'>        
</span><span class='line'>        self.headerLayoutAttributes.frame = CGRectMake(0, 0, self.collectionView.frame.size.width, self.headerHeight);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //初始化保存布局属性的字典
</span><span class='line'>    NSMutableDictionary *cellLayoutInfoDic = [NSMutableDictionary dictionary];
</span><span class='line'>    //初始化列高数组
</span><span class='line'>    NSMutableArray *columnInfoArray = [self columnInfoArray];
</span><span class='line'>    NSInteger numSections = [self.collectionView numberOfSections];
</span><span class='line'>    for(NSInteger section = 0; section &lt; numSections; section++)  {
</span><span class='line'>        NSInteger numItems = [self.collectionView numberOfItemsInSection:section];
</span><span class='line'>        for(NSInteger item = 0; item &lt; numItems; item++){
</span><span class='line'>            //获取列高最小的model，以它的高作为y坐标
</span><span class='line'>            BGWaterFlowModel *firstModel = columnInfoArray.firstObject;
</span><span class='line'>            CGFloat y = firstModel.height;
</span><span class='line'>            CGFloat x = self.contentInset.left + (self.horizontalItemSpacing + self.itemWidth) * firstModel.column;
</span><span class='line'>            
</span><span class='line'>            NSIndexPath *indexPath = [NSIndexPath indexPathForItem:item inSection:section];
</span><span class='line'>            
</span><span class='line'>            //通过代理方法传入对应item的高度。
</span><span class='line'>            
</span><span class='line'>            CGFloat itemHeight = [((id&lt;BGWaterFlowLayoutDelegate&gt;)self.collectionView.delegate) collectionView:self.collectionView layout:self heightForItemAtIndexPath:indexPath];
</span><span class='line'>            
</span><span class='line'>            //通过layoutAttributesForCellWithIndexPath:方法来创建cell的布局属性对象。
</span><span class='line'>            
</span><span class='line'>            UICollectionViewLayoutAttributes *itemAttributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];
</span><span class='line'>            //计算item的布局属性
</span><span class='line'>            itemAttributes.frame = CGRectMake(x, y+self.contentInset.top+self.headerHeight, self.itemWidth, itemHeight);
</span><span class='line'>            //计算当前列高,verticalItemSpacing代表项与项之间的垂直间隔。
</span><span class='line'>            firstModel.height += (itemHeight + self.verticalItemSpacing);
</span><span class='line'>            //保存新的列高，并进行排序：从后往前查找，查找到高度比它小的对象，就插入到该对象之后。
</span><span class='line'>            [self sortArrayByHeight:columnInfoArray];
</span><span class='line'>            
</span><span class='line'>     //保存计算好的item布局属性
</span><span class='line'>     cellLayoutInfoDic[indexPath] = itemAttributes;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //保存局部布局属性字典到全局字典中
</span><span class='line'>    self.cellLayoutInfoDic = [cellLayoutInfoDic copy];
</span><span class='line'>    
</span><span class='line'>    //按照前面的排序逻辑，列高数组中的最后一个元素，就是高度最大的一列。
</span><span class='line'>    BGWaterFlowModel *lastModel = columnInfoArray.lastObject;
</span><span class='line'>    
</span><span class='line'>    //如有上拉刷新需求的则需要提供尾视图布局属性。
</span><span class='line'>    demo中的footerHeight属性可设置是否显示尾视图（是否计算尾视图的布局属性）。
</span><span class='line'>    
</span><span class='line'>    if(self.footerHeight &gt; 0){
</span><span class='line'>        self.footerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionFooter withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];
</span><span class='line'>        //计算尾视图的布局属性
</span><span class='line'>        self.footerLayoutAttributes.frame = CGRectMake(0, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom, self.collectionView.frame.size.width, self.footerHeight);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //直接计算出collectionView的contentSize
</span><span class='line'>    self.contentSize = CGSizeMake(self.collectionView.frame.size.width, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom+self.footerHeight);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p><strong>好吧，这么一大坨代码看到就头疼了，来张图帮助理解一下！图糙理不糙，理解万岁</strong>
<img src="http://ww4.sinaimg.cn/mw690/7f266405jw1ey25ujzticj218a0xmjww.jpg" alt="" /></p>

<p><strong>这样看上去是不是更清晰了？</strong></p>

<ul>
<li><strong>重写"collectionViewContentSize"方法返回collectionView的内容高度。</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (CGSize)collectionViewContentSize{
</span><span class='line'>  //返回计算好的collectionView内容高度
</span><span class='line'>    return self.contentSize;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>重写"layoutAttributesForElementsInRect"方法返回指定矩形区域中的cell或者其他类型视图布局属性。</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect {
</span><span class='line'>
</span><span class='line'>  //返回一组已经计算好的布局属性。
</span><span class='line'>  
</span><span class='line'>    NSMutableArray *attributesArrs = [NSMutableArray array];
</span><span class='line'>    [self.cellLayoutInfoDic enumerateKeysAndObjectsUsingBlock:^(NSIndexPath *indexPath,
</span><span class='line'>                                                                UICollectionViewLayoutAttributes *attributes,
</span><span class='line'>                                                                BOOL *stop) { 
</span><span class='line'>        //遍历布局属性保存字典，添加布局属性至数组中                                                       
</span><span class='line'>        if (CGRectIntersectsRect(rect, attributes.frame)) {
</span><span class='line'>            [attributesArrs addObject:attributes];
</span><span class='line'>        }
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    //如果有头视图或者尾视图则需要添加头视图与尾视图的布局属性
</span><span class='line'>    
</span><span class='line'>    if (self.headerLayoutAttributes && CGRectIntersectsRect(rect, self.headerLayoutAttributes.frame)) {
</span><span class='line'>        [attributesArrs addObject:self.headerLayoutAttributes];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    
</span><span class='line'>    if (self.footerLayoutAttributes && CGRectIntersectsRect(rect, self.footerLayoutAttributes.frame)) {
</span><span class='line'>        [attributesArrs addObject:self.footerLayoutAttributes];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return attributesArrs;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>结语：</h4>

<p><a href = "https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/index.html#//apple_ref/occ/cl/UICollectionViewLayout">UICollectionViewLayout</a>相关的内容姿势非常多，相关文章也非常多。本文介绍的瀑布流布局也只是其中的冰山一角，很多东西官方文档中已经介绍的非常详细了。所以，还是建议多看官方文档。本文主要注重项目的实用性，在后面就直接上代码了，可能在理论方面还是有所欠缺，对于不足的地方，希望大家多提建议，一起交流学习，一起进步。如果文中有看不懂的地方，还请您留言。我会及时进行回复。最后，本文的Demo就在于方便徒手撸代码的人使用。你懂的。后期会不断的更新优化，进一步的完善。敬请期待&hellip;</p>

<p>点击此处下载本文的Demo:<a href = 'https://github.com/yangshebing/BGWaterFlowView'><strong>BGWaterFlowView</strong></a></p>

<p>Demo使用方式详见:<a href = "https://github.com/yangshebing/BGWaterFlowView/blob/master/README.md"><strong>README.md</strong></a></p>

<p>Demo运行瀑布流效果截图如下所示:</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey0z6x4xf9j20ku12aqb5.jpg"/ width = "375" height = "677" align = "center"></p>

<h6>参考博客地址：</h6>

<ul>
<li><a href = "http://objccn.io/issue-3-3/">自定义 Collection View 布局</a></li>
</ul>


<p>转载请注明出处</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS绘制虚线方式总结]]></title>
    <link href="http://yangshebing.github.io/blog/2015/10/12/ioshui-zhi-xu-xian-fang-shi-zong-jie/"/>
    <updated>2015-10-12T23:44:28+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/10/12/ioshui-zhi-xu-xian-fang-shi-zong-jie</id>
    <content type="html"><![CDATA[<h3>一、iOS中绘制虚线常见的几种方式：</h3>

<p>1、重写drawRect方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)drawRect:(CGRect)rect
</span><span class='line'>{
</span><span class='line'>    [super drawRect:rect];
</span><span class='line'>CGContextRef currentContext = UIGraphicsGetCurrentContext();
</span><span class='line'>//设置虚线颜色
</span><span class='line'>    CGContextSetStrokeColorWithColor(currentContext, [UIColor BlackColor].CGColor);
</span><span class='line'>    //设置虚线宽度
</span><span class='line'>    CGContextSetLineWidth(currentContext, 1);
</span><span class='line'>    //设置虚线绘制起点
</span><span class='line'>    CGContextMoveToPoint(currentContext, 0, 0);
</span><span class='line'>    //设置虚线绘制终点
</span><span class='line'>    CGContextAddLineToPoint(currentContext, self.frame.origin.x + self.frame.size.width, 0);
</span><span class='line'>    //设置虚线排列的宽度间隔:下面的arr中的数字表示先绘制3个点再绘制1个点
</span><span class='line'>    CGFloat arr[] = {3,1};
</span><span class='line'>    //下面最后一个参数“2”代表排列的个数。
</span><span class='line'>    CGContextSetLineDash(currentContext, 0, arr, 2);
</span><span class='line'>    CGContextDrawPath(currentContext, kCGPathStroke);
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>2、采用CAShapeLayer方式绘制虚线</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CAShapeLayer *shapeLayer = [CAShapeLayer layer];
</span><span class='line'>[shapeLayer setBounds:self.bounds];
</span><span class='line'>[shapeLayer setPosition:CGPointMake(self.frame.size.width / 2.0, self.frame.size.height)];
</span><span class='line'>[shapeLayer setFillColor:[UIColor clearColor].CGColor];
</span><span class='line'>//设置虚线颜色
</span><span class='line'>shapeLayer setStrokeColor:[UIColor BlackColor].CGColor];
</span><span class='line'>//设置虚线宽度
</span><span class='line'>[shapeLayer setLineWidth:self.frame.size.height];
</span><span class='line'>[shapeLayer setLineJoin:kCALineJoinRound];
</span><span class='line'>//设置虚线的线宽及间距
</span><span class='line'> [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:3], [NSNumber numberWithInt:1], nil]];
</span><span class='line'> //创建虚线绘制路径
</span><span class='line'> CGMutablePathRef path = CGPathCreateMutable();
</span><span class='line'> //设置虚线绘制路径起点
</span><span class='line'> CGPathMoveToPoint(path, NULL, 0, 0);
</span><span class='line'> //设置虚线绘制路径终点
</span><span class='line'> CGPathAddLineToPoint(path, NULL, self.frame.size.width, 0);
</span><span class='line'> //设置虚线绘制路径
</span><span class='line'> [shapeLayer setPath:path];
</span><span class='line'> CGPathRelease(path);
</span><span class='line'> //添加虚线
</span><span class='line'> [self.layer addSublayer:shapeLayer];
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<h5>关于这种方式已经有人整理出了一个非常好用的类方法，具体请参看文章末尾的参考博客地址：“iOS绘制虚线方法【原创】”一文，此方法使用起来非常简单方便。</h5>

<h6><strong><font color="red">注意：下面非完整代码，如有需要，请自行前往该博文中直接复制使用。</font></strong></h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> ** lineView:       需要绘制成虚线的view
</span><span class='line'> ** lineLength:     虚线的宽度
</span><span class='line'> ** lineSpacing:    虚线的间距
</span><span class='line'> ** lineColor:      虚线的颜色
</span><span class='line'> **/
</span><span class='line'> 
</span><span class='line'>+ (void)drawDashLine:(UIView *)lineView lineLength:(int)lineLength lineSpacing:(int)lineSpacing lineColor:(UIColor *)lineColor
</span><span class='line'>{
</span><span class='line'>    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
</span><span class='line'>    .....
</span><span class='line'>    [shapeLayer setStrokeColor:lineColor.CGColor];
</span><span class='line'>    ......
</span><span class='line'>    [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:lineLength], [NSNumber numberWithInt:lineSpacing], nil]];
</span><span class='line'>  　......
</span><span class='line'>    [lineView.layer addSublayer:shapeLayer];
</span><span class='line'>    
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>3、经济实惠型：采用贴图的方式绘制虚线（需要设计师切图配合）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIImageView *imgDashLineView =[[UIImageView alloc] initWithFrame:CGRectMake(15, 200, self.view.frame.size.width - 30, 1)];
</span><span class='line'>
</span><span class='line'>[imgDashLineView setBackgroundColor:[UIColor colorWithPatternImage:[UIImage imageNamed:@"xuxian.png"]]];
</span><span class='line'>
</span><span class='line'>[self.view addSubview:imgDashLineView];
</span></code></pre></td></tr></table></div></figure>


<p>在以上这几种方式中我个人比较偏爱最后一种，简单粗暴。</p>

<p>以上内容部分来自于网络，本着分享的学习精神，如有涉及侵权问题，请及时告知。欢迎一起探讨学习，有问题请留言。我将会在第一时间对你的问题进行回复。如需转载，请注明出处。</p>

<h6>参考博客地址：</h6>

<ul>
<li>1、<a href="http://blog.it985.com/14080.html">iOS绘制虚线方法【原创】</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于GitHub搭建Octopress个人技术博客(Mac版)]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/17/test/"/>
    <updated>2015-09-17T23:42:42+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/17/test</id>
    <content type="html"><![CDATA[<h6>作为一名屌逼的程序猿，肯定是要有一个屌逼的技术博客。在交流学习的同时，顺便见证自己成长的心路历程。废话不多说，直接进入正题。编程讲究的四门功课，“说，学，逗，唱”。不会就学嘛！没有就找嘛！网上相关的文章简直太多了！其中原理就不多说，我且按照我搭建的顺序写一下步骤吧！</h6>

<p><strong>注意事项：在搭建之前，检查MAC电脑是否已经安装了Git和Ruby 1.9.3及以上版本。（Mac默认均已自带，ruby请自行检查版本：ruby &ndash;version，如果缺少，当自行下载）</strong></p>

<h4>一、开始安装octopress</h4>

<!--more-->


<p>1、将Octopress从github上clone到本地</p>

<pre><code class="`">git clone git://github.com/imathis/octopress.git octopress
cd octopress
</code></pre>

<p>2、安装Octopress</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem install bundler
</span><span class='line'>bundle install
</span><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>


<p>如果当你执行“bundle install”这步失败了，请更改一下本地octopress文件夹下Gemfile文件当中的源（路径：/Users/用户名/octopress/Gemfile），将文件中的<code>source "https://rubygems.org"</code>更换成 <code>source "http://ruby.taobao.org/"</code>,然后保存文件再重新执行bundle install及其后续操作。</p>

<p>3、部署GitHub Pages
在CitHub中新建一个名为username.github.io的仓库（username为你的GitHub用户名）。</p>

<ul>
<li>开始配置GitHub Pages</li>
</ul>


<p>在终端继续输入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages</span></code></pre></td></tr></table></div></figure>


<p>在Repository url后面粘贴username.github.io仓库对应的url地址</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Enter the read/write url for your repository
</span><span class='line'>(For example, 'git@github.com:your_username/your_username.github.io.git)
</span><span class='line'>           or 'https://github.com/your_username/your_username.github.io')
</span><span class='line'>Repository url: </span></code></pre></td></tr></table></div></figure>


<p>把上面代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>https://github.com/your_username/your_username.github.io”
</span><span class='line'>或者
</span><span class='line'>“git@github.com:your_username/your_username.github.io.git</span></code></pre></td></tr></table></div></figure>


<p>中的your_username替换成自己GitHub用户名即可。（两种地址，前者是HTTPS地址，后者是SSH地址，任选一个粘贴即可）</p>

<p>现在可以开始生成自己的第一篇博客并部署放至GitHub上。
在终端输入以下命令：生成一篇新的博客</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post['test']</span></code></pre></td></tr></table></div></figure>


<p>其中test是默认的博客标题（当然博客的标题可以在markdown文件里面更改）。当然你也可以输入rake new_post命令，按照终端的提示输入博客的标题。生成完成的文章内容在octopress/source/_posts目录下。文件名为时间＋标题名，如“2015-09-17-test.markdown”。可以用markdown工具（本文用的markdown工具为“Mou”）进行编辑与修改。</p>

<p>接下来在终端输入rake generate命令生成静态文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate</span></code></pre></td></tr></table></div></figure>


<p>在部署到GitHub上之前，你可以在本地预览一下博客的效果。
先在终端输入rake preview命令，生成预览blog。然后在浏览器中输入<code>http://localhost:4000</code>查看博客的预览效果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake preview</span></code></pre></td></tr></table></div></figure>


<p>在终端退出预览效果：ctrl+c</p>

<p>确认效果之后，开始部署至GitHub。rake deploy命令会将octopress/public目录下的文件上传至仓库的master分支。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<p>最后一步，将Octopress的源码提交至GitHub</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m 'commit source file'
</span><span class='line'>git push origin source</span></code></pre></td></tr></table></div></figure>


<p>完工，屌逼的第一篇博客就已经发布到GitHub Pages上了。你现在可以输入:username.github.io在线查看自己的博客了（如：yangshebing.github.io）。</p>

<p>至于其中的相关原理分析我就不一一赘述了。请参看文章末尾的参考文章链接或者自行网上搜索。</p>

<h4>二、简单的配置Octopress</h4>

<h6>1、修改Octopress的配置文件（路径：octopress/_config.yml）</h6>

<ul>
<li>设置博客的标题，子标题以及作者相关信息。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>title: 杨社兵的技术博客
</span><span class='line'>subtitle: 业精于勤荒于嬉，行成于思毁于随.
</span><span class='line'>author: 杨社兵</span></code></pre></td></tr></table></div></figure>


<ul>
<li>删除twitter相关信息（GFW造成页面加载慢）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Twitter
</span><span class='line'>twitter_user:
</span><span class='line'>twitter_tweet_button: true</span></code></pre></td></tr></table></div></figure>


<ul>
<li>修改source/_includes目录下的head.html文件：将<code>//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.jst</code>替换成<code>http://cdn.staticfile.org/jquery/1.9.1/jquery.min.jst</code>（解决页面加载过慢问题）</li>
<li>修改source/_includes/custom目录下的自定义head.html文件，去掉google自定义字体（解决页面加载过慢问题）</li>
</ul>


<h6>2、添加统计工具（百度统计）</h6>

<p>去<a href="http://tongji.baidu.com">百度统计</a>官网申请一个账号，在管理界面选择“代码获取”，复制代码至<code>source/_includes/custom/footer.html</code>文件中。</p>

<h6>3、自定义博客导航栏</h6>

<p>部署好博客之后，你会发现导航栏上默认的只有两项：Blog、Archives，无法满足我们的需求。比如我们想在导航栏上添加一个选项为“关于我”。</p>

<p>打开“/source/_includes/custom”目录的navigation.html文件进行编辑：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*&lt;ul class="main-navigation"&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://yangshebing.github.io/"&gt;我的博客&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://yangshebing.github.io/blog/archives"&gt;所有文章&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://weibo.com/yangshebing" target="_blank"&gt;新浪微博&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>  &lt;li&gt;&lt;a href="http://yangshebing.github.io/about"&gt;关于我&lt;/a&gt;&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span></code></pre></td></tr></table></div></figure>


<p>接下来在终端输入rake new_page命令，生成一个index.markdown文件，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_page['about']</span></code></pre></td></tr></table></div></figure>


<p>它的默认保存路径是：“source/about/index.markdown”，编辑index.markdown文件，即可定制“关于我”页面内容。</p>

<h6>4、关于博客的评论和分享到微博功能，请参考末尾文章链接《象写程序一样写博客：搭建基于github的博客》一文。</h6>

<p>参考文章链接：</p>

<p>（1）<a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/" target="_blank">象写程序一样写博客：搭建基于github的博客</a></p>

<p>（2）<a href="http://matrixzk.github.io/blog/20141020/octopress-setup-and-analysis/#section" target="_blank">使用 Octopress 2.0 搭建基于 Github Pages 个人博客的详细过程及原理分析</a></p>

<p>（3）<a href="http://www.jianshu.com/p/0ac2ac1a8e45" target="_blank">octopress博客搭建和个性化配置</a></p>

<p>（4）<a href="https://liuchungui.github.io/blog/2015/09/11/macdian-nao-shang-da-jian-octopressbo-ke/" target="_blank">Mac电脑上搭建octopress博客</a></p>

<p>（5）<a href="http://www.cnblogs.com/sawyerzhu/p/3710374.html" target="_blank">Mac环境下octopress个人博客搭建</a></p>

<p>（6）<a href="http://foggry.com/blog/2014/04/28/custom-your-octopress-blog/" target="_blank">自定义你的Octopress博客</a></p>

<p>（7）<a href="http://blog.devtang.com/blog/2014/06/02/use-gitcafe-to-host-blog/" target="_blank">将博客从GitHub迁移到GitCafe</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中点击状态栏让滑动视图回到顶部]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/13/arcticle/"/>
    <updated>2015-09-13T23:28:31+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/13/arcticle</id>
    <content type="html"><![CDATA[<h6>在产品开发过程中，有时候会有这种需求，需要点击状态栏让滑动视图（UIScrollView）或者表视图（UITableView）返回到顶部，让用户可以更快的浏览最新的信息。</h6>

<h6>这个时候我们需要设置滑动视图的scrollsToTop属性，让它决定点击状态栏是否返回顶部。</h6>

<!--more-->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// When the user taps the status bar, 
</span><span class='line'>the scroll view beneath the touch which is closest to the status bar will be scrolled to top,
</span><span class='line'> but only if its scrollsToTop property is YES, 
</span><span class='line'> its delegate does not return NO from shouldScrollViewScrollToTop,
</span><span class='line'>  and it is not already at the top. 
</span><span class='line'>// On iPhone, we execute this gesture only if there’s one on-screen scroll view with scrollsToTop == YES.
</span><span class='line'> If more than one is found, none will be scrolled.
</span><span class='line'>@property(nonatomic) BOOL scrollsToTop; // default is YES.</span></code></pre></td></tr></table></div></figure>


<h6>设置这个属性，可以让点击状态栏不返回顶部。如果我们需要让它点击状态栏回到顶部，我们可以把这个属性值设置为YES（默认为YES）。按正常情况来说，这个时候点击状态栏是可以返回到顶部。但是点击状态栏还是没有反应怎么办？</h6>

<h6>解决方法如下：</h6>

<h6>按照上面官方文档的说法，只有把当前主控制器需要设置的那个scrollview找到并把它的scrollsToTop属性设置为YES，然后再把其他scrollview的scrollsToTop属性设置为NO 。这样它才会响应这个事件。其中的原理非常简单，如果当前主控制器中有2个scrollview，系统压根就不知道你想要其中的哪个scrollview滑动到顶部。</h6>

<h6>举个栗子：</h6>

<ul>
<li>假设当前控制器中有三个表视图（UITableView）或者滑动视图(UIScrollView)要切换，把当前显示的滑动视图scrollsToTop属性设置为YES,其他滑动视图的scrollsToTop属性设置为NO即可。</li>
</ul>


<p><strong>注意：如果当前滑动视图中存在子视图也是滑动视图的情况，那么它子视图中的滑动视图scrollsToTop属性也要设置为NO，不然它仍然会造成点击状态栏无法响应返回到顶部操作。</strong></p>

<h6>参考博客地址：</h6>

<ul>
<li><a href="http://blog.sina.com.cn/s/blog_463dc5b90101k9ib.html">点击状态栏不返回顶部问题</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift语言编程]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/12/swift/"/>
    <updated>2015-09-12T12:53:21+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/12/swift</id>
    <content type="html"><![CDATA[<h4>Swift语言基础学习</h4>

<p>1、语法基础</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态限制UITextField或UITextView用户输入中英文混编字数统计]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/12/test/"/>
    <updated>2015-09-12T11:31:37+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/12/test</id>
    <content type="html"><![CDATA[<p><strong>动态限制用户输入字数，这个在很多app中都会涉及，由于NSString的Length属性获取的长度中英文都是一个字节，不满足一个汉字两个字节、一个字符一个字节的需求。网上的方法大致是以下两种：</strong></p>

<h6>1、使用Unicode编码把OC中的NSString字符串转换成C的字符串。然后对字符串遍历进行统计长度。</h6>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>-  (int)convertToInt:(NSString*)strtemp {  
</span><span class='line'>    int strlength = 0;
</span><span class='line'>    char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding];
</span><span class='line'>    for (int i=0 ; i&lt;[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding];i++) {
</span><span class='line'>        if (*p) {
</span><span class='line'>            p++;
</span><span class='line'>            strlength++;
</span><span class='line'>        }
</span><span class='line'>        else {
</span><span class='line'>            p++;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return strlength;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h6>2、直接计算OC中的NSString字符串中单词的个数</h6>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSInteger)countWordWithStr:(NSString *)s
</span><span class='line'>{
</span><span class='line'>    NSInteger i,n=[s length],l=0,a=0,b=0;
</span><span class='line'>    unichar c;
</span><span class='line'>    for(i=0;i&lt;n;i++){
</span><span class='line'>        c=[s characterAtIndex:i];
</span><span class='line'>        if(isblank(c)){
</span><span class='line'>            b++;
</span><span class='line'>        }else if(isascii(c)){
</span><span class='line'>            a++;
</span><span class='line'>        }else{
</span><span class='line'>            l++;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    if(a==0 && l==0) return 0;
</span><span class='line'>    return l+(NSInteger)ceilf((float)(a+b)/2.0);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>以上资料均为网上整理得来，仅供学习交流使用。有关于此类问题，欢迎在最下方留言一起探讨优化学习。</strong></p>

<h6>参考博客地址：</h6>

<ul>
<li>1、<a href="http://mobilesolutions.blog.163.com/blog/static/18922417620116133910181/">统计含中英文混编的NSString 字符串长度 </a></li>
<li>2、<a href="http://blog.csdn.net/toss156/article/details/8993270">【IOS】IOS开发常用函数</a></li>
<li>3、<a href="http://code.qtuba.com/article-60968.html">iOS - 推断输入字符串长度函数</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
