<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-c | 杨社兵的技术博客]]></title>
  <link href="http://yangshebing.github.io/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://yangshebing.github.io/"/>
  <updated>2016-05-15T00:10:15+08:00</updated>
  <id>http://yangshebing.github.io/</id>
  <author>
    <name><![CDATA[杨社兵]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS图形绘制CoreGraphics篇]]></title>
    <link href="http://yangshebing.github.io/blog/2016/05/14/iostu-xing-hui-zhi-coregraphicspian/"/>
    <updated>2016-05-14T21:57:43+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/05/14/iostu-xing-hui-zhi-coregraphicspian</id>
    <content type="html"><![CDATA[<h4>1、绘制直线</h4>

<pre><code>
//获取当前上下文
    CGContextRef contextRef = UIGraphicsGetCurrentContext();
    UIColor *color = [UIColor colorWithRed:0.5 green:0.35 blue:0.8 alpha:0.7];
    //设置线条颜色
//    CGContextSetStrokeColor(contextRef, CGColorGetComponents([UIColor redColor].CGColor));
    //官方推荐首选这个API
    CGContextSetStrokeColorWithColor(contextRef, [UIColor redColor].CGColor);
    //设置线条颜色
    CGContextSetLineWidth(contextRef, 5);
    //设置线条端点(不带端点)
    CGContextSetLineCap(contextRef, kCGLineCapButt);
    //设置线条绘制的起始坐标点
    CGContextMoveToPoint(contextRef, 50, 20);
    //结束点
    CGContextAddLineToPoint(contextRef, 100, 20);
    //绘制线条路径
    CGContextStrokePath(contextRef);
</code></pre>

<!--more-->


<p><strong>这里插播一个从指定UIColor对象中获取RGB值得方式，上面设置线条颜色方法：CGContextSetStrokeColor第二个参数有用到。</strong></p>

<pre><code>
    //它是返回一个存储RGB与Alpha值得数组
    const CGFloat *componets =  CGColorGetComponents(color.CGColor);
    CGFloat r,g,b,a;
    //R值
    r = componets[0];
    //G值
    g = componets[1];
    //B值
    b = componets[2];
    //Alpha值
    a = componets[3];
</code></pre>

<p><strong>不信，此处看客可以打印RGB、Alpha值试试！</strong></p>

<h4>2、绘制矩形</h4>

<pre><code>  //设置线条颜色
    CGContextSetStrokeColorWithColor(contextRef, [UIColor blueColor].CGColor);
    CGContextSetLineWidth(contextRef, 2);
    //绘制矩形边框
    CGContextStrokeRect(contextRef, CGRectMake(50, 30, 80, 80));
//    CGContextSetFillColor(contextRef, CGColorGetComponents([UIColor cyanColor].CGColor));
    //绘制实心矩形
    CGContextSetFillColorWithColor(contextRef, [UIColor cyanColor].CGColor);
    CGContextFillRect(contextRef, CGRectMake(50, 120, 80, 80));

    //绘制带边框的矩形
    CGContextSetStrokeColorWithColor(contextRef, [UIColor brownColor].CGColor);
    CGContextSetFillColorWithColor(contextRef, [UIColor magentaColor].CGColor);
    CGContextSetLineWidth(contextRef, 2);
    CGContextAddRect(contextRef, CGRectMake(50, 210, 80, 80));

    //绘制路径方式：
    /*CGPathDrawingMode:
     *kCGPathFill,  //用非零绕数规则填充（什么鬼？）
     *kCGPathEOFill,    //用奇偶规则填充不带边框
     *kCGPathStroke,    //描线
     *kCGPathFillStroke,    //描线填充
     *kCGPathEOFillStroke   //奇偶填充带边框
     */
    CGContextDrawPath(contextRef, kCGPathFillStroke);
</code></pre>

<p> <strong>这里介绍一下设置线型为虚线的方式（虚线绘制方式）</strong></p>

<pre><code>
/*
*phase:    虚线开始部分绘制大小
*const CGFloat *lengths:   虚线排列的大小规则数组，数组的值用来指定绘制与未绘制部分的长度（间隔）
*例如{2，3}指交替绘制2个单元长度的线段与3个单元长度未绘制长度线段（间隙）
*例子示意图：      --   --   --   --   --   --
*{1，3，4，2}绘制一个单元长度线段，间隔3个单元长度空隙，接着绘制4个长度的线段，间隔2个单元长度的空隙
*例子示意图：      -   ----  -   ----  -   ----  -   ----  -
*size_t count: 虚线排列数组中参数值有用个数
*/

const CGFloat spaceArr[] = {6, 4, 5, 7};
CGContextSetLineDash(contextRef, 0, spaceArr, 4);
</code></pre>

<p> ####3、绘制贝塞尔曲线</p>

<pre><code>
CGContextSetStrokeColorWithColor(contextRef, [UIColor redColor].CGColor);
CGContextSetFillColorWithColor(contextRef, [UIColor grayColor].CGColor);
CGContextSetLineWidth(contextRef, 1);
CGContextMoveToPoint(contextRef, 50, 300);
//添加三个point坐标。绘制一条曲线。
//CGContextAddCurveToPoint(contextRef, 100, 320, 150, 300, 200, 360);
//添加二次曲线
CGContextAddQuadCurveToPoint(contextRef, 250, 380, 290, 280);
CGContextDrawPath(contextRef, kCGPathStroke);
</code></pre>

<h4>4、绘制圆弧</h4>

<pre><code>
CGContextAddArc(contextRef, 50, 390, 20.0, -10 * M_PI / 180, 60 * M_PI / 180, YES);
CGContextDrawPath(contextRef, kCGPathStroke);
</code></pre>

<h4>5、绘制圆形</h4>

<pre><code>
//绘制圆形:方式一
CGContextSetStrokeColorWithColor(contextRef, [UIColor blueColor].CGColor);
CGContextSetFillColorWithColor(contextRef, [UIColor redColor].CGColor);
CGContextAddArc(contextRef, 50, 480, 20.0, -180 * M_PI / 180, 180 * M_PI / 180, NO);
CGContextDrawPath(contextRef, kCGPathFillStroke);
//绘制圆形：方式二
CGContextAddEllipseInRect(contextRef, CGRectMake(0, 500, 80, 80));
CGContextDrawPath(contextRef, kCGPathFillStroke);
</code></pre>

<h4>6、绘制多边型（六边形）</h4>

<pre><code>
//绘制多边形
CGContextMoveToPoint(contextRef, 180, 500);
CGContextAddLineToPoint(contextRef, 100, 550);
CGContextAddLineToPoint(contextRef, 180, 600);
CGContextAddLineToPoint(contextRef, 260, 600);
CGContextAddLineToPoint(contextRef, 340, 550);
CGContextAddLineToPoint(contextRef, 260, 500);
CGContextAddLineToPoint(contextRef, 180, 500);
CGContextDrawPath(contextRef, kCGPathFillStroke);
//最后关闭它！
CGContextClosePath(contextRef);
</code></pre>

<p><strong>这里就不演示绘制图表了，其实过程都差不多，只是换一种绘制方法而已！
关于简单的图表绘制请参考上一篇，详细请点击：<a href="http://yangshebing.github.io/blog/2016/05/14/iostu-xing-hui-zhi-uibezierpathpian/">iOS图形绘制UIBezierPath篇</a></strong></p>

<p><strong>文中代码效果图：</strong></p>

<p><img src="http://ww1.sinaimg.cn/mw690/7f266405jw1f3va3hd4i9j20ku12aq57.jpg" alt="" />
<strong>不要问我为什么画的这么丑，因为我是粗糙的程序员！随性</strong></p>

<h4>参考博客地址：</h4>

<ul>
<li><a href = "http://ghui.me/post/2016/04/ios-core-graphics/">iOS绘图之用Core Graphics框架绘制常见图形（这篇是用Swift语言写的）</a></li>
</ul>


<p>转载请注明出处</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS图形绘制UIBezierPath篇]]></title>
    <link href="http://yangshebing.github.io/blog/2016/05/14/iostu-xing-hui-zhi-uibezierpathpian/"/>
    <updated>2016-05-14T21:55:19+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/05/14/iostu-xing-hui-zhi-uibezierpathpian</id>
    <content type="html"><![CDATA[<h4>1、绘制直线</h4>

<pre><code>UIBezierPath *line = [[UIBezierPath alloc] init];
//设置线宽
line.lineWidth = 3;
[line moveToPoint:CGPointMake(50, 20)];
[line addLineToPoint:CGPointMake(150, 20)];
//设置绘制线条颜色，这个地方需要注意！UIBezierPath本身类中不包含设置颜色的属性，它是通过UIColor来直接设置。
[[UIColor orangeColor] setStroke];
/*
*线条形状
*kCGLineCapButt,   //不带端点
*kCGLineCapRound,  //端点带圆角
*kCGLineCapSquare  //端点是正方形
*/
line.lineCapStyle = kCGLineCapRound;
[line stroke];
</code></pre>

<!--more-->


<h4>2、绘制矩形</h4>

<ul>
<li>直接通过UIRectFill绘制（不带边框）</li>
</ul>


<pre><code>
[[UIColor blueColor] setFill];
UIRectFill(CGRectMake(50, 30, 100, 40));
</code></pre>

<ul>
<li>使用UIBezierPath绘制（带边框）</li>
</ul>


<pre><code>
UIBezierPath *rectangle = [UIBezierPath bezierPathWithRect:CGRectMake(50, 80, 80, 80)];
//边框线宽
rectangle.lineWidth = 3;
//边框线颜色
[[UIColor purpleColor] setStroke];
/*
*线条之间连接点形状
*kCGLineJoinMiter,      //内斜接
*kCGLineJoinRound,     //圆角
*kCGLineJoinBevel      //外斜接
*/
rectangle.lineJoinStyle = kCGLineJoinRound;
//绘制边框
[rectangle stroke];
//设置填充颜色
[[UIColor yellowColor] setFill];
//绘制矩形内部填充部分
[rectangle fill];
</code></pre>

<ul>
<li>直接绘制带圆角的矩形（实心）：这里也是可以添加边框，具体设置同上</li>
</ul>


<pre><code>
UIBezierPath *rectangleCorner = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 170, 80, 80) cornerRadius:4];
[[UIColor brownColor] setFill];
[rectangleCorner fill];
</code></pre>

<ul>
<li>绘制部分带圆角的矩形边框（空心）</li>
</ul>


<pre><code>
/*
*UIRectCorner:圆角位置
*UIRectCornerTopLeft     = 1 &lt;&lt; 0,     //左上角
*UIRectCornerTopRight    = 1 &lt;&lt; 1,     //右上角
*UIRectCornerBottomLeft  = 1 &lt;&lt; 2,     //左下角
*UIRectCornerBottomRight = 1 &lt;&lt; 3,     //右下角
*UIRectCornerAllCorners        //所有角
*
*/
rectangleCorner = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 260, 40, 40) byRoundingCorners:UIRectCornerTopLeft | UIRectCornerTopRight cornerRadii:CGSizeMake(4, 4)];
[rectangleCorner stroke];
</code></pre>

<h4>3、绘制圆形（绘制椭圆只需更改高宽即可）</h4>

<pre><code>
UIBezierPath *circle = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 310, 80, 80)];
[[UIColor blueColor] setStroke];
circle.lineWidth = 3;
[circle stroke];
[[UIColor redColor] setFill];
[circle fill];
</code></pre>

<h4>4、绘制多边形:(这是正宗的三角形)</h4>

<pre><code>
UIBezierPath *polygon = [UIBezierPath bezierPath];
[polygon moveToPoint:CGPointMake(50, 390)];
[polygon addLineToPoint:CGPointMake(30, 450)];
[polygon addLineToPoint:CGPointMake(100, 450)];
[[UIColor magentaColor] setFill];
[polygon fill];
</code></pre>

<p><strong>啊，三角形不是多边形吗？不调戏各位看客了，还是来个正宗多边形，哈哈哈（六角形）</strong></p>

<pre><code>
[polygon moveToPoint:CGPointMake(50, 460)];
[polygon addLineToPoint:CGPointMake(20, 500)];
[polygon addLineToPoint:CGPointMake(50, 540)];
[polygon addLineToPoint:CGPointMake(100, 540)];
[polygon addLineToPoint:CGPointMake(130, 500)];
[polygon addLineToPoint:CGPointMake(100, 460)];
[[UIColor magentaColor] setFill];
[polygon fill];
</code></pre>

<h4>5、绘制弧线</h4>

<pre><code>
//clockwise参数表示是否顺时针绘制
//弧长计算公式：
UIBezierPath *arcLine = [UIBezierPath bezierPathWithArcCenter:CGPointMake(160, 20) radius:50 startAngle:0 endAngle:90 *  M_PI / 180 clockwise:YES];
//下面这种创建方式也是一样的
//[arcLine addArcWithCenter:CGPointMake(160, 20) radius:50 startAngle:0 endAngle:90 * M_PI / 180 clockwise:YES];
arcLine.lineWidth = 3;
[[UIColor grayColor] setStroke];
[arcLine stroke];
</code></pre>

<h4>6、绘制贝塞尔曲线</h4>

<pre><code>
UIBezierPath *quadLine = [UIBezierPath bezierPath];
[quadLine moveToPoint:CGPointMake(160, 80)];
//带一个控制点
//[quadLine addQuadCurveToPoint:CGPointMake(210, 120) controlPoint:CGPointMake(240, 90)];
//带两个控制点
[quadLine addCurveToPoint:CGPointMake(310, 80) controlPoint1:CGPointMake(210, 150) controlPoint2:CGPointMake(270, 150)];
[[UIColor redColor] setStroke];
[quadLine stroke];
</code></pre>

<h4>7、绘制一个简单的曲线图(这个技术难度不高，项目中又常见，可以拿来练练手)</h4>

<pre><code>
- (void)drawRect:(CGRect)rect {
//绘制线条
    UIBezierPath *grayLine = [UIBezierPath bezierPath];
    grayLine.lineWidth = 1;
    grayLine.lineCapStyle = kCGLineCapButt;
    [[UIColor lightGrayColor] setStroke];
    CGFloat x1 = 140;
    CGFloat x2 = 360;
    CGFloat y = 160;
    //循环绘制7条横向线条
    for (int i = 0; i &lt; 7; i++) {
        [self drawPathWithLine:grayLine movePoint:CGPointMake(x1, y + i * 20) toPoint:CGPointMake(x2, y + i * 20)];
    }

    //绘制竖线
    [self drawPathWithLine:grayLine movePoint:CGPointMake(x1 + 5, y) toPoint:CGPointMake(x1 + 5, y + 6 * 20 + 5)];
    [self drawPathWithLine:grayLine movePoint:CGPointMake(x2, y) toPoint:CGPointMake(x2, y + 6 * 20 + 5)];
    //绘制圆点
    UIBezierPath *circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1, y + 5 * 20 - 5, 10, 10)];
    [[UIColor blueColor] setStroke];
    UIBezierPath *blueLine = [UIBezierPath bezierPath];
    blueLine.lineWidth = 2;
    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x - 2.5, circleDot.currentPoint.y - 5) toPoint:CGPointMake(x1 + 40 + 2.5 , y + 1 * 20 + 5)];
    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 40, y + 1 * 20 - 5, 10, 10)];
    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x , circleDot.currentPoint.y + 2.5) toPoint:CGPointMake(x1 + 80 , y + 3 * 20 - 12.5)];
    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 80, y + 3 * 20 - 15, 10, 10)];
    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x , circleDot.currentPoint.y + 5) toPoint:CGPointMake(x1 + 120 , y + 4 * 20)];
    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 120, y + 4 * 20, 10, 10)];
    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x, circleDot.currentPoint.y - 5) toPoint:CGPointMake(x1 + 160 , y + 1 * 20 - 5)];
    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 160, y + 1 * 20 - 15, 10, 10)];
    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x , circleDot.currentPoint.y + 5) toPoint:CGPointMake(x1 + 200 , y + 6 * 20 - 15)];
    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 200 - 2.5, y + 6 * 20 - 15, 10, 10)];
}

- (void)drawPathWithLine:(UIBezierPath *)line movePoint:(CGPoint)movePoint toPoint:(CGPoint)toPoint {
    [line moveToPoint:movePoint];
    [line addLineToPoint:toPoint];
    [line stroke];
}

- (UIBezierPath *)drawCircleWithOvalInRect:(CGRect)frame {
    UIBezierPath *circleDot = [UIBezierPath bezierPathWithOvalInRect:frame];
    [[UIColor blueColor] setFill];
    [circleDot fill];
    return circleDot;
}
</code></pre>

<p><strong>看客：博主，你代码写的太差了！我看不下去了！死菜鸡！</strong></p>

<p><strong>博主：大哥，我已经尽力了！</strong></p>

<p><strong>看客：这么菜，你还有脸写博客！你咋不上天呢？</strong></p>

<p><strong>博主：那你咋不遁地！</strong></p>

<h4>文中代码效果图：</h4>

<p><img src="http://ww1.sinaimg.cn/mw690/7f266405jw1f3vbdc3656j20ku12adi4.jpg" alt="" />
<strong>不要问我为什么画的这么丑，哥已经尽力了！</strong></p>

<h4>参考博客地址：</h4>

<ul>
<li><a href = "http://ghui.me/post/2016/04/ios-bezierpath/">iOS绘图之用UIKit框架绘制常见图形（这篇是用Swift语言写的）</a></li>
</ul>


<p>转载请注明出处</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UICollectionView（纯代码方式）实现带上下拉刷新的瀑布流式（WaterFlow）布局]]></title>
    <link href="http://yangshebing.github.io/blog/2015/11/03/waterflow/"/>
    <updated>2015-11-03T22:40:32+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/11/03/waterflow</id>
    <content type="html"><![CDATA[<p>瀑布流（WaterFlow）是项目开发过程中的常见布局，有关于瀑布流（WaterFlow）的实现方式：在UICollectionView未出现之前，瀑布流的实现多半是采用UIScrollView或是UITableView。对于我们这种用惯了表视图的人来说，UICollectionView倒略显陌生。有关于UICollectionView的介绍我就不一一赘述，因为一两句话也很难说清楚。网上有很多优秀的文章专门对其进行了一系列的解说，另有苹果官方文档可以查阅。本文主要是介绍如何采用纯代码的方式利用UICollectionView实现带上下拉刷新的瀑布流式（WaterFlow）布局。废话少说，直接入题。</p>

<!--more-->


<h4>一、UICollectionView集成上下拉刷新</h4>

<p>（1）简单的介绍UICollectionView</p>

<p>UICollectionView和UITableView很相似，如果你对表视图非常熟悉，上手的速度也会快很多。使用它时需要相应的设置DataSource（UICollectionViewDataSoure)数据源协议和Delegate（UICollectionViewDelegate)事件协议，并实现相应的协议方法。它与UITableView不同的地方是它有UICollectionViewLayout，可以通过它的子类来定制布局。系统默认的布局方式是UICollectionViewDelegateFlowLayout，实现相应的协议（UICollectionViewDelegateFlowLayout）方法，便可达到默认布局效果。</p>

<p>UICollectionViewCell与UITableViewCell的使用也差不多，一样的有ReuseIdentifier,可以复用。使用UICollectionViewCell时，需要先注册，然后再出列使用。至于注册并出列使用Cell的具体方式，请自行下载文章末尾的BGWaterFlowView或者自行Google。</p>

<p>（2）集成上下拉刷新方式</p>

<p>一般UITableView添加上下拉刷新的方式，是把下拉或者上拉刷新视图的UI放置UITableView的表头属性(tableHeaderView)或者表尾属性（tableFooterView）。但是，在UICollectionView中没有这两个属性。那么我们该如何来集成上下拉刷新呢？这就得说到
UICollectionView布局中的三种显示内容视图：Cells、Supplementary views、Decoration views。(关于这三种视图的介绍可以去官网查阅相关文档，上面有详细的解释)。我们一般是把上下拉刷新的UI放置在Supplementary views（官方解释：它能显示数据但是不同于Cells。不像Cell,Supplementary views是不能被用户选定的。相反，你可以用它去实现类似于给一个指定的section或者整个CollectionView添加页眉和页脚视图这样的功能）上面，其实，Supplementary views就和TableView的section头视图和尾视图差不多。但是用法却大不相同。在自定义瀑布流布局中一定要把它也计算进去，不然显示就会有异常。</p>

<ul>
<li><strong>注册头视图和尾视图单元格类型</strong></li>
</ul>


<pre><code>//注册头视图：kind代表Supplementary视图类型，UICollectionElementKindSectionHeader表示组头

[self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"bGCollectionHeaderView"];

//注册尾视图：UICollectionElementKindSectionHeader表示组尾

    [self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"bGCollectionFooterView"];
</code></pre>

<ul>
<li><strong>实现自定义组视图viewForSupplementaryElementOfKind代理方法</strong></li>
</ul>


<pre><code>- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath {

    //kind代表Supplementary视图类型：头或尾视图（header OR footer）

    if([kind isEqual:UICollectionElementKindSectionHeader]) {
        UICollectionReusableView *collectionHeaderView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"bGCollectionHeaderView" forIndexPath:indexPath];

        //初始化下拉刷新或者自定义页眉视图UI界面
        ...

        return collectionHeaderView;
    } else if([kind isEqual:UICollectionElementKindSectionFooter]) {
        UICollectionReusableView *collectionFooterView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"bGCollectionFooterView" forIndexPath:indexPath];

        //初始化上拉刷新或者自定义页脚视图UI界面
        ...

        return collectionFooterView;
    }

    return nil;
}
</code></pre>

<p>完成以上两步，集成上下拉刷新的功能总算完成了。接下来你可以运行一下工程，看结果是否符合预期。如果你CollectionView使用的是系统的UICollectionViewFlowLayout布局，一定要返回组头或者组尾的高度，否则就会出现组头或者组尾无法显示（本文的下拉刷新视图所在的组头不返回高度不受影响，是因为它的纵坐标（y值）本来就是负数）。另外，还有一点需要注意的是，如果你的CollectionView中存在多组，最好是把上下拉刷新所在的组头或者组尾与其他组（section）的组头或组尾分开，相应的需要多注册一个组头或者组尾视图，分情况进行判断(这部分如果还有问题，可以在文章末尾留言，我会及时回复)。</p>

<h4>二、自定义瀑布流（WaterFlow）式布局</h4>

<p>（1）简单的介绍UICollectionView布局形式</p>

<p>一般来讲，UICollectionView的布局形式分为两种：</p>

<ul>
<li><p>布局与内容独立，其布局不需要根据显示的单元格内容来计算。Cell的显示顺序与内容顺序一致。Cell排满一行则换至下一行继续排列。系统的UICollectionViewFlowLayout就是这样。</p></li>
<li><p>布局需要计算内容，本文的瀑布流Demo局部正是如此。UICollectionViewFlowLayout系统布局在换行的时候，由于每个item高度不同，从而导致布局错乱，无法满足你的需求。所以，这个时候你需要计算每个item的高度，最终用来确定item显示的位置。</p></li>
</ul>


<p>从上述内容我们可以看出，一般如果布局需要计算内容的时候，我们就不应该直接使用UICollectionViewFlowLayout布局了，而是应该子类化一个UICollectionViewLayout，从而达到私人定制的目的。</p>

<p>（2）创建自定义布局</p>

<p><a href = "https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/CreatingCustomLayouts/CreatingCustomLayouts.html#//apple_ref/doc/uid/TP40012334-CH5-SW1">官方文档</a>中有提到，在布局的过程中，CollectionView会调用布局对象的具体方法。这些方法有机会使你计算这些项的位置以及给CollectionView提供它所需要的主要信息。其他的方法也有可能会被调用，但是在布局的过程中这些方法总是会按照以下的顺序调用：</p>

<ol>
<li>使用"prepareLayout"方法去执行一些CollectionView所需要的布局信息的预先计算操作。</li>
<li>使用"collectionViewContentSize"方法去返回根据你最初计算的整个内容区域的总体大小。</li>
<li>使用"layoutAttributesForElementsInRect:&ldquo;方法来返回指定区域的单元格与视图属性。</li>
</ol>


<p>下面我们通过Demo来详细的讲解一下如何自定义瀑布流，废话不多说，直接上代码（本文采用的Demo为<strong>BGWaterFlowView</strong>,<strong>GitHub传送门</strong>：<a href = 'https://github.com/yangshebing/BGWaterFlowView'>请点击这里</a>）：</p>

<ul>
<li><strong>重写"prepareLayout"方法计算布局信息。</strong></li>
</ul>


<pre><code>- (void)prepareLayout{
    [super prepareLayout];
    ...

    //计算每个显示项的宽度，horizontalItemSpacing代表项与项之间的水平间隔， 
    columnNum代表总列数，contentInset代表上下左右的内填充。详见下图说明

    self.itemWidth = (self.collectionView.frame.size.width - (self.horizontalItemSpacing * (self.columnNum - 1)) - self.contentInset.left - self.contentInset.right) / self.columnNum;

    //如有下拉刷新需求的则需要提供头视图（Supplementary view）布局属性。
    demo中的headerHeight属性可设置是否显示头视图（是否计算头视图的布局属性）。

    if(self.headerHeight &gt; 0){

    //通过layoutAttributesForSupplementaryViewOfKind:withIndexPath:方法来创建Supplementary视图布局属性对象，kind用来区分Supplementary视图类型（header或者footer）。

        self.headerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionHeader withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];

        //修改布局参数frame属性

        self.headerLayoutAttributes.frame = CGRectMake(0, 0, self.collectionView.frame.size.width, self.headerHeight);
    }

    //初始化保存布局属性的字典
    NSMutableDictionary *cellLayoutInfoDic = [NSMutableDictionary dictionary];
    //初始化列高数组
    NSMutableArray *columnInfoArray = [self columnInfoArray];
    NSInteger numSections = [self.collectionView numberOfSections];
    for(NSInteger section = 0; section &lt; numSections; section++)  {
        NSInteger numItems = [self.collectionView numberOfItemsInSection:section];
        for(NSInteger item = 0; item &lt; numItems; item++){
            //获取列高最小的model，以它的高作为y坐标
            BGWaterFlowModel *firstModel = columnInfoArray.firstObject;
            CGFloat y = firstModel.height;
            CGFloat x = self.contentInset.left + (self.horizontalItemSpacing + self.itemWidth) * firstModel.column;

            NSIndexPath *indexPath = [NSIndexPath indexPathForItem:item inSection:section];

            //通过代理方法传入对应item的高度。

            CGFloat itemHeight = [((id&lt;BGWaterFlowLayoutDelegate&gt;)self.collectionView.delegate) collectionView:self.collectionView layout:self heightForItemAtIndexPath:indexPath];

            //通过layoutAttributesForCellWithIndexPath:方法来创建cell的布局属性对象。

            UICollectionViewLayoutAttributes *itemAttributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];
            //计算item的布局属性
            itemAttributes.frame = CGRectMake(x, y+self.contentInset.top+self.headerHeight, self.itemWidth, itemHeight);
            //计算当前列高,verticalItemSpacing代表项与项之间的垂直间隔。
            firstModel.height += (itemHeight + self.verticalItemSpacing);
            //保存新的列高，并进行排序：从后往前查找，查找到高度比它小的对象，就插入到该对象之后。
            [self sortArrayByHeight:columnInfoArray];

     //保存计算好的item布局属性
     cellLayoutInfoDic[indexPath] = itemAttributes;
        }
    }

    //保存局部布局属性字典到全局字典中
    self.cellLayoutInfoDic = [cellLayoutInfoDic copy];

    //按照前面的排序逻辑，列高数组中的最后一个元素，就是高度最大的一列。
    BGWaterFlowModel *lastModel = columnInfoArray.lastObject;

    //如有上拉刷新需求的则需要提供尾视图布局属性。
    demo中的footerHeight属性可设置是否显示尾视图（是否计算尾视图的布局属性）。

    if(self.footerHeight &gt; 0){
        self.footerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionFooter withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];
        //计算尾视图的布局属性
        self.footerLayoutAttributes.frame = CGRectMake(0, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom, self.collectionView.frame.size.width, self.footerHeight);
    }

    //直接计算出collectionView的contentSize
    self.contentSize = CGSizeMake(self.collectionView.frame.size.width, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom+self.footerHeight);
}
</code></pre>

<p><strong>好吧，这么一大坨代码看到就头疼了，来张图帮助理解一下！图糙理不糙，理解万岁</strong>
<img src="http://ww4.sinaimg.cn/mw690/7f266405jw1ey25ujzticj218a0xmjww.jpg" alt="" /></p>

<p><strong>这样看上去是不是更清晰了？</strong></p>

<ul>
<li><strong>重写"collectionViewContentSize"方法返回collectionView的内容高度。</strong></li>
</ul>


<pre><code>
- (CGSize)collectionViewContentSize{
    //返回计算好的collectionView内容高度
    return self.contentSize;
}
</code></pre>

<ul>
<li><strong>重写"layoutAttributesForElementsInRect"方法返回指定矩形区域中的cell或者其他类型视图布局属性。</strong></li>
</ul>


<pre><code>- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect {

    //返回一组已经计算好的布局属性。

    NSMutableArray *attributesArrs = [NSMutableArray array];
    [self.cellLayoutInfoDic enumerateKeysAndObjectsUsingBlock:^(NSIndexPath *indexPath,
                                                                UICollectionViewLayoutAttributes *attributes,
                                                                BOOL *stop) { 
        //遍历布局属性保存字典，添加布局属性至数组中                                                       
        if (CGRectIntersectsRect(rect, attributes.frame)) {
            [attributesArrs addObject:attributes];
        }
    }];

    //如果有头视图或者尾视图则需要添加头视图与尾视图的布局属性

    if (self.headerLayoutAttributes &amp;&amp; CGRectIntersectsRect(rect, self.headerLayoutAttributes.frame)) {
        [attributesArrs addObject:self.headerLayoutAttributes];
    }


    if (self.footerLayoutAttributes &amp;&amp; CGRectIntersectsRect(rect, self.footerLayoutAttributes.frame)) {
        [attributesArrs addObject:self.footerLayoutAttributes];
    }

    return attributesArrs;
}
</code></pre>

<h4>结语：</h4>

<p><a href = "https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/index.html#//apple_ref/occ/cl/UICollectionViewLayout">UICollectionViewLayout</a>相关的内容姿势非常多，相关文章也非常多。本文介绍的瀑布流布局也只是其中的冰山一角，很多东西官方文档中已经介绍的非常详细了。所以，还是建议多看官方文档。本文主要注重项目的实用性，在后面就直接上代码了，可能在理论方面还是有所欠缺，对于不足的地方，希望大家多提建议，一起交流学习，一起进步。如果文中有看不懂的地方，还请您留言。我会及时进行回复。最后，本文的Demo就在于方便徒手撸代码的人使用。你懂的。后期会不断的更新优化，进一步的完善。敬请期待&hellip;</p>

<p>点击此处下载本文的Demo:<a href = 'https://github.com/yangshebing/BGWaterFlowView'><strong>BGWaterFlowView</strong></a></p>

<p>Demo使用方式详见:<a href = "https://github.com/yangshebing/BGWaterFlowView/blob/master/README.md"><strong>README.md</strong></a></p>

<p>Demo运行瀑布流效果截图如下所示:</p>

<p><img src="http://ww2.sinaimg.cn/large/7f266405jw1ey0z6x4xf9j20ku12aqb5.jpg"/ width = "375" height = "677" align = "center"></p>

<h6>参考博客地址：</h6>

<ul>
<li><a href = "http://objccn.io/issue-3-3/">自定义 Collection View 布局</a></li>
</ul>


<p>转载请注明出处</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS绘制虚线方式总结]]></title>
    <link href="http://yangshebing.github.io/blog/2015/10/12/ioshui-zhi-xu-xian-fang-shi-zong-jie/"/>
    <updated>2015-10-12T23:44:28+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/10/12/ioshui-zhi-xu-xian-fang-shi-zong-jie</id>
    <content type="html"><![CDATA[<h3>一、iOS中绘制虚线常见的几种方式：</h3>

<p>1、重写drawRect方法。</p>

<pre><code>- (void)drawRect:(CGRect)rect
{
    [super drawRect:rect];
CGContextRef currentContext = UIGraphicsGetCurrentContext();
//设置虚线颜色
    CGContextSetStrokeColorWithColor(currentContext, [UIColor BlackColor].CGColor);
    //设置虚线宽度
    CGContextSetLineWidth(currentContext, 1);
    //设置虚线绘制起点
    CGContextMoveToPoint(currentContext, 0, 0);
    //设置虚线绘制终点
    CGContextAddLineToPoint(currentContext, self.frame.origin.x + self.frame.size.width, 0);
    //设置虚线排列的宽度间隔:下面的arr中的数字表示先绘制3个点再绘制1个点
    CGFloat arr[] = {3,1};
    //下面最后一个参数“2”代表排列的个数。
    CGContextSetLineDash(currentContext, 0, arr, 2);
    CGContextDrawPath(currentContext, kCGPathStroke);

}
</code></pre>

<!--more-->


<p>2、采用CAShapeLayer方式绘制虚线</p>

<pre><code>CAShapeLayer *shapeLayer = [CAShapeLayer layer];
[shapeLayer setBounds:self.bounds];
[shapeLayer setPosition:CGPointMake(self.frame.size.width / 2.0, self.frame.size.height)];
[shapeLayer setFillColor:[UIColor clearColor].CGColor];
//设置虚线颜色
shapeLayer setStrokeColor:[UIColor BlackColor].CGColor];
//设置虚线宽度
[shapeLayer setLineWidth:self.frame.size.height];
[shapeLayer setLineJoin:kCALineJoinRound];
//设置虚线的线宽及间距
 [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:3], [NSNumber numberWithInt:1], nil]];
 //创建虚线绘制路径
 CGMutablePathRef path = CGPathCreateMutable();
 //设置虚线绘制路径起点
 CGPathMoveToPoint(path, NULL, 0, 0);
 //设置虚线绘制路径终点
 CGPathAddLineToPoint(path, NULL, self.frame.size.width, 0);
 //设置虚线绘制路径
 [shapeLayer setPath:path];
 CGPathRelease(path);
 //添加虚线
 [self.layer addSublayer:shapeLayer];
</code></pre>

<h5>关于这种方式已经有人整理出了一个非常好用的类方法，具体请参看文章末尾的参考博客地址：“iOS绘制虚线方法【原创】”一文，此方法使用起来非常简单方便。</h5>

<h6><strong><font color="red">注意：下面非完整代码，如有需要，请自行前往该博文中直接复制使用。</font></strong></h6>

<pre><code>/**
 ** lineView:       需要绘制成虚线的view
 ** lineLength:     虚线的宽度
 ** lineSpacing:    虚线的间距
 ** lineColor:      虚线的颜色
 **/

+ (void)drawDashLine:(UIView *)lineView lineLength:(int)lineLength lineSpacing:(int)lineSpacing lineColor:(UIColor *)lineColor
{
    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
    .....
    [shapeLayer setStrokeColor:lineColor.CGColor];
    ......
    [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:lineLength], [NSNumber numberWithInt:lineSpacing], nil]];
    　......
    [lineView.layer addSublayer:shapeLayer];

}
</code></pre>

<p>3、经济实惠型：采用贴图的方式绘制虚线（需要设计师切图配合）</p>

<pre><code>UIImageView *imgDashLineView =[[UIImageView alloc] initWithFrame:CGRectMake(15, 200, self.view.frame.size.width - 30, 1)];

[imgDashLineView setBackgroundColor:[UIColor colorWithPatternImage:[UIImage imageNamed:@"xuxian.png"]]];

[self.view addSubview:imgDashLineView];
</code></pre>

<p>在以上这几种方式中我个人比较偏爱最后一种，简单粗暴。</p>

<p>以上内容部分来自于网络，本着分享的学习精神，如有涉及侵权问题，请及时告知。欢迎一起探讨学习，有问题请留言。我将会在第一时间对你的问题进行回复。如需转载，请注明出处。</p>

<h6>参考博客地址：</h6>

<ul>
<li>1、<a href="http://blog.it985.com/14080.html">iOS绘制虚线方法【原创】</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中点击状态栏让滑动视图回到顶部]]></title>
    <link href="http://yangshebing.github.io/blog/2015/09/13/arcticle/"/>
    <updated>2015-09-13T23:28:31+08:00</updated>
    <id>http://yangshebing.github.io/blog/2015/09/13/arcticle</id>
    <content type="html"><![CDATA[<h6>在产品开发过程中，有时候会有这种需求，需要点击状态栏让滑动视图（UIScrollView）或者表视图（UITableView）返回到顶部，让用户可以更快的浏览最新的信息。</h6>

<h6>这个时候我们需要设置滑动视图的scrollsToTop属性，让它决定点击状态栏是否返回顶部。</h6>

<!--more-->


<pre><code class="">// When the user taps the status bar, 
the scroll view beneath the touch which is closest to the status bar will be scrolled to top,
 but only if its scrollsToTop property is YES, 
 its delegate does not return NO from shouldScrollViewScrollToTop,
  and it is not already at the top. 
// On iPhone, we execute this gesture only if there’s one on-screen scroll view with scrollsToTop == YES.
 If more than one is found, none will be scrolled.
@property(nonatomic) BOOL scrollsToTop; // default is YES.
</code></pre>

<h6>设置这个属性，可以让点击状态栏不返回顶部。如果我们需要让它点击状态栏回到顶部，我们可以把这个属性值设置为YES（默认为YES）。按正常情况来说，这个时候点击状态栏是可以返回到顶部。但是点击状态栏还是没有反应怎么办？</h6>

<h6>解决方法如下：</h6>

<h6>按照上面官方文档的说法，只有把当前主控制器需要设置的那个scrollview找到并把它的scrollsToTop属性设置为YES，然后再把其他scrollview的scrollsToTop属性设置为NO 。这样它才会响应这个事件。其中的原理非常简单，如果当前主控制器中有2个scrollview，系统压根就不知道你想要其中的哪个scrollview滑动到顶部。</h6>

<h6>举个栗子：</h6>

<ul>
<li>假设当前控制器中有三个表视图（UITableView）或者滑动视图(UIScrollView)要切换，把当前显示的滑动视图scrollsToTop属性设置为YES,其他滑动视图的scrollsToTop属性设置为NO即可。</li>
</ul>


<p><strong>注意：如果当前滑动视图中存在子视图也是滑动视图的情况，那么它子视图中的滑动视图scrollsToTop属性也要设置为NO，不然它仍然会造成点击状态栏无法响应返回到顶部操作。</strong></p>

<h6>参考博客地址：</h6>

<ul>
<li><a href="http://blog.sina.com.cn/s/blog_463dc5b90101k9ib.html">点击状态栏不返回顶部问题</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
