<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Others | 杨社兵的技术博客]]></title>
  <link href="http://yangshebing.github.io/blog/categories/others/atom.xml" rel="self"/>
  <link href="http://yangshebing.github.io/"/>
  <updated>2016-05-01T23:08:54+08:00</updated>
  <id>http://yangshebing.github.io/</id>
  <author>
    <name><![CDATA[杨社兵]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS面试题系列之常见算法]]></title>
    <link href="http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-chang-jian-suan-fa/"/>
    <updated>2016-04-24T23:59:06+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-chang-jian-suan-fa</id>
    <content type="html"><![CDATA[<h4>iOS面试中熟悉常见算法</h4>

<p>1、    对以下一组数据进行降序排序（冒泡排序）。“24，17，85，13，9，54，76，45，5，63”</p>

<!--more-->


<pre><code class="">int main(int argc, char *argv[]) {
    int array[10] = {24, 17, 85, 13, 9, 54, 76, 45, 5, 63};
        int num = sizeof(array)/sizeof(int);
        for(int i = 0; i &lt; num-1; i++) {
            for(int j = 0; j &lt; num - 1 - i; j++) {
                    if(array[j] &lt; array[j+1]) {
                            int tmp = array[j];
                                array[j] = array[j+1];
                                array[j+1] = tmp;
                            }
                    }
            }

    for(int i = 0; i &lt; num; i++) {
            printf("%d", array[i]);
                if(i == num-1) {
                    printf("\n");
                    }
                else {
                    printf(" ");
                    }
            }
    }
</code></pre>

<p>2、    对以下一组数据进行升序排序（选择排序）。“86, 37, 56, 29, 92, 73, 15, 63, 30, 8”</p>

<pre><code>
void sort(int a[],int n)
{

    int i, j, index;

    for(i = 0; i &lt; n - 1; i++) {

        index = i;

        for(j = i + 1; j &lt; n; j++) {

            if(a[index] &gt; a[j]) {

                index = j;

            }

        }

        if(index != i) {

            int temp = a[i];

            a[i] = a[index];

            a[index] = temp;

        }

    }

}

int main(int argc, const char * argv[]) {

    int numArr[10] = {86, 37, 56, 29, 92, 73, 15, 63, 30, 8};

    sort(numArr, 10);

    for (int i = 0; i &lt; 10; i++) {

        printf("%d, ", numArr[i]);

    }

    printf("\n");

    return 0;

}
</code></pre>

<p>3、    快速排序算法</p>

<pre><code>void sort(int *a, int left, int right) {
if(left &gt;= right) {
return ;
}
int i = left;
int j = right;
int key = a[left];
while (i &lt; j) {
while (i &lt; j &amp;&amp; key &gt;= a[j]) {
j--;
}
a[i] = a[j];
while (i &lt; j &amp;&amp; key &lt;= a[i]) {
    i++;
    }
a[j] = a[i];
}
a[i] = key;
sort(a, left, i-1);
sort(a, i+1, right);
}
</code></pre>

<p>4、    归并排序</p>

<pre><code>void merge(int sourceArr[], int tempArr[], int startIndex, int midIndex, int endIndex) {
    int i = startIndex;
        int j = midIndex + 1;
        int k = startIndex;
        while (i != midIndex + 1 &amp;&amp; j != endIndex + 1) {
            if (sourceArr[i] &gt;= sourceArr[j]) {
                    tempArr[k++] = sourceArr[j++];
                    } else {
                    tempArr[k++] = sourceArr[i++];
                     }
            }        while (i != midIndex + 1) {
            tempArr[k++] = sourceArr[i++];
            }        while (j != endIndex + 1) {
            tempArr[k++] = sourceArr[j++];
            }        for (i = startIndex; i &lt;= endIndex; i++) {
            sourceArr[i] = tempArr[i];
            }
    }

void sort(int souceArr[], int tempArr[], int startIndex, int endIndex) {
    int midIndex;
        if (startIndex &lt; endIndex) {
            midIndex = (startIndex + endIndex) / 2;
                sort(souceArr, tempArr, startIndex, midIndex);
                sort(souceArr, tempArr, midIndex + 1, endIndex);
                merge(souceArr, tempArr, startIndex, midIndex, endIndex);
            }
    }

int main(int argc, const char * argv[]) {
    int numArr[10] = {86, 37, 56, 29, 92, 73, 15, 63, 30, 8};
        int tempArr[10];
        sort(numArr, tempArr, 0, 9);
        for (int i = 0; i &lt; 10; i++) {
            printf("%d, ", numArr[i]);
            }
        printf("\n");
        return 0;
    }
</code></pre>

<p>5、    实现二分查找算法（编程语言不限）</p>

<pre><code>int bsearchWithoutRecursion(int array[],int low,int high,int target) {
while(low &lt;= high) {
int mid = (low + high) / 2;
if(array[mid] &gt; target)
high = mid - 1;
else if(array[mid] &lt; target)
low = mid + 1;
else    //findthetarget
return mid;
}
//the array does not contain the target
return -1;
}
----------------------------------------
递归实现
int binary_search(const int arr[],int low,int high,int key){
int mid=low + (high - low) / 2;
if(low &gt; high)
return -1;
else{
if(arr[mid] == key)
    return mid;
else if(arr[mid] &gt; key)
return binary_search(arr, low, mid-1, key);
else
return binary_search(arr, mid+1, high, key);
}
}
</code></pre>

<p>6、    如何实现链表翻转（链表逆序）？思路：每次把第二个元素提到最前面来。</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct NODE {
    struct NODE *next;
        int num;
    }node;

node *createLinkList(int length) {
    if (length &lt;= 0) {
            return NULL;
            }
        node *head,*p,*q;
        int number = 1;
        head = (node *)malloc(sizeof(node));
        head-&gt;num = 1;
        head-&gt;next = head;
        p = q = head;
        while (++number &lt;= length) {
            p = (node *)malloc(sizeof(node));
                p-&gt;num = number;
                p-&gt;next = NULL;
                q-&gt;next = p;
                q = p;
            }
        return head;}

void printLinkList(node *head) {
    if (head == NULL) {
            return;
            }
        node *p = head;
        while (p) {
            printf("%d ", p-&gt;num);
                p = p -&gt; next;
            }
        printf("\n");
    }

node *reverseFunc1(node *head) {
    if (head == NULL) {
            return head;

            }

        node *p,*q;
        p = head;
        q = NULL;
        while (p) {
            node *pNext = p -&gt; next;
                p -&gt; next = q;
                q = p;
                p = pNext;
            }
        return q;
    }

int main(int argc, const char * argv[]) {
    node *head = createLinkList(7);
        if (head) {
            printLinkList(head);
                node *reHead = reverseFunc1(head);
                printLinkList(reHead);
                free(reHead);    
    }
        free(head);
        return 0;
    }
</code></pre>

<p>7、    实现一个字符串“how are you”的逆序输出（编程语言不限）。如给定字符串为“hello world”,输出结果应当为“world hello”。</p>

<pre><code>int spliterFunc(char *p) {
    char c[100][100];
        int i = 0;
        int j = 0;

        while (*p != '\0') {
            if (*p == ' ') {
                    i++;
                        j = 0;
                    } else {
                    c[i][j] = *p;
                        j++;
                    }
                p++;    

    }

        for (int k = i; k &gt;= 0; k--) {
            printf("%s", c[k]);
                if (k &gt; 0) {
                    printf(" ");
                    } else {
                    printf("\n");
                        }
            }    return 0;

    }
</code></pre>

<p>8、    给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？如“abaccddeeef”,字符是b,输出应该是2。</p>

<pre><code>
char *strOutPut(char *);

int compareDifferentChar(char, char *);

int main(int argc, const char * argv[]) {    
        char *inputStr = "abaccddeeef";
        char *outputStr = strOutPut(inputStr);
        printf("%c \n", *outputStr);
        return 0;
    }

char *strOutPut(char *s) {
    char str[100];
        char *p = s;
        int index = 0;
        while (*s != '\0') {
            if (compareDifferentChar(*s, p) == 1) {
                    str[index] = *s;
                        index++;
                    }
                s++;
            }
        return &amp;str;}

int compareDifferentChar(char c, char *s) {
    int i = 0;
        while (*s != '\0' &amp;&amp; i&lt;= 1) {
            if (*s == c) {
                    i++;
                    }
                s++;    }
        if (i == 1) {
            return 1;
            } else {
            return 0;
            }
    }
</code></pre>

<p>9、    二叉树的先序遍历为FBACDEGH,中序遍历为：ABDCEFGH,请写出这个二叉树的后序遍历结果。
<strong>ADECBHGF</strong></p>

<ul>
<li>先序+中序遍历还原二叉树：先序遍历是：ABDEGCFH 中序遍历是：DBGEACHF</li>
</ul>


<p>首先从先序得到第一个为A，就是二叉树的根，回到中序，可以将其分为三部分：</p>

<p>左子树的中序序列DBGE，根A，右子树的中序序列CHF
接着将左子树的序列回到先序可以得到B为根，这样回到左子树的中序再次将左子树分割为三部分：
左子树的左子树D，左子树的根B，左子树的右子树GE
同样地，可以得到右子树的根为C
类似地将右子树分割为根C，右子树的右子树HF，注意其左子树为空
如果只有一个就是叶子不用再进行了，刚才的GE和HF再次这样运作，就可以将二叉树还原了。</p>

<p>10、   打印2-100之间的素数。</p>

<pre><code>int main(int argc, const char * argv[]) {
    for (int i = 2; i &lt; 100; i++) {
            int r = isPrime(i);
                if (r == 1) {
                    printf("%ld ", i);
                    }
            }
        return 0;
    }

int isPrime(int n){
    int i, s;
        for(i = 2; i &lt;= sqrt(n); i++)
            if(n % i == 0)  return 0;
            return 1;
    }
</code></pre>

<p>11、   求两个整数的最大公约数。</p>

<pre><code>int gcd(int a, int b) {
    int temp = 0;
        if (a &lt; b) {
            temp = a;
                a = b;
                b = temp;
            }        while (b != 0) {
            temp = a % b;
                a = b;
                b = temp;
            }
        return a;
    }
</code></pre>

<p><strong>本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！</strong></p>

<p><strong>如需转载，请注明出处</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS面试题系列之UI相关]]></title>
    <link href="http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-uiji-chu/"/>
    <updated>2016-04-24T23:58:39+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-uiji-chu</id>
    <content type="html"><![CDATA[<p><strong>1、  简述app启动周期。</strong></p>

<p>打开应用程序，它先会执行main函数，再执行UIApplicationMain函数。初始化
UIApplication，设置代理对象，开启事件循环，调用代理方法进行事件处理。</p>

<p>首先会调用application:didFinishLaunchingWithOptions:代理方法。</p>

<!--more-->


<p>接下来会调用applicationDidBecomeActive:代理方法。监听系统事件，结束程序。当程序正常退出UIApplicationMain函数才会返回。</p>

<p>监听系统事件：</p>

<p>锁屏后app会调用：applicationWillResignActive:代理方法。然后接着调用
applicationDidEnterBackground:方法。</p>

<p>解锁后app会调用：applicationWillEnterForeground:代理方法。接着调用
applicationDidBecomeActive代理方法。</p>

<p>杀死进程会调用：applicationWillTerminate:代理方法。</p>

<p>接听电话：先调用applicationWillResignActive:代理方法。挂断电话后会直接进入
应用调：applicationDidBecomeActive:代理方法。</p>

<p>出现内存警告会调用：applicationDidReceiveMemoryWarning:代理方法</p>

<p><strong>2、  简单的说说UIApplication的作用及继承关系。</strong></p>

<p>（1）UIApplication是继承UIResponder的。UIApplication是整个应用程序的核
心。每一个程序在运行期必须有UIApplication(或子类)的一个实例（有且只有一
个），通过[UIApplication shareApplication]可以得到这个单例实例。</p>

<p>（2）UIApplication帮助管理应用程序的生命周期，通过delegate来履行任务。</p>

<p>（3）UIApplication可以接收事件，把所有用户事件都放入队列，逐个处理。它会发送
当前事件给一个合适的目标控件进行处理。他还将部分事件转给delegate对象来处理。
delegate可以处理的事件包括：应用程序的生命周期事件（如程序启动与关闭）、系统事
件（如来电）。</p>

<p><strong>3、  简述推送消息原理。</strong></p>

<p>（1）应用程序注册接收远程通知的时候，系统会发送请求到APNS服务器。APNS服务器收
到请求后会根据请求所带的key值生成一个独一无二的deviceToken。然后APNS服务器会把deviceToken包装成NSData对象发送到对应请求的App上。接下来APP把deviceToken发送给我们自己的服务器（Provider）。服务器接收到deviceToken后进行存储等相关处理。服务器会把推送给用户的消息发送至APNS服务器，最后APNS服务器再发送通知给app。</p>

<p>（2）有关于deviceToken变化问题：重新安装或卸载应用程序，deviceToken不会发生变化。系统升级deviceToken可能会发生变化。抹掉所有内容和设置，重置设备后，deviceToken会变化</p>

<p>（3）注册远程通知方法注册远程通知：一般在app启动完成的时候注册远程通知，注册方法一般在didFinishLaunchingWithOptions：代理方法中处理注册远程通知回调方法：注册成功会回调didRegisterForRometoNotificationsWithDeviceToken:其中的deviceToken参数就是APNS服务器返回的token。注册失败会回调didFailToRegisterForRemoteNotificationsWithError:</p>

<p>（4）处理接收到的远程通知消息程序启动时，app从Terminate状态进入Foreground状态时，会根据didFinishLaunchingWithOptions:代理方法中的luanchOptions参数来获取userInfo。判断是否有推送消息。方式如下：   // userInfo为收到远程通知的内容NSDictionary*userInfo=launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey];if (userInfo) {   // 有推送的消息，处理推送的消息  }如果app处于Background状态时，只有用户点击了通知消息才会调用didReceiveRemoteNotification:，如果当前app处于Foreground状态，会直接调用该方法。</p>

<p><strong>4、  简单说下UITableView、UIButton、UIWindow控件的继承关系。</strong></p>

<p>（1）UITableView的继承关系：UITableView继承UIScrollView。UIScrollView继承UIView。UIView继承UIResponder。UIResponder继承NSObject。</p>

<p>（2）UIButton的继承关系：UIButton继承UIControl，UIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。</p>

<p>（3）UIWindow继承UIView。</p>

<p><strong>5、  UIView与UIButton有什么区别？UISwitch呢？</strong></p>

<p>UIView继承自UIResponder，它能响应某个动作。UIButton继承UIControl。它不仅可以响应某个动作，还能为某个对象添加对应的动作加以响应。UIButton也能实现UISwitch的功能，它们的区别是分发的事件不一样。</p>

<p><strong>6、  简述UIControl的继承关系，它用来做什么？</strong></p>

<p>UIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。它能为某个特定对象添加事件。能进行事件分发。</p>

<p><strong>7、  简述UIViewController中view的生命周期。</strong></p>

<p>先调用loadView方法，再调用viewDidLoad方法，调用viewWillAppear方法，调用viewWillLayoutSubviews方法，调用viewDidLayoutSubviews方法，再调用viewDidApper方法。控制器消失的时候先调用viewWillDisappear方法，再调用viewDidDisapper方法。最后调用dealloc方法。当出现内存警告的时候会调用didReceiveMemoryWarning方法。</p>

<p><strong>8、  简述UITableView的代理方法调用顺序。</strong></p>

<p>先调用numberOfSectionsInTableView:方法，</p>

<p>numberOfRowsInSection:</p>

<p>heightForRowAtIndexPath:</p>

<p>cellForRowAtIndexPath:</p>

<p><strong>9、  你在用CollectionView的时候有没有遇到什么问题？问题是怎么解决的？</strong></p>

<p>刷新的时候会闪烁。在刷新的时候会默认附加一个隐式的fade动画。可以通过取消动画来达到取消闪烁的目的。</p>

<p><strong>10、 简述UIResponder类的作用。</strong></p>

<p>UIResponder类主要是为那些需要响应并处理事件的对象定义了一组接口。这些事件包括：触摸事件、运动事件、远程控制事件（如耳机控制音视频播放）。当用户触发某一事件时，UIKit会创建一个UIEvent事件对象，事件对象会加入到一个FIFO先进先出的队列中。UIApplication对象处理事件时，会从队列头部取出一个事件对象进行分发。</p>

<p><strong>11、 如何监听View的触摸事件？事件如何传递？简述视图的响应者链。</strong></p>

<p>可以通过View类的touchesBegan、touchesMoved、touchesEnded、touchesCancelled方法监听视图的触摸。
当触摸一个视图对象时，系统会捕捉此事件，并给这个事件创建一个UIEvent对象，将此对象加入当前应用程序的事件队列中，然后由UIApplication对象从队列中取出来进行事件分发，首先会分发给UIWindow对象，然后由UIWindow对象分发给触摸的视图对象，即第一响应者对象。</p>

<p>响应者链：当事件交给第一响应者处理，如果第一响应者不处理，事件就会沿着响应者链向上传递，交给下一个响应者。一般来说，第一响应者是一个视图对象或者是其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象，然后是它的父视图对象，以此类推，直到顶层视图。接下来会沿着顶层视图到UIWindow对象，再到UIApplication对象。如果整个过程都没有响应这个事件，该事件就会被丢弃，一般情况下，在响应者链中只要有对象处理事件，事件就会停止传递。有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。</p>

<p><strong>12、 CALayer与UIView有什么区别？</strong></p>

<p>（1）UIView是iOS系统中界面元素的继承。所有的界面元素都继承自它，他本身完全是由CoreAnimation来实现的。它真正的绘图部分，是由一个叫CALayer的类来管理。UIView本身更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，如frame,bounds等，实际上内部都是在访问它所包含的CALayer的相关属性。</p>

<p>（2）UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示。</p>

<p>（3）UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer。</p>

<p>（4）CALayer坐标系统与UIView有点不一样，它多了一个anchorPoint的属性。</p>

<p>（5）UIView的layer树形在系统内部，被系统维护着三份copy。逻辑树，动画树，显示树。</p>

<p>（6）CALayer默认修改属性支持隐式动画</p>

<p>（7）View可以接受并处理事件，Layer不可以。</p>

<p><strong>13、 如何优化UITableView?</strong></p>

<p>（1）复用单元格</p>

<p>（2）使用不透明的视图，单元格中少使用动画。</p>

<p>（3）图片使用异步加载，设置图片加载的并发数。</p>

<p>（4）滑动时不加载图片，停止滑动时再加载。</p>

<p>（5）图片和文字可以直接drawRect</p>

<p>（6）如果cell是动态行高，计算缓存单元格高度</p>

<p>（7）尽量少reloadData，只reloadRowsAtIndexPaths</p>

<p>（8）cell高度固定直接用rowHeight属性设置高度。</p>

<p><strong>14、 简述加载到控制器上的根视图创建与加载时机。</strong></p>

<p>视图控制器的根视图加载是在UIViewController的loadView方法中。当视图控制中的loadView方法被调用时，会先通过NSBundle加载，通过控制器的类名作为xib文件名加载xib文件，如果存在，加载View为根视图，如果不存在，则自动创建一个View作为根视图。</p>

<p><strong>15、 简述UITableView中cell的复用机制。</strong></p>

<p>UITableView会创建屏幕显示单元格个数（N）+1个单元格，当滑动到第N+2个单元格时就会复用第1个单元格。UITableView中还有单元格复用池的概念。当tableView调用初始化单元格协议方法获取单元格时，它会根据你设定的reuse identifier先去复用池中查找可用的复用单元格，找到则复用该单元格，没找到这创建一个新的单元格对象。</p>

<p><strong>本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！</strong></p>

<p><strong>如需转载，请注明出处</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS面试题系列之Objective-C基础]]></title>
    <link href="http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-zhi-objective-cji-chu/"/>
    <updated>2016-04-24T23:58:04+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-zhi-objective-cji-chu</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native iOS 开发环境搭建]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/21/react-native-ios-kai-fa-huan-jing-da-jian/"/>
    <updated>2016-01-21T01:07:09+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/21/react-native-ios-kai-fa-huan-jing-da-jian</id>
    <content type="html"><![CDATA[<h4>一、React Native基础环境搭建</h4>

<p>1、安装<a href="http://brew.sh">Homebrew</a></p>

<p>打开终端输入：
<code>
ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
</code></p>

<!--more-->


<p>2、安装<a href="https://github.com/creationix/nvm#installation">nvm</a>方法</p>

<p>通过脚本安装方式，在终端执行：
<code>
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.1/install.sh | bash
</code></p>

<p>激活nvm,在安装脚本执行完之后，在终端执行:
<code>
. ~/.nvm/nvm.sh
</code></p>

<p>nvm其他安装方式详见<a href="https://github.com/creationix/nvm#installation">安装向导</a></p>

<p>3、默认安装最新版本的Node.js并且设置好命令行的环境变量
<code>
nvm install node &amp;&amp; nvm alias default node
</code></p>

<p>可以输入node命令启动Node.js环境，npm(node package manager)文档传送门:<a href="https://docs.npmjs.com">&ldquo;点击此处&rdquo;</a></p>

<p>4、安装watchman</p>

<p>在终端输入：
<code>
brew install watchman
</code></p>

<p>到此处React Native基础环境搭建基本完成，推荐经常运行<code>brew update &amp;&amp; brew upgrade</code>命令保持你的程序是最新的。</p>

<h4>二、iOS开发环境</h4>

<p>1、iOS开发环境：（默认读者已经安装<strong>Xcode7.0或以上版本</strong>，没有可自行前往AppStore下载）</p>

<ul>
<li>使用npm（node包管理工具）安装react-native-cli(此处应注意权限问题，如果遇到权限问题，请在下面的命令前加上sudo)</li>
</ul>


<p><code>
npm install -g react-native-cli
</code></p>

<ul>
<li>初始化工程（下面的语句中千万不要加sudo，后果自负）</li>
</ul>


<p><code>
react-native init ReactNativeProject（工程名）
</code></p>

<p>在初始化的过程中，如果进度缓慢，推荐你将npm仓库源换成国内镜像：(翻墙用户请忽略)
在终端输入：</p>

<pre><code>npm config set registry https://registry.npm.taobao.org
npm config set disturl https://npm.taobao.org/dist
</code></pre>

<p>2、使用Xcode运行调试程序</p>

<ul>
<li>查找ReactNativeProject文件目录</li>
</ul>


<p>按住快捷键<code>Command+Shift+G</code>，在弹出的“前往文件夹”对话框中输入路径<code>/Users/yangshebing/ReactNativeProject</code>（yangshebing表示电脑用户名，请自行更改）,点击前往。在文件目中的ios文件夹下找到“ReactNativeProject.xcodeproj”工程文件。如图所示：（有关终端查找该文件目录方法，请自行到文章末尾的参考文章中寻找）
<img src="http://ww4.sinaimg.cn/large/7f266405jw1f0651k88wij216s0oa42t.jpg" alt="" /></p>

<ul>
<li>运行ReactNativeProject工程</li>
</ul>


<p>使用Xcode打开“ReactNativeProject.xcodeproj”工程文件，按住快捷键"Command+R"运行此项目，运行成功后便可在模拟器上看到效果。</p>

<ul>
<li>编辑index.ios.js文件修改界面</li>
</ul>


<p>笔者编辑index.ios.js文件工具是Vim，每当编辑完index.ios.js文件并保存之后，在模拟器(Simulator)中，按<code>Command+R</code>可刷新界面查看改变后的效果。</p>

<p>下面我们也试着稍微修改一下index.ios.js文件：</p>

<pre><code>/**
 * Sample React Native App
 * https://github.com/facebook/react-native
 */
'use strict';
import React, {
  AppRegistry,
  Component,
  StyleSheet,
  //添加Image全局变量
  Image,
  Text,
  View
} from 'react-native';

class ReactNativeProject extends Component {
  render() {
    return (
      &lt;View style={styles.container}&gt;
      //添加文本展示
        &lt;Text style={styles.welcome}&gt;
          美女
        &lt;/Text&gt;
        //添加图片展示
        &lt;Image 
        source= 
        //这里需要指定图片的大小
        style={styles.picture} /&gt;
      &lt;/View&gt;
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5FCFF',
  },
  //这里可以设置文本的字体，对齐方式等
  welcome: {
    fontSize: 20,
    textAlign: 'center',
    margin: 10,
  },
  //新增图片style，设置图片大小
  picture: {
    width: 80,
    height: 150,
  },
});

AppRegistry.registerComponent('ReactNativeProject', () =&gt; ReactNativeProject);
</code></pre>

<p>刷新后运行效果如下图所示：
<img src="http://ww3.sinaimg.cn/mw690/7f266405jw1f06flkcxxgj20ku12a3zr.jpg" alt="" /></p>

<ul>
<li>真机运行调试项目</li>
</ul>


<p>在<code>ReactNativeProject</code>工程中找到AppDelegate.m文件，将<code>localhost</code>替换成自己电脑的IP地址。</p>

<pre><code>//  jsCodeLocation = [NSURL URLWithString:@"http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true"];

  jsCodeLocation = [NSURL URLWithString:@"http://192.168.31.168:8081/index.ios.bundle?platform=ios&amp;dev=true"];
</code></pre>

<p>替换完成之后再次运行程序，这个时候可以通过摇晃设备唤出开发菜单。</p>

<ul>
<li>禁用开发菜单</li>
</ul>


<p>在打包提交市场前，需要禁用开发菜单。禁用开发菜单方法如下：
打开工程，选择<code>Product → Scheme → Edit Scheme</code>或使用快捷键“Command + &lt;”,在弹出的窗口中选择左边的Run菜单项。更改“Build Configuration” 设置项为“Release”。
<img src="http://ww1.sinaimg.cn/large/7f266405jw1f06e3sf5qjj21ds0s0tc2.jpg" alt="" /></p>

<h4>三、参考资料地址：</h4>

<ul>
<li><a href="https://facebook.github.io/react-native/docs/tutorial.html">React Native开发指南英文版（官方）</a></li>
<li><a href="http://reactnative.cn/docs/getting-started.html#content">React Native开发指南中文版</a></li>
<li><a href="http://www.cnblogs.com/meteoric_cry/p/4862314.html">React Native入门遇到的一些问题</a></li>
</ul>


<p><strong>此文仅供学习交流，转载请注明出处！</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015年终总结]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/01/2015nian-zhong-zong-jie/"/>
    <updated>2016-01-01T13:26:26+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/01/2015nian-zhong-zong-jie</id>
    <content type="html"><![CDATA[<h4>总结：</h4>

<p>回首过去一年，好像没有什么能说出口的成绩，专业没啥进步。在公司做了两款App，上半年主要开发的是一款叫“在线等”的手机应用，这是一款解决人们选择困难症的应用，经过重重困难，最终上线。没啥成绩可言。下半年主要研发的是一款叫“斗图神器”的应用，由于Android版早就开发好了，所以iOS版开发起来就快很多了。总的来说成绩还不错，其中也有点小波折。<!--more-->现在已经提交过3，4版了。目前“斗图神器”项目已经引入了全新的Swift语言与Objective-C语言混编。目的是拥抱Swift，它才是未来。这对我们来说是好事，有项目环境学习新语言就更快了。现在我还是处于Swift 初级入门阶段，明年希望能进一步提高吧！在学习方面，搭建了自己的<a href="http://yangshebing.github.io"><strong>个人技术博客</strong></a>，另外还写了几篇质量不高的博文，在github上放了几个质量不高的demo。买了手机和电脑，这也算专业学习上的投入吧。生活上，除了每天写写代码，并没有什么其他变化。4月份去了一趟泰山，7月份去了一次十渡，10月份游了半个北京（虽然来北京久了，却很少出去）顺带去了一趟天津。今年最大的事情就是拔了一颗智齿和一颗蛀牙，花了不少钱，现在都没弄好！折腾了半条命（太背），一直不太顺。其次就是大病没犯，小病不断，北京这边雾霾比较严重。咽炎也挺折腾人的。本来年底是计划上线一款自己的app,由于各种借口各种拖最终没能实现，也没啥可遗憾的，主要是自己没有努力。其实还计划学习一门除专业外的语言，这个计划也耽搁了！计划内的写一个插件，现在也还没开动！专业书今年没有仔细读过，其实应该多读几本。扩展书籍就读过《高效能人士的7个习惯》与《从0到1》。总而言之就是读的书还是太少，平常大部分时间是在网上看别人的博客学习，看官方文档，不会的就自己用google搜索。人丑就要多读书。越来越不会说话了，已经想不起还有什么要说的了，那就先写到这吧！共勉！
2016的计划与展望：</p>

<h4>计划：</h4>

<ul>
<li>1、  读10本以上的专业相关的书籍，扩展阅读书籍不少于5本。</li>
<li>2、  学一门专业外的语言</li>
<li>3、  在github上开源5个项目（高质量）</li>
<li>4、  博客不少于50篇博文（高质量）</li>
<li>5、  找个女盆友</li>
<li>6、  福利计划：去国外旅游一次（条件如下）</li>
</ul>


<pre><code>if plan five implement {
        implement plan six
} else {
        nothing happened
}
</code></pre>

<h4>展望：</h4>

<p>马上迎来全新的2016年，又是一个全新的开始。时间匆匆，趁着年轻就要好好努力，物尽其用。希望在新的一年里，事业蒸蒸日上，身体健健康康（身体是革命的本钱，是实现计划的基石），愿家人幸福安康。</p>
]]></content>
  </entry>
  
</feed>
