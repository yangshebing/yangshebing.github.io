<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Others | 杨社兵的技术博客]]></title>
  <link href="http://yangshebing.github.io/blog/categories/others/atom.xml" rel="self"/>
  <link href="http://yangshebing.github.io/"/>
  <updated>2016-04-25T01:43:11+08:00</updated>
  <id>http://yangshebing.github.io/</id>
  <author>
    <name><![CDATA[杨社兵]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS面试题系列之常见算法]]></title>
    <link href="http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-chang-jian-suan-fa/"/>
    <updated>2016-04-24T23:59:06+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-chang-jian-suan-fa</id>
    <content type="html"><![CDATA[<h4>iOS面试中熟悉常见算法</h4>

<p>1、    对以下一组数据进行降序排序（冒泡排序）。“24，17，85，13，9，54，76，45，5，63”</p>

<!--more-->


<pre><code class="">int main(int argc, char *argv[]) {  int array[10] = {24, 17, 85, 13, 9, 54, 76, 45, 5, 63}; int num = sizeof(array)/sizeof(int);    for(int i = 0; i &lt; num-1; i++) {        for(int j = 0; j &lt; num - 1 - i; j++) {          if(array[j] &lt; array[j+1]) {             int tmp = array[j];             array[j] = array[j+1];              array[j+1] = tmp;           }       }   }   for(int i = 0; i &lt; num; i++) {      printf("%d", array[i]);     if(i == num-1) {            printf("\n");       }       else {          printf(" ");        }   }}
</code></pre>

<p>2、    对以下一组数据进行升序排序（选择排序）。“86, 37, 56, 29, 92, 73, 15, 63, 30, 8”</p>

<pre><code>
void sort(int a[],int n)
{
    int i, j, index;
    for(i = 0; i &lt; n - 1; i++) {

        index = i;

        for(j = i + 1; j &lt; n; j++) {
            if(a[index] &gt; a[j])
            {
                index = j;
            }
        }

        if(index != i) {
            int temp = a[i];
            a[i] = a[index];
            a[index] = temp;
        }
    }
}

int main(int argc, const char * argv[]) {
    int numArr[10] = {86, 37, 56, 29, 92, 73, 15, 63, 30, 8};
    sort(numArr, 10);
    for (int i = 0; i &lt; 10; i++) {
        printf("%d, ", numArr[i]);
    }
    printf("\n");
    return 0;
}
</code></pre>

<p>3、    快速排序算法</p>

<pre><code>void sort(int *a, int left, int right) {if(left &gt;= right) {return ;}int i = left;int j = right;int key = a[left];while (i &lt; j) {while (i &lt; j &amp;&amp; key &gt;= a[j]) {j--;}a[i] = a[j];while (i &lt; j &amp;&amp; key &lt;= a[i]) {   i++;}a[j] = a[i];}a[i] = key;sort(a, left, i-1);sort(a, i+1, right);}
</code></pre>

<p>4、    归并排序</p>

<pre><code>void merge(int sourceArr[], int tempArr[], int startIndex, int midIndex, int endIndex) {    int i = startIndex;    int j = midIndex + 1;    int k = startIndex;    while (i != midIndex + 1 &amp;&amp; j != endIndex + 1) {        if (sourceArr[i] &gt;= sourceArr[j]) {            tempArr[k++] = sourceArr[j++];        } else {            tempArr[k++] = sourceArr[i++];        }    }        while (i != midIndex + 1) {        tempArr[k++] = sourceArr[i++];    }        while (j != endIndex + 1) {        tempArr[k++] = sourceArr[j++];    }        for (i = startIndex; i &lt;= endIndex; i++) {        sourceArr[i] = tempArr[i];    }}void sort(int souceArr[], int tempArr[], int startIndex, int endIndex) {    int midIndex;    if (startIndex &lt; endIndex) {        midIndex = (startIndex + endIndex) / 2;        sort(souceArr, tempArr, startIndex, midIndex);        sort(souceArr, tempArr, midIndex + 1, endIndex);        merge(souceArr, tempArr, startIndex, midIndex, endIndex);    }}int main(int argc, const char * argv[]) {    int numArr[10] = {86, 37, 56, 29, 92, 73, 15, 63, 30, 8};    int tempArr[10];    sort(numArr, tempArr, 0, 9);    for (int i = 0; i &lt; 10; i++) {        printf("%d, ", numArr[i]);    }    printf("\n");    return 0;}
</code></pre>

<p>5、    实现二分查找算法（编程语言不限）</p>

<pre><code>int bsearchWithoutRecursion(int array[],int low,int high,int target){while(low &lt;= high){int mid = (low + high) / 2;if(array[mid] &gt; target)high = mid - 1;else if(array[mid] &lt; target)low = mid + 1;else//findthetargetreturn mid;}//the array does not contain the targetreturn -1;}----------------------------------------递归实现int binary_search(const int arr[],int low,int high,int key){int mid=low + (high - low) / 2;if(low &gt; high)return -1;else{if(arr[mid] == key)return mid;else if(arr[mid] &gt; key)return binary_search(arr, low, mid-1, key);elsereturn binary_search(arr, mid+1, high, key);}}
</code></pre>

<p>6、    如何实现链表翻转（链表逆序）？思路：每次把第二个元素提到最前面来。</p>

<pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct NODE {    struct NODE *next;    int num;}node;node *createLinkList(int length) {    if (length &lt;= 0) {        return NULL;    }    node *head,*p,*q;    int number = 1;    head = (node *)malloc(sizeof(node));    head-&gt;num = 1;    head-&gt;next = head;    p = q = head;    while (++number &lt;= length) {        p = (node *)malloc(sizeof(node));        p-&gt;num = number;        p-&gt;next = NULL;        q-&gt;next = p;        q = p;    }    return head;}void printLinkList(node *head) {    if (head == NULL) {        return;    }    node *p = head;    while (p) {        printf("%d ", p-&gt;num);        p = p -&gt; next;    }    printf("\n");}node *reverseFunc1(node *head) {    if (head == NULL) {        return head;    }    node *p,*q;    p = head;    q = NULL;    while (p) {        node *pNext = p -&gt; next;        p -&gt; next = q;        q = p;        p = pNext;    }    return q;}int main(int argc, const char * argv[]) {    node *head = createLinkList(7);    if (head) {        printLinkList(head);        node *reHead = reverseFunc1(head);        printLinkList(reHead);        free(reHead);    }    free(head);    return 0;}
</code></pre>

<p>7、    实现一个字符串“how are you”的逆序输出（编程语言不限）。如给定字符串为“hello world”,输出结果应当为“world hello”。</p>

<pre><code>int spliterFunc(char *p) {    char c[100][100];    int i = 0;    int j = 0;    while (*p != '\0') {        if (*p == ' ') {            i++;            j = 0;        } else {            c[i][j] = *p;            j++;        }        p++;    }    for (int k = i; k &gt;= 0; k--) {        printf("%s", c[k]);        if (k &gt; 0) {            printf(" ");        } else {            printf("\n");          }    }    return 0;}
</code></pre>

<p>8、    给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？如“abaccddeeef”,字符是b,输出应该是2。</p>

<pre><code>
char *strOutPut(char *);int compareDifferentChar(char, char *);int main(int argc, const char * argv[]) {        char *inputStr = "abaccddeeef";    char *outputStr = strOutPut(inputStr);    printf("%c \n", *outputStr);    return 0;}char *strOutPut(char *s) {    char str[100];    char *p = s;    int index = 0;    while (*s != '\0') {        if (compareDifferentChar(*s, p) == 1) {            str[index] = *s;            index++;        }        s++;    }    return &amp;str;}int compareDifferentChar(char c, char *s) {    int i = 0;    while (*s != '\0' &amp;&amp; i&lt;= 1) {        if (*s == c) {            i++;        }        s++;    }    if (i == 1) {        return 1;    } else {        return 0;    }}
</code></pre>

<p>9、    二叉树的先序遍历为FBACDEGH,中序遍历为：ABDCEFGH,请写出这个二叉树的后序遍历结果。
<strong>ADECBHGF</strong></p>

<ul>
<li>先序+中序遍历还原二叉树：先序遍历是：ABDEGCFH 中序遍历是：DBGEACHF</li>
</ul>


<p>首先从先序得到第一个为A，就是二叉树的根，回到中序，可以将其分为三部分：</p>

<p>左子树的中序序列DBGE，根A，右子树的中序序列CHF
接着将左子树的序列回到先序可以得到B为根，这样回到左子树的中序再次将左子树分割为三部分：
左子树的左子树D，左子树的根B，左子树的右子树GE
同样地，可以得到右子树的根为C
类似地将右子树分割为根C，右子树的右子树HF，注意其左子树为空
如果只有一个就是叶子不用再进行了，刚才的GE和HF再次这样运作，就可以将二叉树还原了。</p>

<p>10、   打印2-100之间的素数。</p>

<pre><code>int main(int argc, const char * argv[]) {    for (int i = 2; i &lt; 100; i++) {        int r = isPrime(i);        if (r == 1) {            printf("%ld ", i);        }    }    return 0;}
int isPrime(int n){    int i, s;    for(i = 2; i &lt;= sqrt(n); i++)        if(n % i == 0)  return 0;    return 1;}
</code></pre>

<p>11、   求两个整数的最大公约数。</p>

<pre><code>int gcd(int a, int b) {    int temp = 0;    if (a &lt; b) {        temp = a;        a = b;        b = temp;    }        while (b != 0) {        temp = a % b;        a = b;        b = temp;    }    return a;}
</code></pre>

<p><strong>本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！</strong></p>

<p><strong>如需转载，请注明出处</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS面试题系列之UI基础]]></title>
    <link href="http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-uiji-chu/"/>
    <updated>2016-04-24T23:58:39+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-uiji-chu</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS面试题系列之Objective-C基础]]></title>
    <link href="http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-zhi-objective-cji-chu/"/>
    <updated>2016-04-24T23:58:04+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/04/24/iosmian-shi-ti-zhi-objective-cji-chu</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native iOS 开发环境搭建]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/21/react-native-ios-kai-fa-huan-jing-da-jian/"/>
    <updated>2016-01-21T01:07:09+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/21/react-native-ios-kai-fa-huan-jing-da-jian</id>
    <content type="html"><![CDATA[<h4>一、React Native基础环境搭建</h4>

<p>1、安装<a href="http://brew.sh">Homebrew</a></p>

<p>打开终端输入：
<code>
ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
</code></p>

<p>2、安装<a href="https://github.com/creationix/nvm#installation">nvm</a>方法</p>

<p>通过脚本安装方式，在终端执行：
<code>
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.1/install.sh | bash
</code></p>

<p>激活nvm,在安装脚本执行完之后，在终端执行:
<code>
. ~/.nvm/nvm.sh
</code></p>

<p>nvm其他安装方式详见<a href="https://github.com/creationix/nvm#installation">安装向导</a></p>

<p>3、默认安装最新版本的Node.js并且设置好命令行的环境变量
<code>
nvm install node &amp;&amp; nvm alias default node
</code></p>

<p>可以输入node命令启动Node.js环境，npm(node package manager)文档传送门:<a href="https://docs.npmjs.com">&ldquo;点击此处&rdquo;</a></p>

<p>4、安装watchman</p>

<p>在终端输入：
<code>
brew install watchman
</code></p>

<p>到此处React Native基础环境搭建基本完成，推荐经常运行<code>brew update &amp;&amp; brew upgrade</code>命令保持你的程序是最新的。</p>

<h4>二、iOS开发环境</h4>

<!--more-->


<p>1、iOS开发环境：（默认读者已经安装<strong>Xcode7.0或以上版本</strong>，没有可自行前往AppStore下载）</p>

<ul>
<li>使用npm（node包管理工具）安装react-native-cli(此处应注意权限问题，如果遇到权限问题，请在下面的命令前加上sudo)</li>
</ul>


<p><code>
npm install -g react-native-cli
</code></p>

<ul>
<li>初始化工程（下面的语句中千万不要加sudo，后果自负）</li>
</ul>


<p><code>
react-native init ReactNativeProject（工程名）
</code></p>

<p>在初始化的过程中，如果进度缓慢，推荐你将npm仓库源换成国内镜像：(翻墙用户请忽略)
在终端输入：</p>

<pre><code>npm config set registry https://registry.npm.taobao.org
npm config set disturl https://npm.taobao.org/dist
</code></pre>

<p>2、使用Xcode运行调试程序</p>

<ul>
<li>查找ReactNativeProject文件目录</li>
</ul>


<p>按住快捷键<code>Command+Shift+G</code>，在弹出的“前往文件夹”对话框中输入路径<code>/Users/yangshebing/ReactNativeProject</code>（yangshebing表示电脑用户名，请自行更改）,点击前往。在文件目中的ios文件夹下找到“ReactNativeProject.xcodeproj”工程文件。如图所示：（有关终端查找该文件目录方法，请自行到文章末尾的参考文章中寻找）
<img src="http://ww4.sinaimg.cn/large/7f266405jw1f0651k88wij216s0oa42t.jpg" alt="" /></p>

<ul>
<li>运行ReactNativeProject工程</li>
</ul>


<p>使用Xcode打开“ReactNativeProject.xcodeproj”工程文件，按住快捷键"Command+R"运行此项目，运行成功后便可在模拟器上看到效果。</p>

<ul>
<li>编辑index.ios.js文件修改界面</li>
</ul>


<p>笔者编辑index.ios.js文件工具是Vim，每当编辑完index.ios.js文件并保存之后，在模拟器(Simulator)中，按<code>Command+R</code>可刷新界面查看改变后的效果。</p>

<p>下面我们也试着稍微修改一下index.ios.js文件：</p>

<pre><code>/**
 * Sample React Native App
 * https://github.com/facebook/react-native
 */
'use strict';
import React, {
  AppRegistry,
  Component,
  StyleSheet,
  //添加Image全局变量
  Image,
  Text,
  View
} from 'react-native';

class ReactNativeProject extends Component {
  render() {
    return (
      &lt;View style={styles.container}&gt;
      //添加文本展示
        &lt;Text style={styles.welcome}&gt;
          美女
        &lt;/Text&gt;
        //添加图片展示
        &lt;Image 
        source= 
        //这里需要指定图片的大小
        style={styles.picture} /&gt;
      &lt;/View&gt;
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5FCFF',
  },
  //这里可以设置文本的字体，对齐方式等
  welcome: {
    fontSize: 20,
    textAlign: 'center',
    margin: 10,
  },
  //新增图片style，设置图片大小
  picture: {
    width: 80,
    height: 150,
  },
});

AppRegistry.registerComponent('ReactNativeProject', () =&gt; ReactNativeProject);
</code></pre>

<p>刷新后运行效果如下图所示：
<img src="http://ww3.sinaimg.cn/mw690/7f266405jw1f06flkcxxgj20ku12a3zr.jpg" alt="" /></p>

<ul>
<li>真机运行调试项目</li>
</ul>


<p>在<code>ReactNativeProject</code>工程中找到AppDelegate.m文件，将<code>localhost</code>替换成自己电脑的IP地址。</p>

<pre><code>//  jsCodeLocation = [NSURL URLWithString:@"http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true"];

  jsCodeLocation = [NSURL URLWithString:@"http://192.168.31.168:8081/index.ios.bundle?platform=ios&amp;dev=true"];
</code></pre>

<p>替换完成之后再次运行程序，这个时候可以通过摇晃设备唤出开发菜单。</p>

<ul>
<li>禁用开发菜单</li>
</ul>


<p>在打包提交市场前，需要禁用开发菜单。禁用开发菜单方法如下：
打开工程，选择<code>Product → Scheme → Edit Scheme</code>或使用快捷键“Command + &lt;”,在弹出的窗口中选择左边的Run菜单项。更改“Build Configuration” 设置项为“Release”。
<img src="http://ww1.sinaimg.cn/large/7f266405jw1f06e3sf5qjj21ds0s0tc2.jpg" alt="" /></p>

<h4>三、参考资料地址：</h4>

<ul>
<li><a href="https://facebook.github.io/react-native/docs/tutorial.html">React Native开发指南英文版（官方）</a></li>
<li><a href="http://reactnative.cn/docs/getting-started.html#content">React Native开发指南中文版</a></li>
<li><a href="http://www.cnblogs.com/meteoric_cry/p/4862314.html">React Native入门遇到的一些问题</a></li>
</ul>


<p><strong>此文仅供学习交流，转载请注明出处！</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015年终总结]]></title>
    <link href="http://yangshebing.github.io/blog/2016/01/01/2015nian-zhong-zong-jie/"/>
    <updated>2016-01-01T13:26:26+08:00</updated>
    <id>http://yangshebing.github.io/blog/2016/01/01/2015nian-zhong-zong-jie</id>
    <content type="html"><![CDATA[<h4>总结：</h4>

<p>回首过去一年，好像没有什么能说出口的成绩，专业没啥进步。在公司做了两款App，上半年主要开发的是一款叫“在线等”的手机应用，这是一款解决人们选择困难症的应用，经过重重困难，最终上线。没啥成绩可言。下半年主要研发的是一款叫“斗图神器”的应用，由于Android版早就开发好了，所以iOS版开发起来就快很多了。总的来说成绩还不错，其中也有点小波折。<!--more-->现在已经提交过3，4版了。目前“斗图神器”项目已经引入了全新的Swift语言与Objective-C语言混编。目的是拥抱Swift，它才是未来。这对我们来说是好事，有项目环境学习新语言就更快了。现在我还是处于Swift 初级入门阶段，明年希望能进一步提高吧！在学习方面，搭建了自己的<a href="http://yangshebing.github.io"><strong>个人技术博客</strong></a>，另外还写了几篇质量不高的博文，在github上放了几个质量不高的demo。买了手机和电脑，这也算专业学习上的投入吧。生活上，除了每天写写代码，并没有什么其他变化。4月份去了一趟泰山，7月份去了一次十渡，10月份游了半个北京（虽然来北京久了，却很少出去）顺带去了一趟天津。今年最大的事情就是拔了一颗智齿和一颗蛀牙，花了不少钱，现在都没弄好！折腾了半条命（太背），一直不太顺。其次就是大病没犯，小病不断，北京这边雾霾比较严重。咽炎也挺折腾人的。本来年底是计划上线一款自己的app,由于各种借口各种拖最终没能实现，也没啥可遗憾的，主要是自己没有努力。其实还计划学习一门除专业外的语言，这个计划也耽搁了！计划内的写一个插件，现在也还没开动！专业书今年没有仔细读过，其实应该多读几本。扩展书籍就读过《高效能人士的7个习惯》与《从0到1》。总而言之就是读的书还是太少，平常大部分时间是在网上看别人的博客学习，看官方文档，不会的就自己用google搜索。人丑就要多读书。越来越不会说话了，已经想不起还有什么要说的了，那就先写到这吧！共勉！
2016的计划与展望：</p>

<h4>计划：</h4>

<ul>
<li>1、  读10本以上的专业相关的书籍，扩展阅读书籍不少于5本。</li>
<li>2、  学一门专业外的语言</li>
<li>3、  在github上开源5个项目（高质量）</li>
<li>4、  博客不少于50篇博文（高质量）</li>
<li>5、  找个女盆友</li>
<li>6、  福利计划：去国外旅游一次（条件如下）</li>
</ul>


<pre><code>if plan five implement {
        implement plan six
} else {
        nothing happened
}
</code></pre>

<h4>展望：</h4>

<p>马上迎来全新的2016年，又是一个全新的开始。时间匆匆，趁着年轻就要好好努力，物尽其用。希望在新的一年里，事业蒸蒸日上，身体健健康康（身体是革命的本钱，是实现计划的基石），愿家人幸福安康。</p>
]]></content>
  </entry>
  
</feed>
