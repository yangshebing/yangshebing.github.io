{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"c77dc0fd5f45364a252301d10040458eab6554d6","modified":1473478594000},{"_id":"themes/maupassant/README.md","hash":"75d8c42569809961953d1934de445418c00ab94c","modified":1470636284000},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1470636284000},{"_id":"themes/maupassant/LICENSE","hash":"019dc6a9aba02ae3aaabca45f39aecd6e8e7f1d8","modified":1470636284000},{"_id":"themes/maupassant/_config.yml","hash":"70b048a4cbf3beeb9c14183b442ac23798dd9cfe","modified":1473485091000},{"_id":"themes/maupassant/package.json","hash":"81fb4e2ac051ecfb9a93f37b28910291b939771a","modified":1470636284000},{"_id":"source/_posts/2015-09-12-swift.markdown","hash":"c6979f7b909618bdf37b3abd63366e8ce3dc6de5","modified":1473484588000},{"_id":"source/_posts/2015-09-13-arcticle.markdown","hash":"4a992e6623e42e328fbaad984735f4076a05a13e","modified":1473484605000},{"_id":"source/_posts/2015-09-12-test.markdown","hash":"0e6910f86d382aae54131cafa1c8f8339b40150a","modified":1473484596000},{"_id":"source/_posts/.DS_Store","hash":"8163e4a7c584215960abbffea754f7a7215b933b","modified":1473484806000},{"_id":"source/_posts/2015-11-03-waterflow.markdown","hash":"17218f6c45857c354a5564f665a38280ae8219ba","modified":1473484630000},{"_id":"source/_posts/2015-09-17-test.markdown","hash":"188489e779342bde05d24af6b227d608f99c9785","modified":1473484616000},{"_id":"source/_posts/2015-11-16-ios-ffmpegbian-yi-ji-kxmovie,-iframeextractordiao-shi-xiang-jie-(wu-zhang-ai-yue-du-,jue-dui-shi-ni-xiang-yao-de-).markdown","hash":"6788fee4e51ae711710ca3f96927a84ae1371887","modified":1473484636000},{"_id":"source/_posts/2015-10-12-ioshui-zhi-xu-xian-fang-shi-zong-jie.markdown","hash":"ff4d0118eb97d23a6f5a60ae522a54f9218c7e98","modified":1473484623000},{"_id":"source/_posts/2016-01-04-swiftzhong-uitableviewde-yong-fa-zi-ding-yi-uitableviewhe-uitableviewcell.markdown","hash":"58f0fb310c7a13c3f14de3aab13ee7ceb7782dc6","modified":1473484663000},{"_id":"source/_posts/2016-01-01-2015nian-zhong-zong-jie.markdown","hash":"991919fdd72b0c3419d796a06bf7ce3b45d5f719","modified":1473484646000},{"_id":"source/_posts/2016-01-15-swiftnei-cun-guan-li-(arc)zhi-xun-huan-yin-yong.markdown","hash":"cc3b755b66afa963d834381dd2f679a4cad9a42e","modified":1473484671000},{"_id":"source/_posts/2016-01-02-ioskai-fa-zhi-ji-chu-kong-jian-(swiftban-).markdown","hash":"ac5cf3ae67cdae55ca5b1df1a297365d1013afe3","modified":1473484653000},{"_id":"source/_posts/2016-04-24-iosmian-shi-ti-xi-lie-zhi-chang-jian-suan-fa.markdown","hash":"57fdaa12e4b20fe4f06c684b688fde38a7358d9d","modified":1473484684000},{"_id":"source/_posts/2016-04-24-iosmian-shi-ti-xi-lie-zhi-uiji-chu.markdown","hash":"3dcbbebcef115fd1cdc1da100799734d6a914dbd","modified":1473484690000},{"_id":"source/_posts/2016-04-24-iosmian-shi-ti-zhi-objective-cji-chu.markdown","hash":"2f4c830b4564abd7eafe7806eb45dd98925867a8","modified":1473484696000},{"_id":"source/_posts/2016-01-21-react-native-ios-kai-fa-huan-jing-da-jian.markdown","hash":"6b73dfd94c1878e114fb7edc7b5acc5aa604045b","modified":1473484677000},{"_id":"source/_posts/2016-05-09-swift2-dot-2xin-te-xing.markdown","hash":"7246a262b0314425e716e9fc42169650e2b73a90","modified":1473484702000},{"_id":"source/_posts/2016-05-14-iostu-xing-hui-zhi-coregraphicspian.markdown","hash":"0ce9f87862f1e99d4fd3c1c052f9e3712098ebd1","modified":1473484553000},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1470636284000},{"_id":"themes/maupassant/.git/config","hash":"037345b11c41abb3dbbbd6e0242ced24979a7097","modified":1470636284000},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1470636254000},{"_id":"themes/maupassant/.git/index","hash":"043cbbf4189fd0d66de4bf551d7b830b7b945701","modified":1473476705000},{"_id":"source/_posts/2016-05-14-iostu-xing-hui-zhi-uibezierpathpian.markdown","hash":"bf1f865823b6d8414307e49bedf830606b4e733f","modified":1473484715000},{"_id":"themes/maupassant/.git/packed-refs","hash":"53e4275068b4dbaa003c4f6e8f4eeaa4ed2360d0","modified":1470636284000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1470636284000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1470636284000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1470636284000},{"_id":"themes/maupassant/languages/en.yml","hash":"e13ab1a2d2f1edbe67b4c035fd4667cb6a31db8e","modified":1470636284000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"ebacfa5d0c14d603e0d505757adb24c0bbe5dd13","modified":1470636284000},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1470636284000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"56b65995c60e99dcebbf00168447fd225d28e5b2","modified":1470636284000},{"_id":"themes/maupassant/layout/base.jade","hash":"852c610ac392ef2fa130dbe73bcf4f96f423c869","modified":1470636284000},{"_id":"themes/maupassant/layout/base-without-sidebar.jade","hash":"1ad721de96784bf4253316b796db6200148d4152","modified":1470636284000},{"_id":"themes/maupassant/layout/archive.jade","hash":"0050c883b4f202add71c8664d65e6072179e7190","modified":1470636284000},{"_id":"themes/maupassant/layout/index.jade","hash":"7466ce52023ed8a413a6b4461354a9e20e62fc14","modified":1470636284000},{"_id":"themes/maupassant/layout/single-column.jade","hash":"c35fff4d9b331a41af5bc10f4278ec3d9da503db","modified":1470636284000},{"_id":"themes/maupassant/layout/post.jade","hash":"9cf29fb0daed95935154ce0fa2b154df5a9b11b1","modified":1470636284000},{"_id":"themes/maupassant/layout/page.jade","hash":"8d70fd3b93f2c9087a9ea7ec538dcc1d413bea01","modified":1470636284000},{"_id":"themes/maupassant/layout/timeline.jade","hash":"f03d8df63a188543cfe4e85e76194abe081411a1","modified":1470636284000},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1470636254000},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1470636254000},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1470636254000},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1470636254000},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1470636254000},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1470636254000},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1470636254000},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1470636254000},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1470636254000},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1470636254000},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"8faf09f90b781f9ee7efa547b3feacd028606a04","modified":1470636284000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1470636284000},{"_id":"themes/maupassant/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1470636284000},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1470636284000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1470636284000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1470636284000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1470636284000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1470636284000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1470636284000},{"_id":"themes/maupassant/source/js/search.js","hash":"53db2eb255dd40a412ed62ea7332ca5a22f7816f","modified":1470636284000},{"_id":"themes/maupassant/source/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1470636284000},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1470636284000},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1470636284000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1470636284000},{"_id":"themes/maupassant/source/css/style.scss","hash":"158f1ebecf7b994ffae5332a627465f6bf38113b","modified":1470636284000},{"_id":"themes/maupassant/layout/_widget/category.jade","hash":"a52957872c86ab5af504e54a8b9558ae9ee8372f","modified":1473473355000},{"_id":"themes/maupassant/layout/_widget/recent_comments.jade","hash":"e119c5afa85abc60d139e2da99b0bfcd7a6530f8","modified":1470636284000},{"_id":"themes/maupassant/layout/_widget/tag.jade","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1470636284000},{"_id":"themes/maupassant/layout/_widget/recent_posts.jade","hash":"8b4f62ff0ebbae744dce40f7dffc781f3a4e801f","modified":1473473437000},{"_id":"themes/maupassant/layout/_widget/search.jade","hash":"658e92c054eecf15cbe61576f5c6985789d8d430","modified":1473473650000},{"_id":"themes/maupassant/layout/_partial/mathjax.jade","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1470636284000},{"_id":"themes/maupassant/layout/_partial/comments.jade","hash":"6c7f63ba04a4d28323ba31e79a4927f3d3fcc56e","modified":1470636284000},{"_id":"themes/maupassant/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1470636284000},{"_id":"themes/maupassant/layout/_partial/footer.jade","hash":"aa020b794e697e8e9612530c97c6295efde469fe","modified":1470636284000},{"_id":"themes/maupassant/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1470636284000},{"_id":"themes/maupassant/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1470636284000},{"_id":"themes/maupassant/layout/_partial/mathjax2.jade","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1470636284000},{"_id":"themes/maupassant/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1470636284000},{"_id":"themes/maupassant/layout/_partial/after_footer.jade","hash":"3dbcc9a9f0d6e55da191d3393c18bbfcfe99fa69","modified":1470636284000},{"_id":"themes/maupassant/layout/_widget/links.jade","hash":"514205db5833a4b123691fb6b77193361af13c1c","modified":1473473400000},{"_id":"themes/maupassant/layout/_partial/totop.jade","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1470636284000},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"9138f76c9461186fe7e14add27270f388fdabe2f","modified":1470636284000},{"_id":"themes/maupassant/.git/objects/pack/pack-d45bd21b288905947b74de863c245e4c731c2480.idx","hash":"43e3fe3c85d8675e954dc727cabd103d4a18de9f","modified":1470636284000},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1470636284000},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"8faf09f90b781f9ee7efa547b3feacd028606a04","modified":1470636284000},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"8faf09f90b781f9ee7efa547b3feacd028606a04","modified":1470636284000},{"_id":"themes/maupassant/.git/objects/pack/pack-d45bd21b288905947b74de863c245e4c731c2480.pack","hash":"918a384c159bb64729b866b8373769d865cb8041","modified":1470636284000},{"_id":"themes/maupassant/.DS_Store","hash":"d737f448d5f1a0698c46cd156c05b22c9224e83f","modified":1473477126000},{"_id":"themes/maupassant/languages/.DS_Store","hash":"980222a069f4384f6966ad22125b9c8f8604d0cf","modified":1473472075000},{"_id":"themes/maupassant/layout/.DS_Store","hash":"e4678723ec729c3da7d97b0d4194b231ed9b3c9d","modified":1473476144000},{"_id":"themes/maupassant/source/.DS_Store","hash":"098d37ab45969172ca82131ca07a6d8a5686585c","modified":1473478594000},{"_id":"themes/maupassant/layout/_partial/.DS_Store","hash":"5c63215667d435f8c67bd0a8abf93e77e7706c2f","modified":1473476095000},{"_id":"themes/maupassant/layout/_widget/.DS_Store","hash":"6ba0d8f5eb70292e5f23b03318b8aba5043101ec","modified":1473473603000},{"_id":"themes/maupassant/source/css/.DS_Store","hash":"28e196260084ab7759beb6909920794f9f2855d3","modified":1473473144000},{"_id":"themes/maupassant/source/fancybox/.DS_Store","hash":"96b54a7b0d9b1047268968fe5dfa76c49b28c789","modified":1473472196000},{"_id":"themes/maupassant/source/js/.DS_Store","hash":"c676a94caf8e2b86488776fb604e6b142094ab6e","modified":1473473066000},{"_id":"themes/maupassant/atom.xml","hash":"835497e04385e3243601e1eb86f61466d567cc13","modified":1442503988000},{"_id":"themes/maupassant/source/about/index.md","hash":"117599d6834e5f5e78675c7846be8bcb4b80cad7","modified":1473476987000},{"_id":"themes/maupassant/source/about/.DS_Store","hash":"a6355d2592301b5cf687dc2cc0c58dceb75de806","modified":1473477114000},{"_id":"source/about/index.md","hash":"e1a5ea29dad351e4c52ee720346bfaa732c4dcd5","modified":1473478728000},{"_id":"source/about/.DS_Store","hash":"a6355d2592301b5cf687dc2cc0c58dceb75de806","modified":1473477114000}],"Category":[{"name":"Swift","_id":"ciswie9cb0003e3u2mq1xwk38"},{"name":"Objective-C","_id":"ciswie9cn0008e3u2wt2h5r9y"},{"name":"others","_id":"ciswie9d9000pe3u2qyz7d8on"},{"name":"Others","_id":"ciswie9e4001ae3u2qlu5ct4e"}],"Data":[],"Page":[{"_content":"#### 个人简介\n* 职位：iOS工程师\n\n* 职业经历：曾就职于北京跃联互动科技有限公司技术部iOS工程师，目前任职于北京三石创想科技有限公司技术部。\n\n* 教育经历：湖南科技学院\n\n* CSDN博客：<a href=\"http://blog.csdn.net/yangshebing21\">http://blog.csdn.net/yangshebing21</a>\n\n#### 联系我：\n\n1. 我的微博：<a href=\"http://weibo.com/yangshebing\">http://weibo.com/yangshebing</a>\n\n2. 我的邮箱：<a href=\"shebingyang@gmail.com\">shebingyang@gmail.com</a>\n","source":"about/index.md","raw":"#### 个人简介\n* 职位：iOS工程师\n\n* 职业经历：曾就职于北京跃联互动科技有限公司技术部iOS工程师，目前任职于北京三石创想科技有限公司技术部。\n\n* 教育经历：湖南科技学院\n\n* CSDN博客：<a href=\"http://blog.csdn.net/yangshebing21\">http://blog.csdn.net/yangshebing21</a>\n\n#### 联系我：\n\n1. 我的微博：<a href=\"http://weibo.com/yangshebing\">http://weibo.com/yangshebing</a>\n\n2. 我的邮箱：<a href=\"shebingyang@gmail.com\">shebingyang@gmail.com</a>\n","date":"2016-09-10T03:38:48.000Z","updated":"2016-09-10T03:38:48.000Z","path":"about/index.html","_id":"ciswn3wbi0000juu2ygya89gq","title":"","comments":1,"layout":"page","content":"<h4 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h4><ul>\n<li><p>职位：iOS工程师</p>\n</li>\n<li><p>职业经历：曾就职于北京跃联互动科技有限公司技术部iOS工程师，目前任职于北京三石创想科技有限公司技术部。</p>\n</li>\n<li><p>教育经历：湖南科技学院</p>\n</li>\n<li><p>CSDN博客：<a href=\"http://blog.csdn.net/yangshebing21\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/yangshebing21</a></p>\n</li>\n</ul>\n<h4 id=\"联系我：\"><a href=\"#联系我：\" class=\"headerlink\" title=\"联系我：\"></a>联系我：</h4><ol>\n<li><p>我的微博：<a href=\"http://weibo.com/yangshebing\" target=\"_blank\" rel=\"external\">http://weibo.com/yangshebing</a></p>\n</li>\n<li><p>我的邮箱：<a href=\"shebingyang@gmail.com\">shebingyang@gmail.com</a></p>\n</li>\n</ol>\n","excerpt":"","more":"<h4 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h4><ul>\n<li><p>职位：iOS工程师</p>\n</li>\n<li><p>职业经历：曾就职于北京跃联互动科技有限公司技术部iOS工程师，目前任职于北京三石创想科技有限公司技术部。</p>\n</li>\n<li><p>教育经历：湖南科技学院</p>\n</li>\n<li><p>CSDN博客：<a href=\"http://blog.csdn.net/yangshebing21\">http://blog.csdn.net/yangshebing21</a></p>\n</li>\n</ul>\n<h4 id=\"联系我：\"><a href=\"#联系我：\" class=\"headerlink\" title=\"联系我：\"></a>联系我：</h4><ol>\n<li><p>我的微博：<a href=\"http://weibo.com/yangshebing\">http://weibo.com/yangshebing</a></p>\n</li>\n<li><p>我的邮箱：<a href=\"shebingyang@gmail.com\">shebingyang@gmail.com</a></p>\n</li>\n</ol>\n"}],"Post":[{"layout":"post","title":"swift语言编程","date":"2015-09-12T04:53:21.000Z","comments":1,"keywords":"ios开发, Swift","_content":"\n#### Swift语言基础学习\n* 导入系统类库头文件（swift中称之为模块）\n\n`\nimport UIKit\n`\n\n* 定义一个常量\n\n`\nlet a = 5\n`\n\n* 定义一个变量\n\n`\nvar str = \"Hello, World!\"\n`\n\n* swift中打印输出\n\n`\nprint(\"Hi,Girl!\");\n`\n\n**注意事项：如果在一行内想要写多条语句时需要用分号隔开，一行内写一句代码分号可加可不加（不推荐加）**\n<!--more-->\n`\n//一行内多句代码\nlet dog = \"ddd\";print(dog)\n`\n\n```\n//一行内一句代码\nlet my = \"我的\"\nlet age = 20\nlet sex = \"male\"\nprint(my)\nprint(age)\nprint(sex)\n```\n\n* 一次性定义多个变量\n\n`\nvar a = 0.0, b = 0.0, c = 0.0\n`\n\n* 定义变量并赋初值\n\n```\nvar a : Float = 5;\nvar userName = \"yangshebing\"\n```\n\n* 字符串插值方式：相当于占位符输出\n\n`\nprint(\"the user name is \\(userName)”)\n`\n\n* 定义一个指定类型的变量\n\n```\nvar name : String\nname = \"yangshebing\";\nprint(name);\n```\n\n**注意：在Swift中支持多行注释嵌套**\n\n* 定义一个数组\n\n最简单粗暴的方法：\n\n`\nlet array = [\"a\", \"b\", \"c\"]\n`\n\n常规写法：\n\n```\nlet array1: [String] = [\"A\", \"B\", \"C\"]\nlet array2: Array<String> = [\"A\", \"B\", \"D”]\n```\n\n* 整数和浮点数之间转换\n\n```\nlet num = 3\nlet pointNum = 0.14159\nlet pi = Double(num) + pointNum\nlet numPi = Int(pi)\n//Float转换成Int类型时，实型值总是会被缩短，意味着4.75将会变成4, -3.9将会变成-3\nprint(numPi)\n```\n\n* 自定义类型别名\n\n```\ntypealias MyIntType = Int\nlet num : MyIntType = 10\n```\n\n* 布尔\n\nSwift 有一个基本布尔类型，称之为Bool。它提供了两个布尔常量值:true和false\n\n```\nlet isMore = true\nlet isRainy = false\n```\n\n* 布尔类型在if语句中的使用\n\n```\nlet isApple = true\nif isApple {\n    println(\"this is Apple\")\n}\n```\n**使用布尔类型应当注意事项：Swift的类型安全机制会防止non-Boolean代替Bool值，比如下面的代码就会报编译时错误：**\n\n```\nlet num = 1\nif num {\n\t//这个例子编译的时候会报错，但是在Objective-C语言中不会。\n}\n```\n\n正确使用的方式如下：\n\n```\nlet number = 1\nif number == 1 {\n    println(\"this is one\")\n    //这个编译成功\n}\n```\n\n另外，这里提一下：在Swift中判断两个对象是否相等是使用”===“”!==\"\n\n* Swift中元组的使用\n\n```\n//定义一个元组\nlet salaryCombination = （10000, \"one month\"）\n//它代表的是一个（Int, String）类型的元组\n```\n\n```\n//分解元组\nlet (salary, month) = salaryCombination\nprint(\"The salary is \\(salary)\")\nprint(\"The month is \\(month)\")\n//你如果只需要元组的一部分值，你也可以这样写\nlet (salary,_)\nprint(the salary is \\(salary))\n```\n\n* 元组取值方式总结\n\n```\n方式一\nlet firstSalary = (10000, \"one month\")\nlet (salary1,month1) = firstSalary\nlet secondSalary = (20000,\"two month\")\nlet (salary2, month2) = secondSalary\nprint(\"一月收入month1: \\(salary1)\")\nprint(\"二月收入month2: \\(salary2)”)\n\n//方式二\nlet firstSalary = (10000, \"one month\")\nlet (salary1,month1) = firstSalary\nlet secondSalary = (20000,\"two month\")\nlet (salary2, month2) = secondSalary\n//输出元组中的第0个元素， firstSalary.0：firstSalary代表元组名，0代表下标\nprint(\"一月的收入month1: \\(firstSalary.0)\")\nprint(\"二月的收入month2: \\(secondSalary.0)”)\n\n//方式三\nlet firstSalary = (salary : 10000,month : \"one month\")\nlet (salary1,month1) = firstSalary\nlet secondSalary = (salary :20000,month : \"two month\")\nlet (salary2, month2) = secondSalary\n//输出元组中的第0个元素， firstSalary.salary：firstSalary代表元组名，salary代表元组元素的名字\nprint(\"一月的收入month1: \\(firstSalary.salary)\")\nprint(\"二月的收入month2: \\(secondSalary.salary)\")\n```\n#### 本文参考文章资料：\n\n* 《The Swift Programming Language》\n\n**欢迎共同学习进步，本着分享的精神，只是为了让你学习起来更加轻松。**\n\n**如需转载，请注明出处**","source":"_posts/2015-09-12-swift.markdown","raw":"---\nlayout: post\ntitle: \"swift语言编程\"\ndate: 2015-09-12 12:53:21 +0800\ncomments: true\ntags: [iOS, xcode, Swift]\nkeywords: ios开发, Swift\ncategories: Swift\n---\n\n#### Swift语言基础学习\n* 导入系统类库头文件（swift中称之为模块）\n\n`\nimport UIKit\n`\n\n* 定义一个常量\n\n`\nlet a = 5\n`\n\n* 定义一个变量\n\n`\nvar str = \"Hello, World!\"\n`\n\n* swift中打印输出\n\n`\nprint(\"Hi,Girl!\");\n`\n\n**注意事项：如果在一行内想要写多条语句时需要用分号隔开，一行内写一句代码分号可加可不加（不推荐加）**\n<!--more-->\n`\n//一行内多句代码\nlet dog = \"ddd\";print(dog)\n`\n\n```\n//一行内一句代码\nlet my = \"我的\"\nlet age = 20\nlet sex = \"male\"\nprint(my)\nprint(age)\nprint(sex)\n```\n\n* 一次性定义多个变量\n\n`\nvar a = 0.0, b = 0.0, c = 0.0\n`\n\n* 定义变量并赋初值\n\n```\nvar a : Float = 5;\nvar userName = \"yangshebing\"\n```\n\n* 字符串插值方式：相当于占位符输出\n\n`\nprint(\"the user name is \\(userName)”)\n`\n\n* 定义一个指定类型的变量\n\n```\nvar name : String\nname = \"yangshebing\";\nprint(name);\n```\n\n**注意：在Swift中支持多行注释嵌套**\n\n* 定义一个数组\n\n最简单粗暴的方法：\n\n`\nlet array = [\"a\", \"b\", \"c\"]\n`\n\n常规写法：\n\n```\nlet array1: [String] = [\"A\", \"B\", \"C\"]\nlet array2: Array<String> = [\"A\", \"B\", \"D”]\n```\n\n* 整数和浮点数之间转换\n\n```\nlet num = 3\nlet pointNum = 0.14159\nlet pi = Double(num) + pointNum\nlet numPi = Int(pi)\n//Float转换成Int类型时，实型值总是会被缩短，意味着4.75将会变成4, -3.9将会变成-3\nprint(numPi)\n```\n\n* 自定义类型别名\n\n```\ntypealias MyIntType = Int\nlet num : MyIntType = 10\n```\n\n* 布尔\n\nSwift 有一个基本布尔类型，称之为Bool。它提供了两个布尔常量值:true和false\n\n```\nlet isMore = true\nlet isRainy = false\n```\n\n* 布尔类型在if语句中的使用\n\n```\nlet isApple = true\nif isApple {\n    println(\"this is Apple\")\n}\n```\n**使用布尔类型应当注意事项：Swift的类型安全机制会防止non-Boolean代替Bool值，比如下面的代码就会报编译时错误：**\n\n```\nlet num = 1\nif num {\n\t//这个例子编译的时候会报错，但是在Objective-C语言中不会。\n}\n```\n\n正确使用的方式如下：\n\n```\nlet number = 1\nif number == 1 {\n    println(\"this is one\")\n    //这个编译成功\n}\n```\n\n另外，这里提一下：在Swift中判断两个对象是否相等是使用”===“”!==\"\n\n* Swift中元组的使用\n\n```\n//定义一个元组\nlet salaryCombination = （10000, \"one month\"）\n//它代表的是一个（Int, String）类型的元组\n```\n\n```\n//分解元组\nlet (salary, month) = salaryCombination\nprint(\"The salary is \\(salary)\")\nprint(\"The month is \\(month)\")\n//你如果只需要元组的一部分值，你也可以这样写\nlet (salary,_)\nprint(the salary is \\(salary))\n```\n\n* 元组取值方式总结\n\n```\n方式一\nlet firstSalary = (10000, \"one month\")\nlet (salary1,month1) = firstSalary\nlet secondSalary = (20000,\"two month\")\nlet (salary2, month2) = secondSalary\nprint(\"一月收入month1: \\(salary1)\")\nprint(\"二月收入month2: \\(salary2)”)\n\n//方式二\nlet firstSalary = (10000, \"one month\")\nlet (salary1,month1) = firstSalary\nlet secondSalary = (20000,\"two month\")\nlet (salary2, month2) = secondSalary\n//输出元组中的第0个元素， firstSalary.0：firstSalary代表元组名，0代表下标\nprint(\"一月的收入month1: \\(firstSalary.0)\")\nprint(\"二月的收入month2: \\(secondSalary.0)”)\n\n//方式三\nlet firstSalary = (salary : 10000,month : \"one month\")\nlet (salary1,month1) = firstSalary\nlet secondSalary = (salary :20000,month : \"two month\")\nlet (salary2, month2) = secondSalary\n//输出元组中的第0个元素， firstSalary.salary：firstSalary代表元组名，salary代表元组元素的名字\nprint(\"一月的收入month1: \\(firstSalary.salary)\")\nprint(\"二月的收入month2: \\(secondSalary.salary)\")\n```\n#### 本文参考文章资料：\n\n* 《The Swift Programming Language》\n\n**欢迎共同学习进步，本着分享的精神，只是为了让你学习起来更加轻松。**\n\n**如需转载，请注明出处**","slug":"swift","published":1,"updated":"2016-09-10T05:16:28.000Z","_id":"ciswie9bz0000e3u2ysvu3uno","photos":[],"link":"","content":"<h4 id=\"Swift语言基础学习\"><a href=\"#Swift语言基础学习\" class=\"headerlink\" title=\"Swift语言基础学习\"></a>Swift语言基础学习</h4><ul>\n<li>导入系统类库头文件（swift中称之为模块）</li>\n</ul>\n<p><code>import UIKit</code></p>\n<ul>\n<li>定义一个常量</li>\n</ul>\n<p><code>let a = 5</code></p>\n<ul>\n<li>定义一个变量</li>\n</ul>\n<p><code>var str = &quot;Hello, World!&quot;</code></p>\n<ul>\n<li>swift中打印输出</li>\n</ul>\n<p><code>print(&quot;Hi,Girl!&quot;);</code></p>\n<p><strong>注意事项：如果在一行内想要写多条语句时需要用分号隔开，一行内写一句代码分号可加可不加（不推荐加）</strong><br><a id=\"more\"></a><br><code>//一行内多句代码\nlet dog = &quot;ddd&quot;;print(dog)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//一行内一句代码</div><div class=\"line\">let my = &quot;我的&quot;</div><div class=\"line\">let age = 20</div><div class=\"line\">let sex = &quot;male&quot;</div><div class=\"line\">print(my)</div><div class=\"line\">print(age)</div><div class=\"line\">print(sex)</div></pre></td></tr></table></figure>\n<ul>\n<li>一次性定义多个变量</li>\n</ul>\n<p><code>var a = 0.0, b = 0.0, c = 0.0</code></p>\n<ul>\n<li>定义变量并赋初值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a : Float = 5;</div><div class=\"line\">var userName = &quot;yangshebing&quot;</div></pre></td></tr></table></figure>\n<ul>\n<li>字符串插值方式：相当于占位符输出</li>\n</ul>\n<p><code>print(&quot;the user name is \\(userName)”)</code></p>\n<ul>\n<li>定义一个指定类型的变量</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name : String</div><div class=\"line\">name = &quot;yangshebing&quot;;</div><div class=\"line\">print(name);</div></pre></td></tr></table></figure>\n<p><strong>注意：在Swift中支持多行注释嵌套</strong></p>\n<ul>\n<li>定义一个数组</li>\n</ul>\n<p>最简单粗暴的方法：</p>\n<p><code>let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></p>\n<p>常规写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let array1: [String] = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</div><div class=\"line\">let array2: Array&lt;String&gt; = [&quot;A&quot;, &quot;B&quot;, &quot;D”]</div></pre></td></tr></table></figure>\n<ul>\n<li>整数和浮点数之间转换</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">let num = 3</div><div class=\"line\">let pointNum = 0.14159</div><div class=\"line\">let pi = Double(num) + pointNum</div><div class=\"line\">let numPi = Int(pi)</div><div class=\"line\">//Float转换成Int类型时，实型值总是会被缩短，意味着4.75将会变成4, -3.9将会变成-3</div><div class=\"line\">print(numPi)</div></pre></td></tr></table></figure>\n<ul>\n<li>自定义类型别名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">typealias MyIntType = Int</div><div class=\"line\">let num : MyIntType = 10</div></pre></td></tr></table></figure>\n<ul>\n<li>布尔</li>\n</ul>\n<p>Swift 有一个基本布尔类型，称之为Bool。它提供了两个布尔常量值:true和false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let isMore = true</div><div class=\"line\">let isRainy = false</div></pre></td></tr></table></figure>\n<ul>\n<li>布尔类型在if语句中的使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let isApple = true</div><div class=\"line\">if isApple &#123;</div><div class=\"line\">    println(&quot;this is Apple&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>使用布尔类型应当注意事项：Swift的类型安全机制会防止non-Boolean代替Bool值，比如下面的代码就会报编译时错误：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let num = 1</div><div class=\"line\">if num &#123;</div><div class=\"line\">\t//这个例子编译的时候会报错，但是在Objective-C语言中不会。</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>正确使用的方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">let number = 1</div><div class=\"line\">if number == 1 &#123;</div><div class=\"line\">    println(&quot;this is one&quot;)</div><div class=\"line\">    //这个编译成功</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>另外，这里提一下：在Swift中判断两个对象是否相等是使用”===“”!==”</p>\n<ul>\n<li>Swift中元组的使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//定义一个元组</div><div class=\"line\">let salaryCombination = （10000, &quot;one month&quot;）</div><div class=\"line\">//它代表的是一个（Int, String）类型的元组</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//分解元组</div><div class=\"line\">let (salary, month) = salaryCombination</div><div class=\"line\">print(&quot;The salary is \\(salary)&quot;)</div><div class=\"line\">print(&quot;The month is \\(month)&quot;)</div><div class=\"line\">//你如果只需要元组的一部分值，你也可以这样写</div><div class=\"line\">let (salary,_)</div><div class=\"line\">print(the salary is \\(salary))</div></pre></td></tr></table></figure>\n<ul>\n<li>元组取值方式总结</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">方式一</div><div class=\"line\">let firstSalary = (10000, &quot;one month&quot;)</div><div class=\"line\">let (salary1,month1) = firstSalary</div><div class=\"line\">let secondSalary = (20000,&quot;two month&quot;)</div><div class=\"line\">let (salary2, month2) = secondSalary</div><div class=\"line\">print(&quot;一月收入month1: \\(salary1)&quot;)</div><div class=\"line\">print(&quot;二月收入month2: \\(salary2)”)</div><div class=\"line\"></div><div class=\"line\">//方式二</div><div class=\"line\">let firstSalary = (10000, &quot;one month&quot;)</div><div class=\"line\">let (salary1,month1) = firstSalary</div><div class=\"line\">let secondSalary = (20000,&quot;two month&quot;)</div><div class=\"line\">let (salary2, month2) = secondSalary</div><div class=\"line\">//输出元组中的第0个元素， firstSalary.0：firstSalary代表元组名，0代表下标</div><div class=\"line\">print(&quot;一月的收入month1: \\(firstSalary.0)&quot;)</div><div class=\"line\">print(&quot;二月的收入month2: \\(secondSalary.0)”)</div><div class=\"line\"></div><div class=\"line\">//方式三</div><div class=\"line\">let firstSalary = (salary : 10000,month : &quot;one month&quot;)</div><div class=\"line\">let (salary1,month1) = firstSalary</div><div class=\"line\">let secondSalary = (salary :20000,month : &quot;two month&quot;)</div><div class=\"line\">let (salary2, month2) = secondSalary</div><div class=\"line\">//输出元组中的第0个元素， firstSalary.salary：firstSalary代表元组名，salary代表元组元素的名字</div><div class=\"line\">print(&quot;一月的收入month1: \\(firstSalary.salary)&quot;)</div><div class=\"line\">print(&quot;二月的收入month2: \\(secondSalary.salary)&quot;)</div></pre></td></tr></table></figure>\n<h4 id=\"本文参考文章资料：\"><a href=\"#本文参考文章资料：\" class=\"headerlink\" title=\"本文参考文章资料：\"></a>本文参考文章资料：</h4><ul>\n<li>《The Swift Programming Language》</li>\n</ul>\n<p><strong>欢迎共同学习进步，本着分享的精神，只是为了让你学习起来更加轻松。</strong></p>\n<p><strong>如需转载，请注明出处</strong></p>\n","excerpt":"<h4 id=\"Swift语言基础学习\"><a href=\"#Swift语言基础学习\" class=\"headerlink\" title=\"Swift语言基础学习\"></a>Swift语言基础学习</h4><ul>\n<li>导入系统类库头文件（swift中称之为模块）</li>\n</ul>\n<p><code>import UIKit</code></p>\n<ul>\n<li>定义一个常量</li>\n</ul>\n<p><code>let a = 5</code></p>\n<ul>\n<li>定义一个变量</li>\n</ul>\n<p><code>var str = &quot;Hello, World!&quot;</code></p>\n<ul>\n<li>swift中打印输出</li>\n</ul>\n<p><code>print(&quot;Hi,Girl!&quot;);</code></p>\n<p><strong>注意事项：如果在一行内想要写多条语句时需要用分号隔开，一行内写一句代码分号可加可不加（不推荐加）</strong><br>","more":"<br><code>//一行内多句代码\nlet dog = &quot;ddd&quot;;print(dog)</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//一行内一句代码</div><div class=\"line\">let my = &quot;我的&quot;</div><div class=\"line\">let age = 20</div><div class=\"line\">let sex = &quot;male&quot;</div><div class=\"line\">print(my)</div><div class=\"line\">print(age)</div><div class=\"line\">print(sex)</div></pre></td></tr></table></figure>\n<ul>\n<li>一次性定义多个变量</li>\n</ul>\n<p><code>var a = 0.0, b = 0.0, c = 0.0</code></p>\n<ul>\n<li>定义变量并赋初值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a : Float = 5;</div><div class=\"line\">var userName = &quot;yangshebing&quot;</div></pre></td></tr></table></figure>\n<ul>\n<li>字符串插值方式：相当于占位符输出</li>\n</ul>\n<p><code>print(&quot;the user name is \\(userName)”)</code></p>\n<ul>\n<li>定义一个指定类型的变量</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var name : String</div><div class=\"line\">name = &quot;yangshebing&quot;;</div><div class=\"line\">print(name);</div></pre></td></tr></table></figure>\n<p><strong>注意：在Swift中支持多行注释嵌套</strong></p>\n<ul>\n<li>定义一个数组</li>\n</ul>\n<p>最简单粗暴的方法：</p>\n<p><code>let array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></p>\n<p>常规写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let array1: [String] = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</div><div class=\"line\">let array2: Array&lt;String&gt; = [&quot;A&quot;, &quot;B&quot;, &quot;D”]</div></pre></td></tr></table></figure>\n<ul>\n<li>整数和浮点数之间转换</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">let num = 3</div><div class=\"line\">let pointNum = 0.14159</div><div class=\"line\">let pi = Double(num) + pointNum</div><div class=\"line\">let numPi = Int(pi)</div><div class=\"line\">//Float转换成Int类型时，实型值总是会被缩短，意味着4.75将会变成4, -3.9将会变成-3</div><div class=\"line\">print(numPi)</div></pre></td></tr></table></figure>\n<ul>\n<li>自定义类型别名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">typealias MyIntType = Int</div><div class=\"line\">let num : MyIntType = 10</div></pre></td></tr></table></figure>\n<ul>\n<li>布尔</li>\n</ul>\n<p>Swift 有一个基本布尔类型，称之为Bool。它提供了两个布尔常量值:true和false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let isMore = true</div><div class=\"line\">let isRainy = false</div></pre></td></tr></table></figure>\n<ul>\n<li>布尔类型在if语句中的使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let isApple = true</div><div class=\"line\">if isApple &#123;</div><div class=\"line\">    println(&quot;this is Apple&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>使用布尔类型应当注意事项：Swift的类型安全机制会防止non-Boolean代替Bool值，比如下面的代码就会报编译时错误：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let num = 1</div><div class=\"line\">if num &#123;</div><div class=\"line\">\t//这个例子编译的时候会报错，但是在Objective-C语言中不会。</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>正确使用的方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">let number = 1</div><div class=\"line\">if number == 1 &#123;</div><div class=\"line\">    println(&quot;this is one&quot;)</div><div class=\"line\">    //这个编译成功</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>另外，这里提一下：在Swift中判断两个对象是否相等是使用”===“”!==”</p>\n<ul>\n<li>Swift中元组的使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//定义一个元组</div><div class=\"line\">let salaryCombination = （10000, &quot;one month&quot;）</div><div class=\"line\">//它代表的是一个（Int, String）类型的元组</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//分解元组</div><div class=\"line\">let (salary, month) = salaryCombination</div><div class=\"line\">print(&quot;The salary is \\(salary)&quot;)</div><div class=\"line\">print(&quot;The month is \\(month)&quot;)</div><div class=\"line\">//你如果只需要元组的一部分值，你也可以这样写</div><div class=\"line\">let (salary,_)</div><div class=\"line\">print(the salary is \\(salary))</div></pre></td></tr></table></figure>\n<ul>\n<li>元组取值方式总结</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">方式一</div><div class=\"line\">let firstSalary = (10000, &quot;one month&quot;)</div><div class=\"line\">let (salary1,month1) = firstSalary</div><div class=\"line\">let secondSalary = (20000,&quot;two month&quot;)</div><div class=\"line\">let (salary2, month2) = secondSalary</div><div class=\"line\">print(&quot;一月收入month1: \\(salary1)&quot;)</div><div class=\"line\">print(&quot;二月收入month2: \\(salary2)”)</div><div class=\"line\"></div><div class=\"line\">//方式二</div><div class=\"line\">let firstSalary = (10000, &quot;one month&quot;)</div><div class=\"line\">let (salary1,month1) = firstSalary</div><div class=\"line\">let secondSalary = (20000,&quot;two month&quot;)</div><div class=\"line\">let (salary2, month2) = secondSalary</div><div class=\"line\">//输出元组中的第0个元素， firstSalary.0：firstSalary代表元组名，0代表下标</div><div class=\"line\">print(&quot;一月的收入month1: \\(firstSalary.0)&quot;)</div><div class=\"line\">print(&quot;二月的收入month2: \\(secondSalary.0)”)</div><div class=\"line\"></div><div class=\"line\">//方式三</div><div class=\"line\">let firstSalary = (salary : 10000,month : &quot;one month&quot;)</div><div class=\"line\">let (salary1,month1) = firstSalary</div><div class=\"line\">let secondSalary = (salary :20000,month : &quot;two month&quot;)</div><div class=\"line\">let (salary2, month2) = secondSalary</div><div class=\"line\">//输出元组中的第0个元素， firstSalary.salary：firstSalary代表元组名，salary代表元组元素的名字</div><div class=\"line\">print(&quot;一月的收入month1: \\(firstSalary.salary)&quot;)</div><div class=\"line\">print(&quot;二月的收入month2: \\(secondSalary.salary)&quot;)</div></pre></td></tr></table></figure>\n<h4 id=\"本文参考文章资料：\"><a href=\"#本文参考文章资料：\" class=\"headerlink\" title=\"本文参考文章资料：\"></a>本文参考文章资料：</h4><ul>\n<li>《The Swift Programming Language》</li>\n</ul>\n<p><strong>欢迎共同学习进步，本着分享的精神，只是为了让你学习起来更加轻松。</strong></p>\n<p><strong>如需转载，请注明出处</strong></p>"},{"layout":"post","title":"动态限制UITextField或UITextView用户输入中英文混编字数统计","date":"2015-09-12T03:31:37.000Z","comments":1,"keywords":"ios开发, 限制用户输入, UITextField, UITextView","_content":"**动态限制用户输入字数，这个在很多app中都会涉及，由于NSString的Length属性获取的长度中英文都是一个字节，不满足一个汉字两个字节、一个字符一个字节的需求。网上的方法大致是以下两种：**\n###### 1、使用Unicode编码把OC中的NSString字符串转换成C的字符串。然后对字符串遍历进行统计长度。\n<!--more-->\n\n```\n\n-  (int)convertToInt:(NSString*)strtemp {  \n    int strlength = 0;\n    char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding];\n    for (int i=0 ; i<[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding];i++) {\n        if (*p) {\n            p++;\n            strlength++;\n        }\n        else {\n            p++;\n        }\n    }\n    return strlength;\n}\n```\n\n###### 2、直接计算OC中的NSString字符串中单词的个数\n```\n- (NSInteger)countWordWithStr:(NSString *)s\n{\n    NSInteger i,n=[s length],l=0,a=0,b=0;\n    unichar c;\n    for(i=0;i<n;i++){\n        c=[s characterAtIndex:i];\n        if(isblank(c)){\n            b++;\n        }else if(isascii(c)){\n            a++;\n        }else{\n            l++;\n        }\n    }\n    if(a==0 && l==0) return 0;\n    return l+(NSInteger)ceilf((float)(a+b)/2.0);\n}\n```\n**以上资料均为网上整理得来，仅供学习交流使用。有关于此类问题，欢迎在最下方留言一起探讨优化学习。**\n\n###### 参考博客地址：\n* 1、<a href=\"http://mobilesolutions.blog.163.com/blog/static/18922417620116133910181/\">统计含中英文混编的NSString 字符串长度 </a>\n* 2、<a href=\"http://blog.csdn.net/toss156/article/details/8993270\">【IOS】IOS开发常用函数</a>\n* 3、<a href=\"http://code.qtuba.com/article-60968.html\">iOS - 推断输入字符串长度函数</a>\n","source":"_posts/2015-09-12-test.markdown","raw":"---\nlayout: post\ntitle: \"动态限制UITextField或UITextView用户输入中英文混编字数统计\"\ndate: 2015-09-12 11:31:37 +0800\ncomments: true\ntags: [iOS, xcode, Objective-C]\nkeywords: ios开发, 限制用户输入, UITextField, UITextView\ncategories: Objective-C\n---\n**动态限制用户输入字数，这个在很多app中都会涉及，由于NSString的Length属性获取的长度中英文都是一个字节，不满足一个汉字两个字节、一个字符一个字节的需求。网上的方法大致是以下两种：**\n###### 1、使用Unicode编码把OC中的NSString字符串转换成C的字符串。然后对字符串遍历进行统计长度。\n<!--more-->\n\n```\n\n-  (int)convertToInt:(NSString*)strtemp {  \n    int strlength = 0;\n    char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding];\n    for (int i=0 ; i<[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding];i++) {\n        if (*p) {\n            p++;\n            strlength++;\n        }\n        else {\n            p++;\n        }\n    }\n    return strlength;\n}\n```\n\n###### 2、直接计算OC中的NSString字符串中单词的个数\n```\n- (NSInteger)countWordWithStr:(NSString *)s\n{\n    NSInteger i,n=[s length],l=0,a=0,b=0;\n    unichar c;\n    for(i=0;i<n;i++){\n        c=[s characterAtIndex:i];\n        if(isblank(c)){\n            b++;\n        }else if(isascii(c)){\n            a++;\n        }else{\n            l++;\n        }\n    }\n    if(a==0 && l==0) return 0;\n    return l+(NSInteger)ceilf((float)(a+b)/2.0);\n}\n```\n**以上资料均为网上整理得来，仅供学习交流使用。有关于此类问题，欢迎在最下方留言一起探讨优化学习。**\n\n###### 参考博客地址：\n* 1、<a href=\"http://mobilesolutions.blog.163.com/blog/static/18922417620116133910181/\">统计含中英文混编的NSString 字符串长度 </a>\n* 2、<a href=\"http://blog.csdn.net/toss156/article/details/8993270\">【IOS】IOS开发常用函数</a>\n* 3、<a href=\"http://code.qtuba.com/article-60968.html\">iOS - 推断输入字符串长度函数</a>\n","slug":"test","published":1,"updated":"2016-09-10T05:16:36.000Z","_id":"ciswie9c50001e3u23qsy7wya","photos":[],"link":"","content":"<p><strong>动态限制用户输入字数，这个在很多app中都会涉及，由于NSString的Length属性获取的长度中英文都是一个字节，不满足一个汉字两个字节、一个字符一个字节的需求。网上的方法大致是以下两种：</strong></p>\n<h6 id=\"1、使用Unicode编码把OC中的NSString字符串转换成C的字符串。然后对字符串遍历进行统计长度。\"><a href=\"#1、使用Unicode编码把OC中的NSString字符串转换成C的字符串。然后对字符串遍历进行统计长度。\" class=\"headerlink\" title=\"1、使用Unicode编码把OC中的NSString字符串转换成C的字符串。然后对字符串遍历进行统计长度。\"></a>1、使用Unicode编码把OC中的NSString字符串转换成C的字符串。然后对字符串遍历进行统计长度。</h6><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">-  (int)convertToInt:(NSString*)strtemp &#123;  </div><div class=\"line\">    int strlength = 0;</div><div class=\"line\">    char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding];</div><div class=\"line\">    for (int i=0 ; i&lt;[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding];i++) &#123;</div><div class=\"line\">        if (*p) &#123;</div><div class=\"line\">            p++;</div><div class=\"line\">            strlength++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            p++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return strlength;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h6 id=\"2、直接计算OC中的NSString字符串中单词的个数\"><a href=\"#2、直接计算OC中的NSString字符串中单词的个数\" class=\"headerlink\" title=\"2、直接计算OC中的NSString字符串中单词的个数\"></a>2、直接计算OC中的NSString字符串中单词的个数</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSInteger)countWordWithStr:(NSString *)s</div><div class=\"line\">&#123;</div><div class=\"line\">    NSInteger i,n=[s length],l=0,a=0,b=0;</div><div class=\"line\">    unichar c;</div><div class=\"line\">    for(i=0;i&lt;n;i++)&#123;</div><div class=\"line\">        c=[s characterAtIndex:i];</div><div class=\"line\">        if(isblank(c))&#123;</div><div class=\"line\">            b++;</div><div class=\"line\">        &#125;else if(isascii(c))&#123;</div><div class=\"line\">            a++;</div><div class=\"line\">        &#125;else&#123;</div><div class=\"line\">            l++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if(a==0 &amp;&amp; l==0) return 0;</div><div class=\"line\">    return l+(NSInteger)ceilf((float)(a+b)/2.0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>以上资料均为网上整理得来，仅供学习交流使用。有关于此类问题，欢迎在最下方留言一起探讨优化学习。</strong></p>\n<h6 id=\"参考博客地址：\"><a href=\"#参考博客地址：\" class=\"headerlink\" title=\"参考博客地址：\"></a>参考博客地址：</h6><ul>\n<li>1、<a href=\"http://mobilesolutions.blog.163.com/blog/static/18922417620116133910181/\" target=\"_blank\" rel=\"external\">统计含中英文混编的NSString 字符串长度 </a></li>\n<li>2、<a href=\"http://blog.csdn.net/toss156/article/details/8993270\" target=\"_blank\" rel=\"external\">【IOS】IOS开发常用函数</a></li>\n<li>3、<a href=\"http://code.qtuba.com/article-60968.html\" target=\"_blank\" rel=\"external\">iOS - 推断输入字符串长度函数</a></li>\n</ul>\n","excerpt":"<p><strong>动态限制用户输入字数，这个在很多app中都会涉及，由于NSString的Length属性获取的长度中英文都是一个字节，不满足一个汉字两个字节、一个字符一个字节的需求。网上的方法大致是以下两种：</strong></p>\n<h6 id=\"1、使用Unicode编码把OC中的NSString字符串转换成C的字符串。然后对字符串遍历进行统计长度。\"><a href=\"#1、使用Unicode编码把OC中的NSString字符串转换成C的字符串。然后对字符串遍历进行统计长度。\" class=\"headerlink\" title=\"1、使用Unicode编码把OC中的NSString字符串转换成C的字符串。然后对字符串遍历进行统计长度。\"></a>1、使用Unicode编码把OC中的NSString字符串转换成C的字符串。然后对字符串遍历进行统计长度。</h6>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">-  (int)convertToInt:(NSString*)strtemp &#123;  </div><div class=\"line\">    int strlength = 0;</div><div class=\"line\">    char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding];</div><div class=\"line\">    for (int i=0 ; i&lt;[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding];i++) &#123;</div><div class=\"line\">        if (*p) &#123;</div><div class=\"line\">            p++;</div><div class=\"line\">            strlength++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            p++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return strlength;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h6 id=\"2、直接计算OC中的NSString字符串中单词的个数\"><a href=\"#2、直接计算OC中的NSString字符串中单词的个数\" class=\"headerlink\" title=\"2、直接计算OC中的NSString字符串中单词的个数\"></a>2、直接计算OC中的NSString字符串中单词的个数</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSInteger)countWordWithStr:(NSString *)s</div><div class=\"line\">&#123;</div><div class=\"line\">    NSInteger i,n=[s length],l=0,a=0,b=0;</div><div class=\"line\">    unichar c;</div><div class=\"line\">    for(i=0;i&lt;n;i++)&#123;</div><div class=\"line\">        c=[s characterAtIndex:i];</div><div class=\"line\">        if(isblank(c))&#123;</div><div class=\"line\">            b++;</div><div class=\"line\">        &#125;else if(isascii(c))&#123;</div><div class=\"line\">            a++;</div><div class=\"line\">        &#125;else&#123;</div><div class=\"line\">            l++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if(a==0 &amp;&amp; l==0) return 0;</div><div class=\"line\">    return l+(NSInteger)ceilf((float)(a+b)/2.0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>以上资料均为网上整理得来，仅供学习交流使用。有关于此类问题，欢迎在最下方留言一起探讨优化学习。</strong></p>\n<h6 id=\"参考博客地址：\"><a href=\"#参考博客地址：\" class=\"headerlink\" title=\"参考博客地址：\"></a>参考博客地址：</h6><ul>\n<li>1、<a href=\"http://mobilesolutions.blog.163.com/blog/static/18922417620116133910181/\">统计含中英文混编的NSString 字符串长度 </a></li>\n<li>2、<a href=\"http://blog.csdn.net/toss156/article/details/8993270\">【IOS】IOS开发常用函数</a></li>\n<li>3、<a href=\"http://code.qtuba.com/article-60968.html\">iOS - 推断输入字符串长度函数</a></li>\n</ul>"},{"layout":"post","title":"iOS中点击状态栏让滑动视图回到顶部","date":"2015-09-13T15:28:31.000Z","comments":1,"keywords":"ios开发, 返回顶部, UIScrollView, UITableView","_content":"###### 在产品开发过程中，有时候会有这种需求，需要点击状态栏让滑动视图（UIScrollView）或者表视图（UITableView）返回到顶部，让用户可以更快的浏览最新的信息。 \n###### 这个时候我们需要设置滑动视图的scrollsToTop属性，让它决定点击状态栏是否返回顶部。 \n<!--more-->\n``` \n// When the user taps the status bar, \nthe scroll view beneath the touch which is closest to the status bar will be scrolled to top,\n but only if its scrollsToTop property is YES, \n its delegate does not return NO from shouldScrollViewScrollToTop,\n  and it is not already at the top. \n// On iPhone, we execute this gesture only if there’s one on-screen scroll view with scrollsToTop == YES.\n If more than one is found, none will be scrolled.\n@property(nonatomic) BOOL scrollsToTop; // default is YES.\n```\n\n###### 设置这个属性，可以让点击状态栏不返回顶部。如果我们需要让它点击状态栏回到顶部，我们可以把这个属性值设置为YES（默认为YES）。按正常情况来说，这个时候点击状态栏是可以返回到顶部。但是点击状态栏还是没有反应怎么办？\n\n###### 解决方法如下： \n###### 按照上面官方文档的说法，只有把当前主控制器需要设置的那个scrollview找到并把它的scrollsToTop属性设置为YES，然后再把其他scrollview的scrollsToTop属性设置为NO 。这样它才会响应这个事件。其中的原理非常简单，如果当前主控制器中有2个scrollview，系统压根就不知道你想要其中的哪个scrollview滑动到顶部。\n\n###### 举个栗子： \n* 假设当前控制器中有三个表视图（UITableView）或者滑动视图(UIScrollView)要切换，把当前显示的滑动视图scrollsToTop属性设置为YES,其他滑动视图的scrollsToTop属性设置为NO即可。\n\n**注意：如果当前滑动视图中存在子视图也是滑动视图的情况，那么它子视图中的滑动视图scrollsToTop属性也要设置为NO，不然它仍然会造成点击状态栏无法响应返回到顶部操作。**\n\n###### 参考博客地址： \n* <a href=\"http://blog.sina.com.cn/s/blog_463dc5b90101k9ib.html\">点击状态栏不返回顶部问题</a>\n\n","source":"_posts/2015-09-13-arcticle.markdown","raw":"---\nlayout: post\ntitle: \"iOS中点击状态栏让滑动视图回到顶部\"\ndate: 2015-09-13 23:28:31 +0800\ncomments: true\ntags: [iOS, xcode, Objective-C]\nkeywords: ios开发, 返回顶部, UIScrollView, UITableView\ncategories: Objective-C\n---\n###### 在产品开发过程中，有时候会有这种需求，需要点击状态栏让滑动视图（UIScrollView）或者表视图（UITableView）返回到顶部，让用户可以更快的浏览最新的信息。 \n###### 这个时候我们需要设置滑动视图的scrollsToTop属性，让它决定点击状态栏是否返回顶部。 \n<!--more-->\n``` \n// When the user taps the status bar, \nthe scroll view beneath the touch which is closest to the status bar will be scrolled to top,\n but only if its scrollsToTop property is YES, \n its delegate does not return NO from shouldScrollViewScrollToTop,\n  and it is not already at the top. \n// On iPhone, we execute this gesture only if there’s one on-screen scroll view with scrollsToTop == YES.\n If more than one is found, none will be scrolled.\n@property(nonatomic) BOOL scrollsToTop; // default is YES.\n```\n\n###### 设置这个属性，可以让点击状态栏不返回顶部。如果我们需要让它点击状态栏回到顶部，我们可以把这个属性值设置为YES（默认为YES）。按正常情况来说，这个时候点击状态栏是可以返回到顶部。但是点击状态栏还是没有反应怎么办？\n\n###### 解决方法如下： \n###### 按照上面官方文档的说法，只有把当前主控制器需要设置的那个scrollview找到并把它的scrollsToTop属性设置为YES，然后再把其他scrollview的scrollsToTop属性设置为NO 。这样它才会响应这个事件。其中的原理非常简单，如果当前主控制器中有2个scrollview，系统压根就不知道你想要其中的哪个scrollview滑动到顶部。\n\n###### 举个栗子： \n* 假设当前控制器中有三个表视图（UITableView）或者滑动视图(UIScrollView)要切换，把当前显示的滑动视图scrollsToTop属性设置为YES,其他滑动视图的scrollsToTop属性设置为NO即可。\n\n**注意：如果当前滑动视图中存在子视图也是滑动视图的情况，那么它子视图中的滑动视图scrollsToTop属性也要设置为NO，不然它仍然会造成点击状态栏无法响应返回到顶部操作。**\n\n###### 参考博客地址： \n* <a href=\"http://blog.sina.com.cn/s/blog_463dc5b90101k9ib.html\">点击状态栏不返回顶部问题</a>\n\n","slug":"arcticle","published":1,"updated":"2016-09-10T05:16:45.000Z","_id":"ciswie9cb0004e3u2aowy3tdi","photos":[],"link":"","content":"<h6 id=\"在产品开发过程中，有时候会有这种需求，需要点击状态栏让滑动视图（UIScrollView）或者表视图（UITableView）返回到顶部，让用户可以更快的浏览最新的信息。\"><a href=\"#在产品开发过程中，有时候会有这种需求，需要点击状态栏让滑动视图（UIScrollView）或者表视图（UITableView）返回到顶部，让用户可以更快的浏览最新的信息。\" class=\"headerlink\" title=\"在产品开发过程中，有时候会有这种需求，需要点击状态栏让滑动视图（UIScrollView）或者表视图（UITableView）返回到顶部，让用户可以更快的浏览最新的信息。\"></a>在产品开发过程中，有时候会有这种需求，需要点击状态栏让滑动视图（UIScrollView）或者表视图（UITableView）返回到顶部，让用户可以更快的浏览最新的信息。</h6><h6 id=\"这个时候我们需要设置滑动视图的scrollsToTop属性，让它决定点击状态栏是否返回顶部。\"><a href=\"#这个时候我们需要设置滑动视图的scrollsToTop属性，让它决定点击状态栏是否返回顶部。\" class=\"headerlink\" title=\"这个时候我们需要设置滑动视图的scrollsToTop属性，让它决定点击状态栏是否返回顶部。\"></a>这个时候我们需要设置滑动视图的scrollsToTop属性，让它决定点击状态栏是否返回顶部。</h6><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// When the user taps the status bar, </div><div class=\"line\">the scroll view beneath the touch which is closest to the status bar will be scrolled to top,</div><div class=\"line\"> but only if its scrollsToTop property is YES, </div><div class=\"line\"> its delegate does not return NO from shouldScrollViewScrollToTop,</div><div class=\"line\">  and it is not already at the top. </div><div class=\"line\">// On iPhone, we execute this gesture only if there’s one on-screen scroll view with scrollsToTop == YES.</div><div class=\"line\"> If more than one is found, none will be scrolled.</div><div class=\"line\">@property(nonatomic) BOOL scrollsToTop; // default is YES.</div></pre></td></tr></table></figure>\n<h6 id=\"设置这个属性，可以让点击状态栏不返回顶部。如果我们需要让它点击状态栏回到顶部，我们可以把这个属性值设置为YES（默认为YES）。按正常情况来说，这个时候点击状态栏是可以返回到顶部。但是点击状态栏还是没有反应怎么办？\"><a href=\"#设置这个属性，可以让点击状态栏不返回顶部。如果我们需要让它点击状态栏回到顶部，我们可以把这个属性值设置为YES（默认为YES）。按正常情况来说，这个时候点击状态栏是可以返回到顶部。但是点击状态栏还是没有反应怎么办？\" class=\"headerlink\" title=\"设置这个属性，可以让点击状态栏不返回顶部。如果我们需要让它点击状态栏回到顶部，我们可以把这个属性值设置为YES（默认为YES）。按正常情况来说，这个时候点击状态栏是可以返回到顶部。但是点击状态栏还是没有反应怎么办？\"></a>设置这个属性，可以让点击状态栏不返回顶部。如果我们需要让它点击状态栏回到顶部，我们可以把这个属性值设置为YES（默认为YES）。按正常情况来说，这个时候点击状态栏是可以返回到顶部。但是点击状态栏还是没有反应怎么办？</h6><h6 id=\"解决方法如下：\"><a href=\"#解决方法如下：\" class=\"headerlink\" title=\"解决方法如下：\"></a>解决方法如下：</h6><h6 id=\"按照上面官方文档的说法，只有把当前主控制器需要设置的那个scrollview找到并把它的scrollsToTop属性设置为YES，然后再把其他scrollview的scrollsToTop属性设置为NO-。这样它才会响应这个事件。其中的原理非常简单，如果当前主控制器中有2个scrollview，系统压根就不知道你想要其中的哪个scrollview滑动到顶部。\"><a href=\"#按照上面官方文档的说法，只有把当前主控制器需要设置的那个scrollview找到并把它的scrollsToTop属性设置为YES，然后再把其他scrollview的scrollsToTop属性设置为NO-。这样它才会响应这个事件。其中的原理非常简单，如果当前主控制器中有2个scrollview，系统压根就不知道你想要其中的哪个scrollview滑动到顶部。\" class=\"headerlink\" title=\"按照上面官方文档的说法，只有把当前主控制器需要设置的那个scrollview找到并把它的scrollsToTop属性设置为YES，然后再把其他scrollview的scrollsToTop属性设置为NO 。这样它才会响应这个事件。其中的原理非常简单，如果当前主控制器中有2个scrollview，系统压根就不知道你想要其中的哪个scrollview滑动到顶部。\"></a>按照上面官方文档的说法，只有把当前主控制器需要设置的那个scrollview找到并把它的scrollsToTop属性设置为YES，然后再把其他scrollview的scrollsToTop属性设置为NO 。这样它才会响应这个事件。其中的原理非常简单，如果当前主控制器中有2个scrollview，系统压根就不知道你想要其中的哪个scrollview滑动到顶部。</h6><h6 id=\"举个栗子：\"><a href=\"#举个栗子：\" class=\"headerlink\" title=\"举个栗子：\"></a>举个栗子：</h6><ul>\n<li>假设当前控制器中有三个表视图（UITableView）或者滑动视图(UIScrollView)要切换，把当前显示的滑动视图scrollsToTop属性设置为YES,其他滑动视图的scrollsToTop属性设置为NO即可。</li>\n</ul>\n<p><strong>注意：如果当前滑动视图中存在子视图也是滑动视图的情况，那么它子视图中的滑动视图scrollsToTop属性也要设置为NO，不然它仍然会造成点击状态栏无法响应返回到顶部操作。</strong></p>\n<h6 id=\"参考博客地址：\"><a href=\"#参考博客地址：\" class=\"headerlink\" title=\"参考博客地址：\"></a>参考博客地址：</h6><ul>\n<li><a href=\"http://blog.sina.com.cn/s/blog_463dc5b90101k9ib.html\" target=\"_blank\" rel=\"external\">点击状态栏不返回顶部问题</a></li>\n</ul>\n","excerpt":"<h6 id=\"在产品开发过程中，有时候会有这种需求，需要点击状态栏让滑动视图（UIScrollView）或者表视图（UITableView）返回到顶部，让用户可以更快的浏览最新的信息。\"><a href=\"#在产品开发过程中，有时候会有这种需求，需要点击状态栏让滑动视图（UIScrollView）或者表视图（UITableView）返回到顶部，让用户可以更快的浏览最新的信息。\" class=\"headerlink\" title=\"在产品开发过程中，有时候会有这种需求，需要点击状态栏让滑动视图（UIScrollView）或者表视图（UITableView）返回到顶部，让用户可以更快的浏览最新的信息。\"></a>在产品开发过程中，有时候会有这种需求，需要点击状态栏让滑动视图（UIScrollView）或者表视图（UITableView）返回到顶部，让用户可以更快的浏览最新的信息。</h6><h6 id=\"这个时候我们需要设置滑动视图的scrollsToTop属性，让它决定点击状态栏是否返回顶部。\"><a href=\"#这个时候我们需要设置滑动视图的scrollsToTop属性，让它决定点击状态栏是否返回顶部。\" class=\"headerlink\" title=\"这个时候我们需要设置滑动视图的scrollsToTop属性，让它决定点击状态栏是否返回顶部。\"></a>这个时候我们需要设置滑动视图的scrollsToTop属性，让它决定点击状态栏是否返回顶部。</h6>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// When the user taps the status bar, </div><div class=\"line\">the scroll view beneath the touch which is closest to the status bar will be scrolled to top,</div><div class=\"line\"> but only if its scrollsToTop property is YES, </div><div class=\"line\"> its delegate does not return NO from shouldScrollViewScrollToTop,</div><div class=\"line\">  and it is not already at the top. </div><div class=\"line\">// On iPhone, we execute this gesture only if there’s one on-screen scroll view with scrollsToTop == YES.</div><div class=\"line\"> If more than one is found, none will be scrolled.</div><div class=\"line\">@property(nonatomic) BOOL scrollsToTop; // default is YES.</div></pre></td></tr></table></figure>\n<h6 id=\"设置这个属性，可以让点击状态栏不返回顶部。如果我们需要让它点击状态栏回到顶部，我们可以把这个属性值设置为YES（默认为YES）。按正常情况来说，这个时候点击状态栏是可以返回到顶部。但是点击状态栏还是没有反应怎么办？\"><a href=\"#设置这个属性，可以让点击状态栏不返回顶部。如果我们需要让它点击状态栏回到顶部，我们可以把这个属性值设置为YES（默认为YES）。按正常情况来说，这个时候点击状态栏是可以返回到顶部。但是点击状态栏还是没有反应怎么办？\" class=\"headerlink\" title=\"设置这个属性，可以让点击状态栏不返回顶部。如果我们需要让它点击状态栏回到顶部，我们可以把这个属性值设置为YES（默认为YES）。按正常情况来说，这个时候点击状态栏是可以返回到顶部。但是点击状态栏还是没有反应怎么办？\"></a>设置这个属性，可以让点击状态栏不返回顶部。如果我们需要让它点击状态栏回到顶部，我们可以把这个属性值设置为YES（默认为YES）。按正常情况来说，这个时候点击状态栏是可以返回到顶部。但是点击状态栏还是没有反应怎么办？</h6><h6 id=\"解决方法如下：\"><a href=\"#解决方法如下：\" class=\"headerlink\" title=\"解决方法如下：\"></a>解决方法如下：</h6><h6 id=\"按照上面官方文档的说法，只有把当前主控制器需要设置的那个scrollview找到并把它的scrollsToTop属性设置为YES，然后再把其他scrollview的scrollsToTop属性设置为NO-。这样它才会响应这个事件。其中的原理非常简单，如果当前主控制器中有2个scrollview，系统压根就不知道你想要其中的哪个scrollview滑动到顶部。\"><a href=\"#按照上面官方文档的说法，只有把当前主控制器需要设置的那个scrollview找到并把它的scrollsToTop属性设置为YES，然后再把其他scrollview的scrollsToTop属性设置为NO-。这样它才会响应这个事件。其中的原理非常简单，如果当前主控制器中有2个scrollview，系统压根就不知道你想要其中的哪个scrollview滑动到顶部。\" class=\"headerlink\" title=\"按照上面官方文档的说法，只有把当前主控制器需要设置的那个scrollview找到并把它的scrollsToTop属性设置为YES，然后再把其他scrollview的scrollsToTop属性设置为NO 。这样它才会响应这个事件。其中的原理非常简单，如果当前主控制器中有2个scrollview，系统压根就不知道你想要其中的哪个scrollview滑动到顶部。\"></a>按照上面官方文档的说法，只有把当前主控制器需要设置的那个scrollview找到并把它的scrollsToTop属性设置为YES，然后再把其他scrollview的scrollsToTop属性设置为NO 。这样它才会响应这个事件。其中的原理非常简单，如果当前主控制器中有2个scrollview，系统压根就不知道你想要其中的哪个scrollview滑动到顶部。</h6><h6 id=\"举个栗子：\"><a href=\"#举个栗子：\" class=\"headerlink\" title=\"举个栗子：\"></a>举个栗子：</h6><ul>\n<li>假设当前控制器中有三个表视图（UITableView）或者滑动视图(UIScrollView)要切换，把当前显示的滑动视图scrollsToTop属性设置为YES,其他滑动视图的scrollsToTop属性设置为NO即可。</li>\n</ul>\n<p><strong>注意：如果当前滑动视图中存在子视图也是滑动视图的情况，那么它子视图中的滑动视图scrollsToTop属性也要设置为NO，不然它仍然会造成点击状态栏无法响应返回到顶部操作。</strong></p>\n<h6 id=\"参考博客地址：\"><a href=\"#参考博客地址：\" class=\"headerlink\" title=\"参考博客地址：\"></a>参考博客地址：</h6><ul>\n<li><a href=\"http://blog.sina.com.cn/s/blog_463dc5b90101k9ib.html\">点击状态栏不返回顶部问题</a></li>\n</ul>"},{"layout":"post","title":"UICollectionView（纯代码方式）实现带上下拉刷新的瀑布流式（WaterFlow）布局","date":"2015-11-03T14:40:32.000Z","comments":1,"keywords":"UICollectionView, WaterFlow, FlowLayout, 下拉刷新","_content":"\n瀑布流（WaterFlow）是项目开发过程中的常见布局，有关于瀑布流（WaterFlow）的实现方式：在UICollectionView未出现之前，瀑布流的实现多半是采用UIScrollView或是UITableView。对于我们这种用惯了表视图的人来说，UICollectionView倒略显陌生。有关于UICollectionView的介绍我就不一一赘述，因为一两句话也很难说清楚。网上有很多优秀的文章专门对其进行了一系列的解说，另有苹果官方文档可以查阅。本文主要是介绍如何采用纯代码的方式利用UICollectionView实现带上下拉刷新的瀑布流式（WaterFlow）布局。废话少说，直接入题。\n<!--more-->\n#### 一、UICollectionView集成上下拉刷新\n\n（1）简单的介绍UICollectionView\n\nUICollectionView和UITableView很相似，如果你对表视图非常熟悉，上手的速度也会快很多。使用它时需要相应的设置DataSource（UICollectionViewDataSoure)数据源协议和Delegate（UICollectionViewDelegate)事件协议，并实现相应的协议方法。它与UITableView不同的地方是它有UICollectionViewLayout，可以通过它的子类来定制布局。系统默认的布局方式是UICollectionViewDelegateFlowLayout，实现相应的协议（UICollectionViewDelegateFlowLayout）方法，便可达到默认布局效果。\n\nUICollectionViewCell与UITableViewCell的使用也差不多，一样的有ReuseIdentifier,可以复用。使用UICollectionViewCell时，需要先注册，然后再出列使用。至于注册并出列使用Cell的具体方式，请自行下载文章末尾的BGWaterFlowView或者自行Google。\n\n（2）集成上下拉刷新方式\n\n一般UITableView添加上下拉刷新的方式，是把下拉或者上拉刷新视图的UI放置UITableView的表头属性(tableHeaderView)或者表尾属性（tableFooterView）。但是，在UICollectionView中没有这两个属性。那么我们该如何来集成上下拉刷新呢？这就得说到\nUICollectionView布局中的三种显示内容视图：Cells、Supplementary views、Decoration views。(关于这三种视图的介绍可以去官网查阅相关文档，上面有详细的解释)。我们一般是把上下拉刷新的UI放置在Supplementary views（官方解释：它能显示数据但是不同于Cells。不像Cell,Supplementary views是不能被用户选定的。相反，你可以用它去实现类似于给一个指定的section或者整个CollectionView添加页眉和页脚视图这样的功能）上面，其实，Supplementary views就和TableView的section头视图和尾视图差不多。但是用法却大不相同。在自定义瀑布流布局中一定要把它也计算进去，不然显示就会有异常。\n\n* **注册头视图和尾视图单元格类型**\n\n```\n//注册头视图：kind代表Supplementary视图类型，UICollectionElementKindSectionHeader表示组头\n\n[self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@\"bGCollectionHeaderView\"];\n\n//注册尾视图：UICollectionElementKindSectionHeader表示组尾\n\n    [self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@\"bGCollectionFooterView\"];\n    \n```\n\n* **实现自定义组视图viewForSupplementaryElementOfKind代理方法**\n\n\n```\n- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath {\n\n\t//kind代表Supplementary视图类型：头或尾视图（header OR footer）\n\t\n    if([kind isEqual:UICollectionElementKindSectionHeader]) {\n        UICollectionReusableView *collectionHeaderView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@\"bGCollectionHeaderView\" forIndexPath:indexPath];\n        \n        //初始化下拉刷新或者自定义页眉视图UI界面\n        ...\n        \n        return collectionHeaderView;\n    } else if([kind isEqual:UICollectionElementKindSectionFooter]) {\n        UICollectionReusableView *collectionFooterView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@\"bGCollectionFooterView\" forIndexPath:indexPath];\n        \n        //初始化上拉刷新或者自定义页脚视图UI界面\n        ...\n        \n        return collectionFooterView;\n    }\n    \n    return nil;\n}\n    \n```\n\n完成以上两步，集成上下拉刷新的功能总算完成了。接下来你可以运行一下工程，看结果是否符合预期。如果你CollectionView使用的是系统的UICollectionViewFlowLayout布局，一定要返回组头或者组尾的高度，否则就会出现组头或者组尾无法显示（本文的下拉刷新视图所在的组头不返回高度不受影响，是因为它的纵坐标（y值）本来就是负数）。另外，还有一点需要注意的是，如果你的CollectionView中存在多组，最好是把上下拉刷新所在的组头或者组尾与其他组（section）的组头或组尾分开，相应的需要多注册一个组头或者组尾视图，分情况进行判断(这部分如果还有问题，可以在文章末尾留言，我会及时回复)。\n\n#### 二、自定义瀑布流（WaterFlow）式布局\n\n（1）简单的介绍UICollectionView布局形式\n\n一般来讲，UICollectionView的布局形式分为两种：\n\n* 布局与内容独立，其布局不需要根据显示的单元格内容来计算。Cell的显示顺序与内容顺序一致。Cell排满一行则换至下一行继续排列。系统的UICollectionViewFlowLayout就是这样。\n\n* 布局需要计算内容，本文的瀑布流Demo局部正是如此。UICollectionViewFlowLayout系统布局在换行的时候，由于每个item高度不同，从而导致布局错乱，无法满足你的需求。所以，这个时候你需要计算每个item的高度，最终用来确定item显示的位置。\n\n从上述内容我们可以看出，一般如果布局需要计算内容的时候，我们就不应该直接使用UICollectionViewFlowLayout布局了，而是应该子类化一个UICollectionViewLayout，从而达到私人定制的目的。\n\n（2）创建自定义布局\n\n<a href = \"https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/CreatingCustomLayouts/CreatingCustomLayouts.html#//apple_ref/doc/uid/TP40012334-CH5-SW1\">官方文档</a>中有提到，在布局的过程中，CollectionView会调用布局对象的具体方法。这些方法有机会使你计算这些项的位置以及给CollectionView提供它所需要的主要信息。其他的方法也有可能会被调用，但是在布局的过程中这些方法总是会按照以下的顺序调用：\n\n1. 使用\"prepareLayout\"方法去执行一些CollectionView所需要的布局信息的预先计算操作。\n2. 使用\"collectionViewContentSize\"方法去返回根据你最初计算的整个内容区域的总体大小。\n3. 使用\"layoutAttributesForElementsInRect:\"方法来返回指定区域的单元格与视图属性。\n\n下面我们通过Demo来详细的讲解一下如何自定义瀑布流，废话不多说，直接上代码（本文采用的Demo为**BGWaterFlowView**,**GitHub传送门**：<a href = 'https://github.com/yangshebing/BGWaterFlowView'>请点击这里</a>）：\n\n* **重写\"prepareLayout\"方法计算布局信息。**\n\n```\n- (void)prepareLayout{\n    [super prepareLayout];\n    ...\n    \n    //计算每个显示项的宽度，horizontalItemSpacing代表项与项之间的水平间隔， \n    columnNum代表总列数，contentInset代表上下左右的内填充。详见下图说明\n    \n    self.itemWidth = (self.collectionView.frame.size.width - (self.horizontalItemSpacing * (self.columnNum - 1)) - self.contentInset.left - self.contentInset.right) / self.columnNum;\n    \n    //如有下拉刷新需求的则需要提供头视图（Supplementary view）布局属性。\n    demo中的headerHeight属性可设置是否显示头视图（是否计算头视图的布局属性）。\n    \n    if(self.headerHeight > 0){\n    \n    //通过layoutAttributesForSupplementaryViewOfKind:withIndexPath:方法来创建Supplementary视图布局属性对象，kind用来区分Supplementary视图类型（header或者footer）。\n    \n        self.headerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionHeader withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];\n        \n        //修改布局参数frame属性\n        \n        self.headerLayoutAttributes.frame = CGRectMake(0, 0, self.collectionView.frame.size.width, self.headerHeight);\n    }\n    \n    //初始化保存布局属性的字典\n    NSMutableDictionary *cellLayoutInfoDic = [NSMutableDictionary dictionary];\n    //初始化列高数组\n    NSMutableArray *columnInfoArray = [self columnInfoArray];\n    NSInteger numSections = [self.collectionView numberOfSections];\n    for(NSInteger section = 0; section < numSections; section++)  {\n        NSInteger numItems = [self.collectionView numberOfItemsInSection:section];\n        for(NSInteger item = 0; item < numItems; item++){\n            //获取列高最小的model，以它的高作为y坐标\n            BGWaterFlowModel *firstModel = columnInfoArray.firstObject;\n            CGFloat y = firstModel.height;\n            CGFloat x = self.contentInset.left + (self.horizontalItemSpacing + self.itemWidth) * firstModel.column;\n            \n            NSIndexPath *indexPath = [NSIndexPath indexPathForItem:item inSection:section];\n            \n            //通过代理方法传入对应item的高度。\n            \n            CGFloat itemHeight = [((id<BGWaterFlowLayoutDelegate>)self.collectionView.delegate) collectionView:self.collectionView layout:self heightForItemAtIndexPath:indexPath];\n            \n            //通过layoutAttributesForCellWithIndexPath:方法来创建cell的布局属性对象。\n            \n            UICollectionViewLayoutAttributes *itemAttributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];\n            //计算item的布局属性\n            itemAttributes.frame = CGRectMake(x, y+self.contentInset.top+self.headerHeight, self.itemWidth, itemHeight);\n            //计算当前列高,verticalItemSpacing代表项与项之间的垂直间隔。\n            firstModel.height += (itemHeight + self.verticalItemSpacing);\n            //保存新的列高，并进行排序：从后往前查找，查找到高度比它小的对象，就插入到该对象之后。\n            [self sortArrayByHeight:columnInfoArray];\n            \n     //保存计算好的item布局属性\n     cellLayoutInfoDic[indexPath] = itemAttributes;\n        }\n    }\n    \n    //保存局部布局属性字典到全局字典中\n    self.cellLayoutInfoDic = [cellLayoutInfoDic copy];\n    \n    //按照前面的排序逻辑，列高数组中的最后一个元素，就是高度最大的一列。\n    BGWaterFlowModel *lastModel = columnInfoArray.lastObject;\n    \n    //如有上拉刷新需求的则需要提供尾视图布局属性。\n    demo中的footerHeight属性可设置是否显示尾视图（是否计算尾视图的布局属性）。\n    \n    if(self.footerHeight > 0){\n        self.footerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionFooter withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];\n        //计算尾视图的布局属性\n        self.footerLayoutAttributes.frame = CGRectMake(0, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom, self.collectionView.frame.size.width, self.footerHeight);\n    }\n    \n    //直接计算出collectionView的contentSize\n    self.contentSize = CGSizeMake(self.collectionView.frame.size.width, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom+self.footerHeight);\n}\n\n```\n\n**好吧，这么一大坨代码看到就头疼了，来张图帮助理解一下！图糙理不糙，理解万岁**\n![](http://ww4.sinaimg.cn/mw690/7f266405jw1ey25ujzticj218a0xmjww.jpg)\n\n**这样看上去是不是更清晰了？**\n\n\n* **重写\"collectionViewContentSize\"方法返回collectionView的内容高度。**\n\n```\n\n- (CGSize)collectionViewContentSize{\n \t//返回计算好的collectionView内容高度\n    return self.contentSize;\n}\n\n```\n\n* **重写\"layoutAttributesForElementsInRect\"方法返回指定矩形区域中的cell或者其他类型视图布局属性。**\n\n```\n- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect {\n\n\t//返回一组已经计算好的布局属性。\n\t\n    NSMutableArray *attributesArrs = [NSMutableArray array];\n    [self.cellLayoutInfoDic enumerateKeysAndObjectsUsingBlock:^(NSIndexPath *indexPath,\n                                                                UICollectionViewLayoutAttributes *attributes,\n                                                                BOOL *stop) { \n        //遍历布局属性保存字典，添加布局属性至数组中                                                       \n        if (CGRectIntersectsRect(rect, attributes.frame)) {\n            [attributesArrs addObject:attributes];\n        }\n    }];\n    \n    //如果有头视图或者尾视图则需要添加头视图与尾视图的布局属性\n    \n    if (self.headerLayoutAttributes && CGRectIntersectsRect(rect, self.headerLayoutAttributes.frame)) {\n        [attributesArrs addObject:self.headerLayoutAttributes];\n    }\n    \n    \n    if (self.footerLayoutAttributes && CGRectIntersectsRect(rect, self.footerLayoutAttributes.frame)) {\n        [attributesArrs addObject:self.footerLayoutAttributes];\n    }\n    \n    return attributesArrs;\n}\n```\n#### 结语：\n\n<a href = \"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/index.html#//apple_ref/occ/cl/UICollectionViewLayout\">UICollectionViewLayout</a>相关的内容姿势非常多，相关文章也非常多。本文介绍的瀑布流布局也只是其中的冰山一角，很多东西官方文档中已经介绍的非常详细了。所以，还是建议多看官方文档。本文主要注重项目的实用性，在后面就直接上代码了，可能在理论方面还是有所欠缺，对于不足的地方，希望大家多提建议，一起交流学习，一起进步。如果文中有看不懂的地方，还请您留言。我会及时进行回复。最后，本文的Demo就在于方便徒手撸代码的人使用。你懂的。后期会不断的更新优化，进一步的完善。敬请期待...\n\n点击此处下载本文的Demo:<a href = 'https://github.com/yangshebing/BGWaterFlowView'>**BGWaterFlowView**</a>\n\nDemo使用方式详见:<a href = \"https://github.com/yangshebing/BGWaterFlowView/blob/master/README.md\">**README.md**</a>\n\nDemo运行瀑布流效果截图如下所示:\n\n<img src=\"http://ww2.sinaimg.cn/large/7f266405jw1ey0z6x4xf9j20ku12aqb5.jpg\"/ width = \"375\" height = \"677\" align = \"center\">\n\n###### 参考博客地址： \n* <a href = \"http://objccn.io/issue-3-3/\">自定义 Collection View 布局</a>\n\n转载请注明出处\n","source":"_posts/2015-11-03-waterflow.markdown","raw":"---\nlayout: post\ntitle: \"UICollectionView（纯代码方式）实现带上下拉刷新的瀑布流式（WaterFlow）布局\"\ndate: 2015-11-03 22:40:32 +0800\ncomments: true\ntags: [iOS9, Xcode7.1, UICollectionView]\nkeywords: UICollectionView, WaterFlow, FlowLayout, 下拉刷新\ncategories: Objective-C\n---\n\n瀑布流（WaterFlow）是项目开发过程中的常见布局，有关于瀑布流（WaterFlow）的实现方式：在UICollectionView未出现之前，瀑布流的实现多半是采用UIScrollView或是UITableView。对于我们这种用惯了表视图的人来说，UICollectionView倒略显陌生。有关于UICollectionView的介绍我就不一一赘述，因为一两句话也很难说清楚。网上有很多优秀的文章专门对其进行了一系列的解说，另有苹果官方文档可以查阅。本文主要是介绍如何采用纯代码的方式利用UICollectionView实现带上下拉刷新的瀑布流式（WaterFlow）布局。废话少说，直接入题。\n<!--more-->\n#### 一、UICollectionView集成上下拉刷新\n\n（1）简单的介绍UICollectionView\n\nUICollectionView和UITableView很相似，如果你对表视图非常熟悉，上手的速度也会快很多。使用它时需要相应的设置DataSource（UICollectionViewDataSoure)数据源协议和Delegate（UICollectionViewDelegate)事件协议，并实现相应的协议方法。它与UITableView不同的地方是它有UICollectionViewLayout，可以通过它的子类来定制布局。系统默认的布局方式是UICollectionViewDelegateFlowLayout，实现相应的协议（UICollectionViewDelegateFlowLayout）方法，便可达到默认布局效果。\n\nUICollectionViewCell与UITableViewCell的使用也差不多，一样的有ReuseIdentifier,可以复用。使用UICollectionViewCell时，需要先注册，然后再出列使用。至于注册并出列使用Cell的具体方式，请自行下载文章末尾的BGWaterFlowView或者自行Google。\n\n（2）集成上下拉刷新方式\n\n一般UITableView添加上下拉刷新的方式，是把下拉或者上拉刷新视图的UI放置UITableView的表头属性(tableHeaderView)或者表尾属性（tableFooterView）。但是，在UICollectionView中没有这两个属性。那么我们该如何来集成上下拉刷新呢？这就得说到\nUICollectionView布局中的三种显示内容视图：Cells、Supplementary views、Decoration views。(关于这三种视图的介绍可以去官网查阅相关文档，上面有详细的解释)。我们一般是把上下拉刷新的UI放置在Supplementary views（官方解释：它能显示数据但是不同于Cells。不像Cell,Supplementary views是不能被用户选定的。相反，你可以用它去实现类似于给一个指定的section或者整个CollectionView添加页眉和页脚视图这样的功能）上面，其实，Supplementary views就和TableView的section头视图和尾视图差不多。但是用法却大不相同。在自定义瀑布流布局中一定要把它也计算进去，不然显示就会有异常。\n\n* **注册头视图和尾视图单元格类型**\n\n```\n//注册头视图：kind代表Supplementary视图类型，UICollectionElementKindSectionHeader表示组头\n\n[self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@\"bGCollectionHeaderView\"];\n\n//注册尾视图：UICollectionElementKindSectionHeader表示组尾\n\n    [self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@\"bGCollectionFooterView\"];\n    \n```\n\n* **实现自定义组视图viewForSupplementaryElementOfKind代理方法**\n\n\n```\n- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath {\n\n\t//kind代表Supplementary视图类型：头或尾视图（header OR footer）\n\t\n    if([kind isEqual:UICollectionElementKindSectionHeader]) {\n        UICollectionReusableView *collectionHeaderView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@\"bGCollectionHeaderView\" forIndexPath:indexPath];\n        \n        //初始化下拉刷新或者自定义页眉视图UI界面\n        ...\n        \n        return collectionHeaderView;\n    } else if([kind isEqual:UICollectionElementKindSectionFooter]) {\n        UICollectionReusableView *collectionFooterView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@\"bGCollectionFooterView\" forIndexPath:indexPath];\n        \n        //初始化上拉刷新或者自定义页脚视图UI界面\n        ...\n        \n        return collectionFooterView;\n    }\n    \n    return nil;\n}\n    \n```\n\n完成以上两步，集成上下拉刷新的功能总算完成了。接下来你可以运行一下工程，看结果是否符合预期。如果你CollectionView使用的是系统的UICollectionViewFlowLayout布局，一定要返回组头或者组尾的高度，否则就会出现组头或者组尾无法显示（本文的下拉刷新视图所在的组头不返回高度不受影响，是因为它的纵坐标（y值）本来就是负数）。另外，还有一点需要注意的是，如果你的CollectionView中存在多组，最好是把上下拉刷新所在的组头或者组尾与其他组（section）的组头或组尾分开，相应的需要多注册一个组头或者组尾视图，分情况进行判断(这部分如果还有问题，可以在文章末尾留言，我会及时回复)。\n\n#### 二、自定义瀑布流（WaterFlow）式布局\n\n（1）简单的介绍UICollectionView布局形式\n\n一般来讲，UICollectionView的布局形式分为两种：\n\n* 布局与内容独立，其布局不需要根据显示的单元格内容来计算。Cell的显示顺序与内容顺序一致。Cell排满一行则换至下一行继续排列。系统的UICollectionViewFlowLayout就是这样。\n\n* 布局需要计算内容，本文的瀑布流Demo局部正是如此。UICollectionViewFlowLayout系统布局在换行的时候，由于每个item高度不同，从而导致布局错乱，无法满足你的需求。所以，这个时候你需要计算每个item的高度，最终用来确定item显示的位置。\n\n从上述内容我们可以看出，一般如果布局需要计算内容的时候，我们就不应该直接使用UICollectionViewFlowLayout布局了，而是应该子类化一个UICollectionViewLayout，从而达到私人定制的目的。\n\n（2）创建自定义布局\n\n<a href = \"https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/CreatingCustomLayouts/CreatingCustomLayouts.html#//apple_ref/doc/uid/TP40012334-CH5-SW1\">官方文档</a>中有提到，在布局的过程中，CollectionView会调用布局对象的具体方法。这些方法有机会使你计算这些项的位置以及给CollectionView提供它所需要的主要信息。其他的方法也有可能会被调用，但是在布局的过程中这些方法总是会按照以下的顺序调用：\n\n1. 使用\"prepareLayout\"方法去执行一些CollectionView所需要的布局信息的预先计算操作。\n2. 使用\"collectionViewContentSize\"方法去返回根据你最初计算的整个内容区域的总体大小。\n3. 使用\"layoutAttributesForElementsInRect:\"方法来返回指定区域的单元格与视图属性。\n\n下面我们通过Demo来详细的讲解一下如何自定义瀑布流，废话不多说，直接上代码（本文采用的Demo为**BGWaterFlowView**,**GitHub传送门**：<a href = 'https://github.com/yangshebing/BGWaterFlowView'>请点击这里</a>）：\n\n* **重写\"prepareLayout\"方法计算布局信息。**\n\n```\n- (void)prepareLayout{\n    [super prepareLayout];\n    ...\n    \n    //计算每个显示项的宽度，horizontalItemSpacing代表项与项之间的水平间隔， \n    columnNum代表总列数，contentInset代表上下左右的内填充。详见下图说明\n    \n    self.itemWidth = (self.collectionView.frame.size.width - (self.horizontalItemSpacing * (self.columnNum - 1)) - self.contentInset.left - self.contentInset.right) / self.columnNum;\n    \n    //如有下拉刷新需求的则需要提供头视图（Supplementary view）布局属性。\n    demo中的headerHeight属性可设置是否显示头视图（是否计算头视图的布局属性）。\n    \n    if(self.headerHeight > 0){\n    \n    //通过layoutAttributesForSupplementaryViewOfKind:withIndexPath:方法来创建Supplementary视图布局属性对象，kind用来区分Supplementary视图类型（header或者footer）。\n    \n        self.headerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionHeader withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];\n        \n        //修改布局参数frame属性\n        \n        self.headerLayoutAttributes.frame = CGRectMake(0, 0, self.collectionView.frame.size.width, self.headerHeight);\n    }\n    \n    //初始化保存布局属性的字典\n    NSMutableDictionary *cellLayoutInfoDic = [NSMutableDictionary dictionary];\n    //初始化列高数组\n    NSMutableArray *columnInfoArray = [self columnInfoArray];\n    NSInteger numSections = [self.collectionView numberOfSections];\n    for(NSInteger section = 0; section < numSections; section++)  {\n        NSInteger numItems = [self.collectionView numberOfItemsInSection:section];\n        for(NSInteger item = 0; item < numItems; item++){\n            //获取列高最小的model，以它的高作为y坐标\n            BGWaterFlowModel *firstModel = columnInfoArray.firstObject;\n            CGFloat y = firstModel.height;\n            CGFloat x = self.contentInset.left + (self.horizontalItemSpacing + self.itemWidth) * firstModel.column;\n            \n            NSIndexPath *indexPath = [NSIndexPath indexPathForItem:item inSection:section];\n            \n            //通过代理方法传入对应item的高度。\n            \n            CGFloat itemHeight = [((id<BGWaterFlowLayoutDelegate>)self.collectionView.delegate) collectionView:self.collectionView layout:self heightForItemAtIndexPath:indexPath];\n            \n            //通过layoutAttributesForCellWithIndexPath:方法来创建cell的布局属性对象。\n            \n            UICollectionViewLayoutAttributes *itemAttributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];\n            //计算item的布局属性\n            itemAttributes.frame = CGRectMake(x, y+self.contentInset.top+self.headerHeight, self.itemWidth, itemHeight);\n            //计算当前列高,verticalItemSpacing代表项与项之间的垂直间隔。\n            firstModel.height += (itemHeight + self.verticalItemSpacing);\n            //保存新的列高，并进行排序：从后往前查找，查找到高度比它小的对象，就插入到该对象之后。\n            [self sortArrayByHeight:columnInfoArray];\n            \n     //保存计算好的item布局属性\n     cellLayoutInfoDic[indexPath] = itemAttributes;\n        }\n    }\n    \n    //保存局部布局属性字典到全局字典中\n    self.cellLayoutInfoDic = [cellLayoutInfoDic copy];\n    \n    //按照前面的排序逻辑，列高数组中的最后一个元素，就是高度最大的一列。\n    BGWaterFlowModel *lastModel = columnInfoArray.lastObject;\n    \n    //如有上拉刷新需求的则需要提供尾视图布局属性。\n    demo中的footerHeight属性可设置是否显示尾视图（是否计算尾视图的布局属性）。\n    \n    if(self.footerHeight > 0){\n        self.footerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionFooter withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];\n        //计算尾视图的布局属性\n        self.footerLayoutAttributes.frame = CGRectMake(0, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom, self.collectionView.frame.size.width, self.footerHeight);\n    }\n    \n    //直接计算出collectionView的contentSize\n    self.contentSize = CGSizeMake(self.collectionView.frame.size.width, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom+self.footerHeight);\n}\n\n```\n\n**好吧，这么一大坨代码看到就头疼了，来张图帮助理解一下！图糙理不糙，理解万岁**\n![](http://ww4.sinaimg.cn/mw690/7f266405jw1ey25ujzticj218a0xmjww.jpg)\n\n**这样看上去是不是更清晰了？**\n\n\n* **重写\"collectionViewContentSize\"方法返回collectionView的内容高度。**\n\n```\n\n- (CGSize)collectionViewContentSize{\n \t//返回计算好的collectionView内容高度\n    return self.contentSize;\n}\n\n```\n\n* **重写\"layoutAttributesForElementsInRect\"方法返回指定矩形区域中的cell或者其他类型视图布局属性。**\n\n```\n- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect {\n\n\t//返回一组已经计算好的布局属性。\n\t\n    NSMutableArray *attributesArrs = [NSMutableArray array];\n    [self.cellLayoutInfoDic enumerateKeysAndObjectsUsingBlock:^(NSIndexPath *indexPath,\n                                                                UICollectionViewLayoutAttributes *attributes,\n                                                                BOOL *stop) { \n        //遍历布局属性保存字典，添加布局属性至数组中                                                       \n        if (CGRectIntersectsRect(rect, attributes.frame)) {\n            [attributesArrs addObject:attributes];\n        }\n    }];\n    \n    //如果有头视图或者尾视图则需要添加头视图与尾视图的布局属性\n    \n    if (self.headerLayoutAttributes && CGRectIntersectsRect(rect, self.headerLayoutAttributes.frame)) {\n        [attributesArrs addObject:self.headerLayoutAttributes];\n    }\n    \n    \n    if (self.footerLayoutAttributes && CGRectIntersectsRect(rect, self.footerLayoutAttributes.frame)) {\n        [attributesArrs addObject:self.footerLayoutAttributes];\n    }\n    \n    return attributesArrs;\n}\n```\n#### 结语：\n\n<a href = \"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/index.html#//apple_ref/occ/cl/UICollectionViewLayout\">UICollectionViewLayout</a>相关的内容姿势非常多，相关文章也非常多。本文介绍的瀑布流布局也只是其中的冰山一角，很多东西官方文档中已经介绍的非常详细了。所以，还是建议多看官方文档。本文主要注重项目的实用性，在后面就直接上代码了，可能在理论方面还是有所欠缺，对于不足的地方，希望大家多提建议，一起交流学习，一起进步。如果文中有看不懂的地方，还请您留言。我会及时进行回复。最后，本文的Demo就在于方便徒手撸代码的人使用。你懂的。后期会不断的更新优化，进一步的完善。敬请期待...\n\n点击此处下载本文的Demo:<a href = 'https://github.com/yangshebing/BGWaterFlowView'>**BGWaterFlowView**</a>\n\nDemo使用方式详见:<a href = \"https://github.com/yangshebing/BGWaterFlowView/blob/master/README.md\">**README.md**</a>\n\nDemo运行瀑布流效果截图如下所示:\n\n<img src=\"http://ww2.sinaimg.cn/large/7f266405jw1ey0z6x4xf9j20ku12aqb5.jpg\"/ width = \"375\" height = \"677\" align = \"center\">\n\n###### 参考博客地址： \n* <a href = \"http://objccn.io/issue-3-3/\">自定义 Collection View 布局</a>\n\n转载请注明出处\n","slug":"waterflow","published":1,"updated":"2016-09-10T05:17:10.000Z","_id":"ciswie9cd0005e3u21c8u1bym","photos":[],"link":"","content":"<p>瀑布流（WaterFlow）是项目开发过程中的常见布局，有关于瀑布流（WaterFlow）的实现方式：在UICollectionView未出现之前，瀑布流的实现多半是采用UIScrollView或是UITableView。对于我们这种用惯了表视图的人来说，UICollectionView倒略显陌生。有关于UICollectionView的介绍我就不一一赘述，因为一两句话也很难说清楚。网上有很多优秀的文章专门对其进行了一系列的解说，另有苹果官方文档可以查阅。本文主要是介绍如何采用纯代码的方式利用UICollectionView实现带上下拉刷新的瀑布流式（WaterFlow）布局。废话少说，直接入题。<br><a id=\"more\"></a></p>\n<h4 id=\"一、UICollectionView集成上下拉刷新\"><a href=\"#一、UICollectionView集成上下拉刷新\" class=\"headerlink\" title=\"一、UICollectionView集成上下拉刷新\"></a>一、UICollectionView集成上下拉刷新</h4><p>（1）简单的介绍UICollectionView</p>\n<p>UICollectionView和UITableView很相似，如果你对表视图非常熟悉，上手的速度也会快很多。使用它时需要相应的设置DataSource（UICollectionViewDataSoure)数据源协议和Delegate（UICollectionViewDelegate)事件协议，并实现相应的协议方法。它与UITableView不同的地方是它有UICollectionViewLayout，可以通过它的子类来定制布局。系统默认的布局方式是UICollectionViewDelegateFlowLayout，实现相应的协议（UICollectionViewDelegateFlowLayout）方法，便可达到默认布局效果。</p>\n<p>UICollectionViewCell与UITableViewCell的使用也差不多，一样的有ReuseIdentifier,可以复用。使用UICollectionViewCell时，需要先注册，然后再出列使用。至于注册并出列使用Cell的具体方式，请自行下载文章末尾的BGWaterFlowView或者自行Google。</p>\n<p>（2）集成上下拉刷新方式</p>\n<p>一般UITableView添加上下拉刷新的方式，是把下拉或者上拉刷新视图的UI放置UITableView的表头属性(tableHeaderView)或者表尾属性（tableFooterView）。但是，在UICollectionView中没有这两个属性。那么我们该如何来集成上下拉刷新呢？这就得说到<br>UICollectionView布局中的三种显示内容视图：Cells、Supplementary views、Decoration views。(关于这三种视图的介绍可以去官网查阅相关文档，上面有详细的解释)。我们一般是把上下拉刷新的UI放置在Supplementary views（官方解释：它能显示数据但是不同于Cells。不像Cell,Supplementary views是不能被用户选定的。相反，你可以用它去实现类似于给一个指定的section或者整个CollectionView添加页眉和页脚视图这样的功能）上面，其实，Supplementary views就和TableView的section头视图和尾视图差不多。但是用法却大不相同。在自定义瀑布流布局中一定要把它也计算进去，不然显示就会有异常。</p>\n<ul>\n<li><strong>注册头视图和尾视图单元格类型</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//注册头视图：kind代表Supplementary视图类型，UICollectionElementKindSectionHeader表示组头</div><div class=\"line\"></div><div class=\"line\">[self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@&quot;bGCollectionHeaderView&quot;];</div><div class=\"line\"></div><div class=\"line\">//注册尾视图：UICollectionElementKindSectionHeader表示组尾</div><div class=\"line\"></div><div class=\"line\">    [self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@&quot;bGCollectionFooterView&quot;];</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>实现自定义组视图viewForSupplementaryElementOfKind代理方法</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath &#123;</div><div class=\"line\"></div><div class=\"line\">\t//kind代表Supplementary视图类型：头或尾视图（header OR footer）</div><div class=\"line\">\t</div><div class=\"line\">    if([kind isEqual:UICollectionElementKindSectionHeader]) &#123;</div><div class=\"line\">        UICollectionReusableView *collectionHeaderView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@&quot;bGCollectionHeaderView&quot; forIndexPath:indexPath];</div><div class=\"line\">        </div><div class=\"line\">        //初始化下拉刷新或者自定义页眉视图UI界面</div><div class=\"line\">        ...</div><div class=\"line\">        </div><div class=\"line\">        return collectionHeaderView;</div><div class=\"line\">    &#125; else if([kind isEqual:UICollectionElementKindSectionFooter]) &#123;</div><div class=\"line\">        UICollectionReusableView *collectionFooterView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@&quot;bGCollectionFooterView&quot; forIndexPath:indexPath];</div><div class=\"line\">        </div><div class=\"line\">        //初始化上拉刷新或者自定义页脚视图UI界面</div><div class=\"line\">        ...</div><div class=\"line\">        </div><div class=\"line\">        return collectionFooterView;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>完成以上两步，集成上下拉刷新的功能总算完成了。接下来你可以运行一下工程，看结果是否符合预期。如果你CollectionView使用的是系统的UICollectionViewFlowLayout布局，一定要返回组头或者组尾的高度，否则就会出现组头或者组尾无法显示（本文的下拉刷新视图所在的组头不返回高度不受影响，是因为它的纵坐标（y值）本来就是负数）。另外，还有一点需要注意的是，如果你的CollectionView中存在多组，最好是把上下拉刷新所在的组头或者组尾与其他组（section）的组头或组尾分开，相应的需要多注册一个组头或者组尾视图，分情况进行判断(这部分如果还有问题，可以在文章末尾留言，我会及时回复)。</p>\n<h4 id=\"二、自定义瀑布流（WaterFlow）式布局\"><a href=\"#二、自定义瀑布流（WaterFlow）式布局\" class=\"headerlink\" title=\"二、自定义瀑布流（WaterFlow）式布局\"></a>二、自定义瀑布流（WaterFlow）式布局</h4><p>（1）简单的介绍UICollectionView布局形式</p>\n<p>一般来讲，UICollectionView的布局形式分为两种：</p>\n<ul>\n<li><p>布局与内容独立，其布局不需要根据显示的单元格内容来计算。Cell的显示顺序与内容顺序一致。Cell排满一行则换至下一行继续排列。系统的UICollectionViewFlowLayout就是这样。</p>\n</li>\n<li><p>布局需要计算内容，本文的瀑布流Demo局部正是如此。UICollectionViewFlowLayout系统布局在换行的时候，由于每个item高度不同，从而导致布局错乱，无法满足你的需求。所以，这个时候你需要计算每个item的高度，最终用来确定item显示的位置。</p>\n</li>\n</ul>\n<p>从上述内容我们可以看出，一般如果布局需要计算内容的时候，我们就不应该直接使用UICollectionViewFlowLayout布局了，而是应该子类化一个UICollectionViewLayout，从而达到私人定制的目的。</p>\n<p>（2）创建自定义布局</p>\n<p><a href=\"https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/CreatingCustomLayouts/CreatingCustomLayouts.html#//apple_ref/doc/uid/TP40012334-CH5-SW1\" target=\"_blank\" rel=\"external\">官方文档</a>中有提到，在布局的过程中，CollectionView会调用布局对象的具体方法。这些方法有机会使你计算这些项的位置以及给CollectionView提供它所需要的主要信息。其他的方法也有可能会被调用，但是在布局的过程中这些方法总是会按照以下的顺序调用：</p>\n<ol>\n<li>使用”prepareLayout”方法去执行一些CollectionView所需要的布局信息的预先计算操作。</li>\n<li>使用”collectionViewContentSize”方法去返回根据你最初计算的整个内容区域的总体大小。</li>\n<li>使用”layoutAttributesForElementsInRect:”方法来返回指定区域的单元格与视图属性。</li>\n</ol>\n<p>下面我们通过Demo来详细的讲解一下如何自定义瀑布流，废话不多说，直接上代码（本文采用的Demo为<strong>BGWaterFlowView</strong>,<strong>GitHub传送门</strong>：<a href=\"https://github.com/yangshebing/BGWaterFlowView\" target=\"_blank\" rel=\"external\">请点击这里</a>）：</p>\n<ul>\n<li><strong>重写”prepareLayout”方法计算布局信息。</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)prepareLayout&#123;</div><div class=\"line\">    [super prepareLayout];</div><div class=\"line\">    ...</div><div class=\"line\">    </div><div class=\"line\">    //计算每个显示项的宽度，horizontalItemSpacing代表项与项之间的水平间隔， </div><div class=\"line\">    columnNum代表总列数，contentInset代表上下左右的内填充。详见下图说明</div><div class=\"line\">    </div><div class=\"line\">    self.itemWidth = (self.collectionView.frame.size.width - (self.horizontalItemSpacing * (self.columnNum - 1)) - self.contentInset.left - self.contentInset.right) / self.columnNum;</div><div class=\"line\">    </div><div class=\"line\">    //如有下拉刷新需求的则需要提供头视图（Supplementary view）布局属性。</div><div class=\"line\">    demo中的headerHeight属性可设置是否显示头视图（是否计算头视图的布局属性）。</div><div class=\"line\">    </div><div class=\"line\">    if(self.headerHeight &gt; 0)&#123;</div><div class=\"line\">    </div><div class=\"line\">    //通过layoutAttributesForSupplementaryViewOfKind:withIndexPath:方法来创建Supplementary视图布局属性对象，kind用来区分Supplementary视图类型（header或者footer）。</div><div class=\"line\">    </div><div class=\"line\">        self.headerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionHeader withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];</div><div class=\"line\">        </div><div class=\"line\">        //修改布局参数frame属性</div><div class=\"line\">        </div><div class=\"line\">        self.headerLayoutAttributes.frame = CGRectMake(0, 0, self.collectionView.frame.size.width, self.headerHeight);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //初始化保存布局属性的字典</div><div class=\"line\">    NSMutableDictionary *cellLayoutInfoDic = [NSMutableDictionary dictionary];</div><div class=\"line\">    //初始化列高数组</div><div class=\"line\">    NSMutableArray *columnInfoArray = [self columnInfoArray];</div><div class=\"line\">    NSInteger numSections = [self.collectionView numberOfSections];</div><div class=\"line\">    for(NSInteger section = 0; section &lt; numSections; section++)  &#123;</div><div class=\"line\">        NSInteger numItems = [self.collectionView numberOfItemsInSection:section];</div><div class=\"line\">        for(NSInteger item = 0; item &lt; numItems; item++)&#123;</div><div class=\"line\">            //获取列高最小的model，以它的高作为y坐标</div><div class=\"line\">            BGWaterFlowModel *firstModel = columnInfoArray.firstObject;</div><div class=\"line\">            CGFloat y = firstModel.height;</div><div class=\"line\">            CGFloat x = self.contentInset.left + (self.horizontalItemSpacing + self.itemWidth) * firstModel.column;</div><div class=\"line\">            </div><div class=\"line\">            NSIndexPath *indexPath = [NSIndexPath indexPathForItem:item inSection:section];</div><div class=\"line\">            </div><div class=\"line\">            //通过代理方法传入对应item的高度。</div><div class=\"line\">            </div><div class=\"line\">            CGFloat itemHeight = [((id&lt;BGWaterFlowLayoutDelegate&gt;)self.collectionView.delegate) collectionView:self.collectionView layout:self heightForItemAtIndexPath:indexPath];</div><div class=\"line\">            </div><div class=\"line\">            //通过layoutAttributesForCellWithIndexPath:方法来创建cell的布局属性对象。</div><div class=\"line\">            </div><div class=\"line\">            UICollectionViewLayoutAttributes *itemAttributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];</div><div class=\"line\">            //计算item的布局属性</div><div class=\"line\">            itemAttributes.frame = CGRectMake(x, y+self.contentInset.top+self.headerHeight, self.itemWidth, itemHeight);</div><div class=\"line\">            //计算当前列高,verticalItemSpacing代表项与项之间的垂直间隔。</div><div class=\"line\">            firstModel.height += (itemHeight + self.verticalItemSpacing);</div><div class=\"line\">            //保存新的列高，并进行排序：从后往前查找，查找到高度比它小的对象，就插入到该对象之后。</div><div class=\"line\">            [self sortArrayByHeight:columnInfoArray];</div><div class=\"line\">            </div><div class=\"line\">     //保存计算好的item布局属性</div><div class=\"line\">     cellLayoutInfoDic[indexPath] = itemAttributes;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //保存局部布局属性字典到全局字典中</div><div class=\"line\">    self.cellLayoutInfoDic = [cellLayoutInfoDic copy];</div><div class=\"line\">    </div><div class=\"line\">    //按照前面的排序逻辑，列高数组中的最后一个元素，就是高度最大的一列。</div><div class=\"line\">    BGWaterFlowModel *lastModel = columnInfoArray.lastObject;</div><div class=\"line\">    </div><div class=\"line\">    //如有上拉刷新需求的则需要提供尾视图布局属性。</div><div class=\"line\">    demo中的footerHeight属性可设置是否显示尾视图（是否计算尾视图的布局属性）。</div><div class=\"line\">    </div><div class=\"line\">    if(self.footerHeight &gt; 0)&#123;</div><div class=\"line\">        self.footerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionFooter withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];</div><div class=\"line\">        //计算尾视图的布局属性</div><div class=\"line\">        self.footerLayoutAttributes.frame = CGRectMake(0, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom, self.collectionView.frame.size.width, self.footerHeight);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //直接计算出collectionView的contentSize</div><div class=\"line\">    self.contentSize = CGSizeMake(self.collectionView.frame.size.width, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom+self.footerHeight);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>好吧，这么一大坨代码看到就头疼了，来张图帮助理解一下！图糙理不糙，理解万岁</strong><br><img src=\"http://ww4.sinaimg.cn/mw690/7f266405jw1ey25ujzticj218a0xmjww.jpg\" alt=\"\"></p>\n<p><strong>这样看上去是不是更清晰了？</strong></p>\n<ul>\n<li><strong>重写”collectionViewContentSize”方法返回collectionView的内容高度。</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- (CGSize)collectionViewContentSize&#123;</div><div class=\"line\"> \t//返回计算好的collectionView内容高度</div><div class=\"line\">    return self.contentSize;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>重写”layoutAttributesForElementsInRect”方法返回指定矩形区域中的cell或者其他类型视图布局属性。</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect &#123;</div><div class=\"line\"></div><div class=\"line\">\t//返回一组已经计算好的布局属性。</div><div class=\"line\">\t</div><div class=\"line\">    NSMutableArray *attributesArrs = [NSMutableArray array];</div><div class=\"line\">    [self.cellLayoutInfoDic enumerateKeysAndObjectsUsingBlock:^(NSIndexPath *indexPath,</div><div class=\"line\">                                                                UICollectionViewLayoutAttributes *attributes,</div><div class=\"line\">                                                                BOOL *stop) &#123; </div><div class=\"line\">        //遍历布局属性保存字典，添加布局属性至数组中                                                       </div><div class=\"line\">        if (CGRectIntersectsRect(rect, attributes.frame)) &#123;</div><div class=\"line\">            [attributesArrs addObject:attributes];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div><div class=\"line\">    </div><div class=\"line\">    //如果有头视图或者尾视图则需要添加头视图与尾视图的布局属性</div><div class=\"line\">    </div><div class=\"line\">    if (self.headerLayoutAttributes &amp;&amp; CGRectIntersectsRect(rect, self.headerLayoutAttributes.frame)) &#123;</div><div class=\"line\">        [attributesArrs addObject:self.headerLayoutAttributes];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    if (self.footerLayoutAttributes &amp;&amp; CGRectIntersectsRect(rect, self.footerLayoutAttributes.frame)) &#123;</div><div class=\"line\">        [attributesArrs addObject:self.footerLayoutAttributes];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    return attributesArrs;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"结语：\"><a href=\"#结语：\" class=\"headerlink\" title=\"结语：\"></a>结语：</h4><p><a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/index.html#//apple_ref/occ/cl/UICollectionViewLayout\" target=\"_blank\" rel=\"external\">UICollectionViewLayout</a>相关的内容姿势非常多，相关文章也非常多。本文介绍的瀑布流布局也只是其中的冰山一角，很多东西官方文档中已经介绍的非常详细了。所以，还是建议多看官方文档。本文主要注重项目的实用性，在后面就直接上代码了，可能在理论方面还是有所欠缺，对于不足的地方，希望大家多提建议，一起交流学习，一起进步。如果文中有看不懂的地方，还请您留言。我会及时进行回复。最后，本文的Demo就在于方便徒手撸代码的人使用。你懂的。后期会不断的更新优化，进一步的完善。敬请期待…</p>\n<p>点击此处下载本文的Demo:<a href=\"https://github.com/yangshebing/BGWaterFlowView\" target=\"_blank\" rel=\"external\"><strong>BGWaterFlowView</strong></a></p>\n<p>Demo使用方式详见:<a href=\"https://github.com/yangshebing/BGWaterFlowView/blob/master/README.md\" target=\"_blank\" rel=\"external\"><strong>README.md</strong></a></p>\n<p>Demo运行瀑布流效果截图如下所示:</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/7f266405jw1ey0z6x4xf9j20ku12aqb5.jpg\" width=\"375\" height=\"677\" align=\"center\"></p>\n<h6 id=\"参考博客地址：\"><a href=\"#参考博客地址：\" class=\"headerlink\" title=\"参考博客地址：\"></a>参考博客地址：</h6><ul>\n<li><a href=\"http://objccn.io/issue-3-3/\" target=\"_blank\" rel=\"external\">自定义 Collection View 布局</a></li>\n</ul>\n<p>转载请注明出处</p>\n","excerpt":"<p>瀑布流（WaterFlow）是项目开发过程中的常见布局，有关于瀑布流（WaterFlow）的实现方式：在UICollectionView未出现之前，瀑布流的实现多半是采用UIScrollView或是UITableView。对于我们这种用惯了表视图的人来说，UICollectionView倒略显陌生。有关于UICollectionView的介绍我就不一一赘述，因为一两句话也很难说清楚。网上有很多优秀的文章专门对其进行了一系列的解说，另有苹果官方文档可以查阅。本文主要是介绍如何采用纯代码的方式利用UICollectionView实现带上下拉刷新的瀑布流式（WaterFlow）布局。废话少说，直接入题。<br>","more":"</p>\n<h4 id=\"一、UICollectionView集成上下拉刷新\"><a href=\"#一、UICollectionView集成上下拉刷新\" class=\"headerlink\" title=\"一、UICollectionView集成上下拉刷新\"></a>一、UICollectionView集成上下拉刷新</h4><p>（1）简单的介绍UICollectionView</p>\n<p>UICollectionView和UITableView很相似，如果你对表视图非常熟悉，上手的速度也会快很多。使用它时需要相应的设置DataSource（UICollectionViewDataSoure)数据源协议和Delegate（UICollectionViewDelegate)事件协议，并实现相应的协议方法。它与UITableView不同的地方是它有UICollectionViewLayout，可以通过它的子类来定制布局。系统默认的布局方式是UICollectionViewDelegateFlowLayout，实现相应的协议（UICollectionViewDelegateFlowLayout）方法，便可达到默认布局效果。</p>\n<p>UICollectionViewCell与UITableViewCell的使用也差不多，一样的有ReuseIdentifier,可以复用。使用UICollectionViewCell时，需要先注册，然后再出列使用。至于注册并出列使用Cell的具体方式，请自行下载文章末尾的BGWaterFlowView或者自行Google。</p>\n<p>（2）集成上下拉刷新方式</p>\n<p>一般UITableView添加上下拉刷新的方式，是把下拉或者上拉刷新视图的UI放置UITableView的表头属性(tableHeaderView)或者表尾属性（tableFooterView）。但是，在UICollectionView中没有这两个属性。那么我们该如何来集成上下拉刷新呢？这就得说到<br>UICollectionView布局中的三种显示内容视图：Cells、Supplementary views、Decoration views。(关于这三种视图的介绍可以去官网查阅相关文档，上面有详细的解释)。我们一般是把上下拉刷新的UI放置在Supplementary views（官方解释：它能显示数据但是不同于Cells。不像Cell,Supplementary views是不能被用户选定的。相反，你可以用它去实现类似于给一个指定的section或者整个CollectionView添加页眉和页脚视图这样的功能）上面，其实，Supplementary views就和TableView的section头视图和尾视图差不多。但是用法却大不相同。在自定义瀑布流布局中一定要把它也计算进去，不然显示就会有异常。</p>\n<ul>\n<li><strong>注册头视图和尾视图单元格类型</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//注册头视图：kind代表Supplementary视图类型，UICollectionElementKindSectionHeader表示组头</div><div class=\"line\"></div><div class=\"line\">[self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@&quot;bGCollectionHeaderView&quot;];</div><div class=\"line\"></div><div class=\"line\">//注册尾视图：UICollectionElementKindSectionHeader表示组尾</div><div class=\"line\"></div><div class=\"line\">    [self registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@&quot;bGCollectionFooterView&quot;];</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>实现自定义组视图viewForSupplementaryElementOfKind代理方法</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath &#123;</div><div class=\"line\"></div><div class=\"line\">\t//kind代表Supplementary视图类型：头或尾视图（header OR footer）</div><div class=\"line\">\t</div><div class=\"line\">    if([kind isEqual:UICollectionElementKindSectionHeader]) &#123;</div><div class=\"line\">        UICollectionReusableView *collectionHeaderView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@&quot;bGCollectionHeaderView&quot; forIndexPath:indexPath];</div><div class=\"line\">        </div><div class=\"line\">        //初始化下拉刷新或者自定义页眉视图UI界面</div><div class=\"line\">        ...</div><div class=\"line\">        </div><div class=\"line\">        return collectionHeaderView;</div><div class=\"line\">    &#125; else if([kind isEqual:UICollectionElementKindSectionFooter]) &#123;</div><div class=\"line\">        UICollectionReusableView *collectionFooterView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@&quot;bGCollectionFooterView&quot; forIndexPath:indexPath];</div><div class=\"line\">        </div><div class=\"line\">        //初始化上拉刷新或者自定义页脚视图UI界面</div><div class=\"line\">        ...</div><div class=\"line\">        </div><div class=\"line\">        return collectionFooterView;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>完成以上两步，集成上下拉刷新的功能总算完成了。接下来你可以运行一下工程，看结果是否符合预期。如果你CollectionView使用的是系统的UICollectionViewFlowLayout布局，一定要返回组头或者组尾的高度，否则就会出现组头或者组尾无法显示（本文的下拉刷新视图所在的组头不返回高度不受影响，是因为它的纵坐标（y值）本来就是负数）。另外，还有一点需要注意的是，如果你的CollectionView中存在多组，最好是把上下拉刷新所在的组头或者组尾与其他组（section）的组头或组尾分开，相应的需要多注册一个组头或者组尾视图，分情况进行判断(这部分如果还有问题，可以在文章末尾留言，我会及时回复)。</p>\n<h4 id=\"二、自定义瀑布流（WaterFlow）式布局\"><a href=\"#二、自定义瀑布流（WaterFlow）式布局\" class=\"headerlink\" title=\"二、自定义瀑布流（WaterFlow）式布局\"></a>二、自定义瀑布流（WaterFlow）式布局</h4><p>（1）简单的介绍UICollectionView布局形式</p>\n<p>一般来讲，UICollectionView的布局形式分为两种：</p>\n<ul>\n<li><p>布局与内容独立，其布局不需要根据显示的单元格内容来计算。Cell的显示顺序与内容顺序一致。Cell排满一行则换至下一行继续排列。系统的UICollectionViewFlowLayout就是这样。</p>\n</li>\n<li><p>布局需要计算内容，本文的瀑布流Demo局部正是如此。UICollectionViewFlowLayout系统布局在换行的时候，由于每个item高度不同，从而导致布局错乱，无法满足你的需求。所以，这个时候你需要计算每个item的高度，最终用来确定item显示的位置。</p>\n</li>\n</ul>\n<p>从上述内容我们可以看出，一般如果布局需要计算内容的时候，我们就不应该直接使用UICollectionViewFlowLayout布局了，而是应该子类化一个UICollectionViewLayout，从而达到私人定制的目的。</p>\n<p>（2）创建自定义布局</p>\n<p><a href = \"https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/CreatingCustomLayouts/CreatingCustomLayouts.html#//apple_ref/doc/uid/TP40012334-CH5-SW1\">官方文档</a>中有提到，在布局的过程中，CollectionView会调用布局对象的具体方法。这些方法有机会使你计算这些项的位置以及给CollectionView提供它所需要的主要信息。其他的方法也有可能会被调用，但是在布局的过程中这些方法总是会按照以下的顺序调用：</p>\n<ol>\n<li>使用”prepareLayout”方法去执行一些CollectionView所需要的布局信息的预先计算操作。</li>\n<li>使用”collectionViewContentSize”方法去返回根据你最初计算的整个内容区域的总体大小。</li>\n<li>使用”layoutAttributesForElementsInRect:”方法来返回指定区域的单元格与视图属性。</li>\n</ol>\n<p>下面我们通过Demo来详细的讲解一下如何自定义瀑布流，废话不多说，直接上代码（本文采用的Demo为<strong>BGWaterFlowView</strong>,<strong>GitHub传送门</strong>：<a href = 'https://github.com/yangshebing/BGWaterFlowView'>请点击这里</a>）：</p>\n<ul>\n<li><strong>重写”prepareLayout”方法计算布局信息。</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)prepareLayout&#123;</div><div class=\"line\">    [super prepareLayout];</div><div class=\"line\">    ...</div><div class=\"line\">    </div><div class=\"line\">    //计算每个显示项的宽度，horizontalItemSpacing代表项与项之间的水平间隔， </div><div class=\"line\">    columnNum代表总列数，contentInset代表上下左右的内填充。详见下图说明</div><div class=\"line\">    </div><div class=\"line\">    self.itemWidth = (self.collectionView.frame.size.width - (self.horizontalItemSpacing * (self.columnNum - 1)) - self.contentInset.left - self.contentInset.right) / self.columnNum;</div><div class=\"line\">    </div><div class=\"line\">    //如有下拉刷新需求的则需要提供头视图（Supplementary view）布局属性。</div><div class=\"line\">    demo中的headerHeight属性可设置是否显示头视图（是否计算头视图的布局属性）。</div><div class=\"line\">    </div><div class=\"line\">    if(self.headerHeight &gt; 0)&#123;</div><div class=\"line\">    </div><div class=\"line\">    //通过layoutAttributesForSupplementaryViewOfKind:withIndexPath:方法来创建Supplementary视图布局属性对象，kind用来区分Supplementary视图类型（header或者footer）。</div><div class=\"line\">    </div><div class=\"line\">        self.headerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionHeader withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];</div><div class=\"line\">        </div><div class=\"line\">        //修改布局参数frame属性</div><div class=\"line\">        </div><div class=\"line\">        self.headerLayoutAttributes.frame = CGRectMake(0, 0, self.collectionView.frame.size.width, self.headerHeight);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //初始化保存布局属性的字典</div><div class=\"line\">    NSMutableDictionary *cellLayoutInfoDic = [NSMutableDictionary dictionary];</div><div class=\"line\">    //初始化列高数组</div><div class=\"line\">    NSMutableArray *columnInfoArray = [self columnInfoArray];</div><div class=\"line\">    NSInteger numSections = [self.collectionView numberOfSections];</div><div class=\"line\">    for(NSInteger section = 0; section &lt; numSections; section++)  &#123;</div><div class=\"line\">        NSInteger numItems = [self.collectionView numberOfItemsInSection:section];</div><div class=\"line\">        for(NSInteger item = 0; item &lt; numItems; item++)&#123;</div><div class=\"line\">            //获取列高最小的model，以它的高作为y坐标</div><div class=\"line\">            BGWaterFlowModel *firstModel = columnInfoArray.firstObject;</div><div class=\"line\">            CGFloat y = firstModel.height;</div><div class=\"line\">            CGFloat x = self.contentInset.left + (self.horizontalItemSpacing + self.itemWidth) * firstModel.column;</div><div class=\"line\">            </div><div class=\"line\">            NSIndexPath *indexPath = [NSIndexPath indexPathForItem:item inSection:section];</div><div class=\"line\">            </div><div class=\"line\">            //通过代理方法传入对应item的高度。</div><div class=\"line\">            </div><div class=\"line\">            CGFloat itemHeight = [((id&lt;BGWaterFlowLayoutDelegate&gt;)self.collectionView.delegate) collectionView:self.collectionView layout:self heightForItemAtIndexPath:indexPath];</div><div class=\"line\">            </div><div class=\"line\">            //通过layoutAttributesForCellWithIndexPath:方法来创建cell的布局属性对象。</div><div class=\"line\">            </div><div class=\"line\">            UICollectionViewLayoutAttributes *itemAttributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];</div><div class=\"line\">            //计算item的布局属性</div><div class=\"line\">            itemAttributes.frame = CGRectMake(x, y+self.contentInset.top+self.headerHeight, self.itemWidth, itemHeight);</div><div class=\"line\">            //计算当前列高,verticalItemSpacing代表项与项之间的垂直间隔。</div><div class=\"line\">            firstModel.height += (itemHeight + self.verticalItemSpacing);</div><div class=\"line\">            //保存新的列高，并进行排序：从后往前查找，查找到高度比它小的对象，就插入到该对象之后。</div><div class=\"line\">            [self sortArrayByHeight:columnInfoArray];</div><div class=\"line\">            </div><div class=\"line\">     //保存计算好的item布局属性</div><div class=\"line\">     cellLayoutInfoDic[indexPath] = itemAttributes;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //保存局部布局属性字典到全局字典中</div><div class=\"line\">    self.cellLayoutInfoDic = [cellLayoutInfoDic copy];</div><div class=\"line\">    </div><div class=\"line\">    //按照前面的排序逻辑，列高数组中的最后一个元素，就是高度最大的一列。</div><div class=\"line\">    BGWaterFlowModel *lastModel = columnInfoArray.lastObject;</div><div class=\"line\">    </div><div class=\"line\">    //如有上拉刷新需求的则需要提供尾视图布局属性。</div><div class=\"line\">    demo中的footerHeight属性可设置是否显示尾视图（是否计算尾视图的布局属性）。</div><div class=\"line\">    </div><div class=\"line\">    if(self.footerHeight &gt; 0)&#123;</div><div class=\"line\">        self.footerLayoutAttributes = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:UICollectionElementKindSectionFooter withIndexPath:[NSIndexPath indexPathForItem:0 inSection:0]];</div><div class=\"line\">        //计算尾视图的布局属性</div><div class=\"line\">        self.footerLayoutAttributes.frame = CGRectMake(0, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom, self.collectionView.frame.size.width, self.footerHeight);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //直接计算出collectionView的contentSize</div><div class=\"line\">    self.contentSize = CGSizeMake(self.collectionView.frame.size.width, lastModel.height+self.headerHeight+self.contentInset.top+self.contentInset.bottom+self.footerHeight);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>好吧，这么一大坨代码看到就头疼了，来张图帮助理解一下！图糙理不糙，理解万岁</strong><br><img src=\"http://ww4.sinaimg.cn/mw690/7f266405jw1ey25ujzticj218a0xmjww.jpg\" alt=\"\"></p>\n<p><strong>这样看上去是不是更清晰了？</strong></p>\n<ul>\n<li><strong>重写”collectionViewContentSize”方法返回collectionView的内容高度。</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- (CGSize)collectionViewContentSize&#123;</div><div class=\"line\"> \t//返回计算好的collectionView内容高度</div><div class=\"line\">    return self.contentSize;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>重写”layoutAttributesForElementsInRect”方法返回指定矩形区域中的cell或者其他类型视图布局属性。</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect &#123;</div><div class=\"line\"></div><div class=\"line\">\t//返回一组已经计算好的布局属性。</div><div class=\"line\">\t</div><div class=\"line\">    NSMutableArray *attributesArrs = [NSMutableArray array];</div><div class=\"line\">    [self.cellLayoutInfoDic enumerateKeysAndObjectsUsingBlock:^(NSIndexPath *indexPath,</div><div class=\"line\">                                                                UICollectionViewLayoutAttributes *attributes,</div><div class=\"line\">                                                                BOOL *stop) &#123; </div><div class=\"line\">        //遍历布局属性保存字典，添加布局属性至数组中                                                       </div><div class=\"line\">        if (CGRectIntersectsRect(rect, attributes.frame)) &#123;</div><div class=\"line\">            [attributesArrs addObject:attributes];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div><div class=\"line\">    </div><div class=\"line\">    //如果有头视图或者尾视图则需要添加头视图与尾视图的布局属性</div><div class=\"line\">    </div><div class=\"line\">    if (self.headerLayoutAttributes &amp;&amp; CGRectIntersectsRect(rect, self.headerLayoutAttributes.frame)) &#123;</div><div class=\"line\">        [attributesArrs addObject:self.headerLayoutAttributes];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    if (self.footerLayoutAttributes &amp;&amp; CGRectIntersectsRect(rect, self.footerLayoutAttributes.frame)) &#123;</div><div class=\"line\">        [attributesArrs addObject:self.footerLayoutAttributes];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    return attributesArrs;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"结语：\"><a href=\"#结语：\" class=\"headerlink\" title=\"结语：\"></a>结语：</h4><p><a href = \"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/index.html#//apple_ref/occ/cl/UICollectionViewLayout\">UICollectionViewLayout</a>相关的内容姿势非常多，相关文章也非常多。本文介绍的瀑布流布局也只是其中的冰山一角，很多东西官方文档中已经介绍的非常详细了。所以，还是建议多看官方文档。本文主要注重项目的实用性，在后面就直接上代码了，可能在理论方面还是有所欠缺，对于不足的地方，希望大家多提建议，一起交流学习，一起进步。如果文中有看不懂的地方，还请您留言。我会及时进行回复。最后，本文的Demo就在于方便徒手撸代码的人使用。你懂的。后期会不断的更新优化，进一步的完善。敬请期待…</p>\n<p>点击此处下载本文的Demo:<a href = 'https://github.com/yangshebing/BGWaterFlowView'><strong>BGWaterFlowView</strong></a></p>\n<p>Demo使用方式详见:<a href = \"https://github.com/yangshebing/BGWaterFlowView/blob/master/README.md\"><strong>README.md</strong></a></p>\n<p>Demo运行瀑布流效果截图如下所示:</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/7f266405jw1ey0z6x4xf9j20ku12aqb5.jpg\"/ width = \"375\" height = \"677\" align = \"center\"></p>\n<h6 id=\"参考博客地址：\"><a href=\"#参考博客地址：\" class=\"headerlink\" title=\"参考博客地址：\"></a>参考博客地址：</h6><ul>\n<li><a href = \"http://objccn.io/issue-3-3/\">自定义 Collection View 布局</a></li>\n</ul>\n<p>转载请注明出处</p>"},{"layout":"post","title":"基于GitHub搭建Octopress个人技术博客(Mac版)","date":"2015-09-17T15:42:42.000Z","comments":1,"keywords":"ios开发, octopress, github, 博客","_content":"###### 作为一名屌逼的程序猿，肯定是要有一个屌逼的技术博客。在交流学习的同时，顺便见证自己成长的心路历程。废话不多说，直接进入正题。编程讲究的四门功课，“说，学，逗，唱”。不会就学嘛！没有就找嘛！网上相关的文章简直太多了！其中原理就不多说，我且按照我搭建的顺序写一下步骤吧！\n\n**注意事项：在搭建之前，检查MAC电脑是否已经安装了Git和Ruby 1.9.3及以上版本。（Mac默认均已自带，ruby请自行检查版本：ruby --version，如果缺少，当自行下载）**\n\n#### 一、开始安装octopress\n<!--more-->\n1、将Octopress从github上clone到本地\n\n ```\ngit clone git://github.com/imathis/octopress.git octopress\ncd octopress\n ```\n2、安装Octopress\n\n```\ngem install bundler\nbundle install\nrake install\n```\n如果当你执行“bundle install”这步失败了，请更改一下本地octopress文件夹下Gemfile文件当中的源（路径：/Users/用户名/octopress/Gemfile），将文件中的```source \"https://rubygems.org\"```更换成 ```source \"http://ruby.taobao.org/\"```,然后保存文件再重新执行bundle install及其后续操作。\n\n3、部署GitHub Pages\n在CitHub中新建一个名为username.github.io的仓库（username为你的GitHub用户名）。\n\n* 开始配置GitHub Pages\n\n在终端继续输入\n\n```\nrake setup_github_pages\n```\n在Repository url后面粘贴username.github.io仓库对应的url地址\n\n```\nEnter the read/write url for your repository\n(For example, 'git@github.com:your_username/your_username.github.io.git)\n           or 'https://github.com/your_username/your_username.github.io')\nRepository url: \n```\n把上面代码：\n\n```\nhttps://github.com/your_username/your_username.github.io”\n或者\n“git@github.com:your_username/your_username.github.io.git\n```\n中的your_username替换成自己GitHub用户名即可。（两种地址，前者是HTTPS地址，后者是SSH地址，任选一个粘贴即可）\n\n现在可以开始生成自己的第一篇博客并部署放至GitHub上。\n在终端输入以下命令：生成一篇新的博客\n\n```\nrake new_post['test']\n```\n其中test是默认的博客标题（当然博客的标题可以在markdown文件里面更改）。当然你也可以输入rake new_post命令，按照终端的提示输入博客的标题。生成完成的文章内容在octopress/source/_posts目录下。文件名为时间＋标题名，如“2015-09-17-test.markdown”。可以用markdown工具（本文用的markdown工具为“Mou”）进行编辑与修改。\n\n接下来在终端输入rake generate命令生成静态文件\n\n```\nrake generate\n```\n\n在部署到GitHub上之前，你可以在本地预览一下博客的效果。\n先在终端输入rake preview命令，生成预览blog。然后在浏览器中输入`http://localhost:4000`查看博客的预览效果。\n\n```\nrake preview\n```\n在终端退出预览效果：ctrl+c\n\n确认效果之后，开始部署至GitHub。rake deploy命令会将octopress/public目录下的文件上传至仓库的master分支。\n\n```\nrake deploy\n```\n最后一步，将Octopress的源码提交至GitHub\n\n```\ngit add .\ngit commit -m 'commit source file'\ngit push origin source\n```\n完工，屌逼的第一篇博客就已经发布到GitHub Pages上了。你现在可以输入:username.github.io在线查看自己的博客了（如：yangshebing.github.io）。\n\n至于其中的相关原理分析我就不一一赘述了。请参看文章末尾的参考文章链接或者自行网上搜索。\n\n#### 二、简单的配置Octopress\n\n###### 1、修改Octopress的配置文件（路径：octopress/_config.yml）\n* 设置博客的标题，子标题以及作者相关信息。\n\n```\ntitle: 杨社兵的技术博客\nsubtitle: 业精于勤荒于嬉，行成于思毁于随.\nauthor: 杨社兵\n```\n\n* 删除twitter相关信息（GFW造成页面加载慢）\n\n```\nTwitter\ntwitter_user:\ntwitter_tweet_button: true\n```\n\n* 修改source/_includes目录下的head.html文件：将```//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.jst```替换成```http://cdn.staticfile.org/jquery/1.9.1/jquery.min.jst```（解决页面加载过慢问题）\n* 修改source/_includes/custom目录下的自定义head.html文件，去掉google自定义字体（解决页面加载过慢问题）\n\n###### 2、添加统计工具（百度统计）\n去<a href=\"http://tongji.baidu.com\">百度统计</a>官网申请一个账号，在管理界面选择“代码获取”，复制代码至```source/_includes/custom/footer.html```文件中。\n\n###### 3、自定义博客导航栏\n部署好博客之后，你会发现导航栏上默认的只有两项：Blog、Archives，无法满足我们的需求。比如我们想在导航栏上添加一个选项为“关于我”。\n\n打开“/source/_includes/custom”目录的navigation.html文件进行编辑：\n\n```\n*<ul class=\"main-navigation\">\n  <li><a href=\"{{ root_url }}/\">我的博客</a></li>\n  <li><a href=\"{{ root_url }}/blog/archives\">所有文章</a></li>\n  <li><a href=\"http://weibo.com/yangshebing\" target=\"_blank\">新浪微博</a></li>\n  <li><a href=\"{{ root_url }}/about\">关于我</a></li>\n</ul>\n\n```\n\n接下来在终端输入rake new_page命令，生成一个index.markdown文件，\n\n```\nrake new_page['about']\n```\n它的默认保存路径是：“source/about/index.markdown”，编辑index.markdown文件，即可定制“关于我”页面内容。\n\n###### 4、关于博客的评论和分享到微博功能，请参考末尾文章链接《象写程序一样写博客：搭建基于github的博客》一文。\n\n参考文章链接：\n\n（1）<a href=\"http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/\" target=\"_blank\">象写程序一样写博客：搭建基于github的博客</a>\n\n（2）<a href=\"http://matrixzk.github.io/blog/20141020/octopress-setup-and-analysis/#section\" target=\"_blank\">使用 Octopress 2.0 搭建基于 Github Pages 个人博客的详细过程及原理分析</a>\n\n（3）<a href=\"http://www.jianshu.com/p/0ac2ac1a8e45\" target=\"_blank\">octopress博客搭建和个性化配置</a>\n\n（4）<a href=\"https://liuchungui.github.io/blog/2015/09/11/macdian-nao-shang-da-jian-octopressbo-ke/\" target=\"_blank\">Mac电脑上搭建octopress博客</a>\n\n（5）<a href=\"http://www.cnblogs.com/sawyerzhu/p/3710374.html\" target=\"_blank\">Mac环境下octopress个人博客搭建</a>\n\n（6）<a href=\"http://foggry.com/blog/2014/04/28/custom-your-octopress-blog/\" target=\"_blank\">自定义你的Octopress博客</a>\n\n（7）<a href=\"http://blog.devtang.com/blog/2014/06/02/use-gitcafe-to-host-blog/\" target=\"_blank\">将博客从GitHub迁移到GitCafe</a>\n","source":"_posts/2015-09-17-test.markdown","raw":"---\nlayout: post\ntitle: \"基于GitHub搭建Octopress个人技术博客(Mac版)\"\ndate: 2015-09-17 23:42:42 +0800\ncomments: true\ntags: [iOS, Xcode, octopress]\nkeywords: ios开发, octopress, github, 博客\ncategories: Others\n---\n###### 作为一名屌逼的程序猿，肯定是要有一个屌逼的技术博客。在交流学习的同时，顺便见证自己成长的心路历程。废话不多说，直接进入正题。编程讲究的四门功课，“说，学，逗，唱”。不会就学嘛！没有就找嘛！网上相关的文章简直太多了！其中原理就不多说，我且按照我搭建的顺序写一下步骤吧！\n\n**注意事项：在搭建之前，检查MAC电脑是否已经安装了Git和Ruby 1.9.3及以上版本。（Mac默认均已自带，ruby请自行检查版本：ruby --version，如果缺少，当自行下载）**\n\n#### 一、开始安装octopress\n<!--more-->\n1、将Octopress从github上clone到本地\n\n ```\ngit clone git://github.com/imathis/octopress.git octopress\ncd octopress\n ```\n2、安装Octopress\n\n```\ngem install bundler\nbundle install\nrake install\n```\n如果当你执行“bundle install”这步失败了，请更改一下本地octopress文件夹下Gemfile文件当中的源（路径：/Users/用户名/octopress/Gemfile），将文件中的```source \"https://rubygems.org\"```更换成 ```source \"http://ruby.taobao.org/\"```,然后保存文件再重新执行bundle install及其后续操作。\n\n3、部署GitHub Pages\n在CitHub中新建一个名为username.github.io的仓库（username为你的GitHub用户名）。\n\n* 开始配置GitHub Pages\n\n在终端继续输入\n\n```\nrake setup_github_pages\n```\n在Repository url后面粘贴username.github.io仓库对应的url地址\n\n```\nEnter the read/write url for your repository\n(For example, 'git@github.com:your_username/your_username.github.io.git)\n           or 'https://github.com/your_username/your_username.github.io')\nRepository url: \n```\n把上面代码：\n\n```\nhttps://github.com/your_username/your_username.github.io”\n或者\n“git@github.com:your_username/your_username.github.io.git\n```\n中的your_username替换成自己GitHub用户名即可。（两种地址，前者是HTTPS地址，后者是SSH地址，任选一个粘贴即可）\n\n现在可以开始生成自己的第一篇博客并部署放至GitHub上。\n在终端输入以下命令：生成一篇新的博客\n\n```\nrake new_post['test']\n```\n其中test是默认的博客标题（当然博客的标题可以在markdown文件里面更改）。当然你也可以输入rake new_post命令，按照终端的提示输入博客的标题。生成完成的文章内容在octopress/source/_posts目录下。文件名为时间＋标题名，如“2015-09-17-test.markdown”。可以用markdown工具（本文用的markdown工具为“Mou”）进行编辑与修改。\n\n接下来在终端输入rake generate命令生成静态文件\n\n```\nrake generate\n```\n\n在部署到GitHub上之前，你可以在本地预览一下博客的效果。\n先在终端输入rake preview命令，生成预览blog。然后在浏览器中输入`http://localhost:4000`查看博客的预览效果。\n\n```\nrake preview\n```\n在终端退出预览效果：ctrl+c\n\n确认效果之后，开始部署至GitHub。rake deploy命令会将octopress/public目录下的文件上传至仓库的master分支。\n\n```\nrake deploy\n```\n最后一步，将Octopress的源码提交至GitHub\n\n```\ngit add .\ngit commit -m 'commit source file'\ngit push origin source\n```\n完工，屌逼的第一篇博客就已经发布到GitHub Pages上了。你现在可以输入:username.github.io在线查看自己的博客了（如：yangshebing.github.io）。\n\n至于其中的相关原理分析我就不一一赘述了。请参看文章末尾的参考文章链接或者自行网上搜索。\n\n#### 二、简单的配置Octopress\n\n###### 1、修改Octopress的配置文件（路径：octopress/_config.yml）\n* 设置博客的标题，子标题以及作者相关信息。\n\n```\ntitle: 杨社兵的技术博客\nsubtitle: 业精于勤荒于嬉，行成于思毁于随.\nauthor: 杨社兵\n```\n\n* 删除twitter相关信息（GFW造成页面加载慢）\n\n```\nTwitter\ntwitter_user:\ntwitter_tweet_button: true\n```\n\n* 修改source/_includes目录下的head.html文件：将```//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.jst```替换成```http://cdn.staticfile.org/jquery/1.9.1/jquery.min.jst```（解决页面加载过慢问题）\n* 修改source/_includes/custom目录下的自定义head.html文件，去掉google自定义字体（解决页面加载过慢问题）\n\n###### 2、添加统计工具（百度统计）\n去<a href=\"http://tongji.baidu.com\">百度统计</a>官网申请一个账号，在管理界面选择“代码获取”，复制代码至```source/_includes/custom/footer.html```文件中。\n\n###### 3、自定义博客导航栏\n部署好博客之后，你会发现导航栏上默认的只有两项：Blog、Archives，无法满足我们的需求。比如我们想在导航栏上添加一个选项为“关于我”。\n\n打开“/source/_includes/custom”目录的navigation.html文件进行编辑：\n\n```\n*<ul class=\"main-navigation\">\n  <li><a href=\"{{ root_url }}/\">我的博客</a></li>\n  <li><a href=\"{{ root_url }}/blog/archives\">所有文章</a></li>\n  <li><a href=\"http://weibo.com/yangshebing\" target=\"_blank\">新浪微博</a></li>\n  <li><a href=\"{{ root_url }}/about\">关于我</a></li>\n</ul>\n\n```\n\n接下来在终端输入rake new_page命令，生成一个index.markdown文件，\n\n```\nrake new_page['about']\n```\n它的默认保存路径是：“source/about/index.markdown”，编辑index.markdown文件，即可定制“关于我”页面内容。\n\n###### 4、关于博客的评论和分享到微博功能，请参考末尾文章链接《象写程序一样写博客：搭建基于github的博客》一文。\n\n参考文章链接：\n\n（1）<a href=\"http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/\" target=\"_blank\">象写程序一样写博客：搭建基于github的博客</a>\n\n（2）<a href=\"http://matrixzk.github.io/blog/20141020/octopress-setup-and-analysis/#section\" target=\"_blank\">使用 Octopress 2.0 搭建基于 Github Pages 个人博客的详细过程及原理分析</a>\n\n（3）<a href=\"http://www.jianshu.com/p/0ac2ac1a8e45\" target=\"_blank\">octopress博客搭建和个性化配置</a>\n\n（4）<a href=\"https://liuchungui.github.io/blog/2015/09/11/macdian-nao-shang-da-jian-octopressbo-ke/\" target=\"_blank\">Mac电脑上搭建octopress博客</a>\n\n（5）<a href=\"http://www.cnblogs.com/sawyerzhu/p/3710374.html\" target=\"_blank\">Mac环境下octopress个人博客搭建</a>\n\n（6）<a href=\"http://foggry.com/blog/2014/04/28/custom-your-octopress-blog/\" target=\"_blank\">自定义你的Octopress博客</a>\n\n（7）<a href=\"http://blog.devtang.com/blog/2014/06/02/use-gitcafe-to-host-blog/\" target=\"_blank\">将博客从GitHub迁移到GitCafe</a>\n","slug":"test","published":1,"updated":"2016-09-10T05:16:56.000Z","_id":"ciswie9cm0007e3u280pwhiyi","photos":[],"link":"","content":"<h6 id=\"作为一名屌逼的程序猿，肯定是要有一个屌逼的技术博客。在交流学习的同时，顺便见证自己成长的心路历程。废话不多说，直接进入正题。编程讲究的四门功课，“说，学，逗，唱”。不会就学嘛！没有就找嘛！网上相关的文章简直太多了！其中原理就不多说，我且按照我搭建的顺序写一下步骤吧！\"><a href=\"#作为一名屌逼的程序猿，肯定是要有一个屌逼的技术博客。在交流学习的同时，顺便见证自己成长的心路历程。废话不多说，直接进入正题。编程讲究的四门功课，“说，学，逗，唱”。不会就学嘛！没有就找嘛！网上相关的文章简直太多了！其中原理就不多说，我且按照我搭建的顺序写一下步骤吧！\" class=\"headerlink\" title=\"作为一名屌逼的程序猿，肯定是要有一个屌逼的技术博客。在交流学习的同时，顺便见证自己成长的心路历程。废话不多说，直接进入正题。编程讲究的四门功课，“说，学，逗，唱”。不会就学嘛！没有就找嘛！网上相关的文章简直太多了！其中原理就不多说，我且按照我搭建的顺序写一下步骤吧！\"></a>作为一名屌逼的程序猿，肯定是要有一个屌逼的技术博客。在交流学习的同时，顺便见证自己成长的心路历程。废话不多说，直接进入正题。编程讲究的四门功课，“说，学，逗，唱”。不会就学嘛！没有就找嘛！网上相关的文章简直太多了！其中原理就不多说，我且按照我搭建的顺序写一下步骤吧！</h6><p><strong>注意事项：在搭建之前，检查MAC电脑是否已经安装了Git和Ruby 1.9.3及以上版本。（Mac默认均已自带，ruby请自行检查版本：ruby –version，如果缺少，当自行下载）</strong></p>\n<h4 id=\"一、开始安装octopress\"><a href=\"#一、开始安装octopress\" class=\"headerlink\" title=\"一、开始安装octopress\"></a>一、开始安装octopress</h4><a id=\"more\"></a>\n<p>1、将Octopress从github上clone到本地</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone git://github.com/imathis/octopress.git octopress</div><div class=\"line\">cd octopress</div></pre></td></tr></table></figure>\n<p>2、安装Octopress</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">gem install bundler</div><div class=\"line\">bundle install</div><div class=\"line\">rake install</div></pre></td></tr></table></figure>\n<p>如果当你执行“bundle install”这步失败了，请更改一下本地octopress文件夹下Gemfile文件当中的源（路径：/Users/用户名/octopress/Gemfile），将文件中的<figure class=\"highlight plain\"><figcaption><span>\"https://rubygems.org\"```更换成 ```source \"http://ruby.taobao.org/\"```,然后保存文件再重新执行bundle install及其后续操作。</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">3、部署GitHub Pages</div><div class=\"line\">在CitHub中新建一个名为username.github.io的仓库（username为你的GitHub用户名）。</div><div class=\"line\"></div><div class=\"line\">* 开始配置GitHub Pages</div><div class=\"line\"></div><div class=\"line\">在终端继续输入</div></pre></td></tr></table></figure></p>\n<p>rake setup_github_pages<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">在Repository url后面粘贴username.github.io仓库对应的url地址</div></pre></td></tr></table></figure></p>\n<p>Enter the read/write url for your repository<br>(For example, ‘git@github.com:your_username/your_username.github.io.git)<br>           or ‘<a href=\"https://github.com/your_username/your_username.github.io\" target=\"_blank\" rel=\"external\">https://github.com/your_username/your_username.github.io</a>‘)<br>Repository url:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">把上面代码：</div></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/your_username/your_username.github.io”\" target=\"_blank\" rel=\"external\">https://github.com/your_username/your_username.github.io”</a><br>或者<br>“git@github.com:your_username/your_username.github.io.git<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">中的your_username替换成自己GitHub用户名即可。（两种地址，前者是HTTPS地址，后者是SSH地址，任选一个粘贴即可）</div><div class=\"line\"></div><div class=\"line\">现在可以开始生成自己的第一篇博客并部署放至GitHub上。</div><div class=\"line\">在终端输入以下命令：生成一篇新的博客</div></pre></td></tr></table></figure></p>\n<p>rake new_post[‘test’]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">其中test是默认的博客标题（当然博客的标题可以在markdown文件里面更改）。当然你也可以输入rake new_post命令，按照终端的提示输入博客的标题。生成完成的文章内容在octopress/source/_posts目录下。文件名为时间＋标题名，如“2015-09-17-test.markdown”。可以用markdown工具（本文用的markdown工具为“Mou”）进行编辑与修改。</div><div class=\"line\"></div><div class=\"line\">接下来在终端输入rake generate命令生成静态文件</div></pre></td></tr></table></figure></p>\n<p>rake generate<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">在部署到GitHub上之前，你可以在本地预览一下博客的效果。</div><div class=\"line\">先在终端输入rake preview命令，生成预览blog。然后在浏览器中输入`http://localhost:4000`查看博客的预览效果。</div></pre></td></tr></table></figure></p>\n<p>rake preview<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">在终端退出预览效果：ctrl+c</div><div class=\"line\"></div><div class=\"line\">确认效果之后，开始部署至GitHub。rake deploy命令会将octopress/public目录下的文件上传至仓库的master分支。</div></pre></td></tr></table></figure></p>\n<p>rake deploy<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">最后一步，将Octopress的源码提交至GitHub</div></pre></td></tr></table></figure></p>\n<p>git add .<br>git commit -m ‘commit source file’<br>git push origin source<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">完工，屌逼的第一篇博客就已经发布到GitHub Pages上了。你现在可以输入:username.github.io在线查看自己的博客了（如：yangshebing.github.io）。</div><div class=\"line\"></div><div class=\"line\">至于其中的相关原理分析我就不一一赘述了。请参看文章末尾的参考文章链接或者自行网上搜索。</div><div class=\"line\"></div><div class=\"line\">#### 二、简单的配置Octopress</div><div class=\"line\"></div><div class=\"line\">###### 1、修改Octopress的配置文件（路径：octopress/_config.yml）</div><div class=\"line\">* 设置博客的标题，子标题以及作者相关信息。</div></pre></td></tr></table></figure></p>\n<p>title: 杨社兵的技术博客<br>subtitle: 业精于勤荒于嬉，行成于思毁于随.<br>author: 杨社兵<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">* 删除twitter相关信息（GFW造成页面加载慢）</div></pre></td></tr></table></figure></p>\n<p>Twitter<br>twitter_user:<br>twitter_tweet_button: true<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">* 修改source/_includes目录下的head.html文件：将```//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.jst```替换成```http://cdn.staticfile.org/jquery/1.9.1/jquery.min.jst```（解决页面加载过慢问题）</div><div class=\"line\">* 修改source/_includes/custom目录下的自定义head.html文件，去掉google自定义字体（解决页面加载过慢问题）</div><div class=\"line\"></div><div class=\"line\">###### 2、添加统计工具（百度统计）</div><div class=\"line\">去&lt;a href=&quot;http://tongji.baidu.com&quot;&gt;百度统计&lt;/a&gt;官网申请一个账号，在管理界面选择“代码获取”，复制代码至```source/_includes/custom/footer.html```文件中。</div><div class=\"line\"></div><div class=\"line\">###### 3、自定义博客导航栏</div><div class=\"line\">部署好博客之后，你会发现导航栏上默认的只有两项：Blog、Archives，无法满足我们的需求。比如我们想在导航栏上添加一个选项为“关于我”。</div><div class=\"line\"></div><div class=\"line\">打开“/source/_includes/custom”目录的navigation.html文件进行编辑：</div></pre></td></tr></table></figure></p>\n<p>*<ul class=\"main-navigation\"><br>  <li><a href=\"/\">我的博客</a></li><br>  <li><a href=\"/blog/archives\">所有文章</a></li><br>  <li><a href=\"http://weibo.com/yangshebing\" target=\"_blank\">新浪微博</a></li><br>  <li><a href=\"/about\">关于我</a></li><br></ul></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">接下来在终端输入rake new_page命令，生成一个index.markdown文件，</div></pre></td></tr></table></figure>\n<p>rake new_page[‘about’]<br>```<br>它的默认保存路径是：“source/about/index.markdown”，编辑index.markdown文件，即可定制“关于我”页面内容。</p>\n<h6 id=\"4、关于博客的评论和分享到微博功能，请参考末尾文章链接《象写程序一样写博客：搭建基于github的博客》一文。\"><a href=\"#4、关于博客的评论和分享到微博功能，请参考末尾文章链接《象写程序一样写博客：搭建基于github的博客》一文。\" class=\"headerlink\" title=\"4、关于博客的评论和分享到微博功能，请参考末尾文章链接《象写程序一样写博客：搭建基于github的博客》一文。\"></a>4、关于博客的评论和分享到微博功能，请参考末尾文章链接《象写程序一样写博客：搭建基于github的博客》一文。</h6><p>参考文章链接：</p>\n<p>（1）<a href=\"http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/\" target=\"_blank\">象写程序一样写博客：搭建基于github的博客</a></p>\n<p>（2）<a href=\"http://matrixzk.github.io/blog/20141020/octopress-setup-and-analysis/#section\" target=\"_blank\">使用 Octopress 2.0 搭建基于 Github Pages 个人博客的详细过程及原理分析</a></p>\n<p>（3）<a href=\"http://www.jianshu.com/p/0ac2ac1a8e45\" target=\"_blank\">octopress博客搭建和个性化配置</a></p>\n<p>（4）<a href=\"https://liuchungui.github.io/blog/2015/09/11/macdian-nao-shang-da-jian-octopressbo-ke/\" target=\"_blank\">Mac电脑上搭建octopress博客</a></p>\n<p>（5）<a href=\"http://www.cnblogs.com/sawyerzhu/p/3710374.html\" target=\"_blank\">Mac环境下octopress个人博客搭建</a></p>\n<p>（6）<a href=\"http://foggry.com/blog/2014/04/28/custom-your-octopress-blog/\" target=\"_blank\">自定义你的Octopress博客</a></p>\n<p>（7）<a href=\"http://blog.devtang.com/blog/2014/06/02/use-gitcafe-to-host-blog/\" target=\"_blank\">将博客从GitHub迁移到GitCafe</a></p>\n","excerpt":"<h6 id=\"作为一名屌逼的程序猿，肯定是要有一个屌逼的技术博客。在交流学习的同时，顺便见证自己成长的心路历程。废话不多说，直接进入正题。编程讲究的四门功课，“说，学，逗，唱”。不会就学嘛！没有就找嘛！网上相关的文章简直太多了！其中原理就不多说，我且按照我搭建的顺序写一下步骤吧！\"><a href=\"#作为一名屌逼的程序猿，肯定是要有一个屌逼的技术博客。在交流学习的同时，顺便见证自己成长的心路历程。废话不多说，直接进入正题。编程讲究的四门功课，“说，学，逗，唱”。不会就学嘛！没有就找嘛！网上相关的文章简直太多了！其中原理就不多说，我且按照我搭建的顺序写一下步骤吧！\" class=\"headerlink\" title=\"作为一名屌逼的程序猿，肯定是要有一个屌逼的技术博客。在交流学习的同时，顺便见证自己成长的心路历程。废话不多说，直接进入正题。编程讲究的四门功课，“说，学，逗，唱”。不会就学嘛！没有就找嘛！网上相关的文章简直太多了！其中原理就不多说，我且按照我搭建的顺序写一下步骤吧！\"></a>作为一名屌逼的程序猿，肯定是要有一个屌逼的技术博客。在交流学习的同时，顺便见证自己成长的心路历程。废话不多说，直接进入正题。编程讲究的四门功课，“说，学，逗，唱”。不会就学嘛！没有就找嘛！网上相关的文章简直太多了！其中原理就不多说，我且按照我搭建的顺序写一下步骤吧！</h6><p><strong>注意事项：在搭建之前，检查MAC电脑是否已经安装了Git和Ruby 1.9.3及以上版本。（Mac默认均已自带，ruby请自行检查版本：ruby –version，如果缺少，当自行下载）</strong></p>\n<h4 id=\"一、开始安装octopress\"><a href=\"#一、开始安装octopress\" class=\"headerlink\" title=\"一、开始安装octopress\"></a>一、开始安装octopress</h4>","more":"<p>1、将Octopress从github上clone到本地</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone git://github.com/imathis/octopress.git octopress</div><div class=\"line\">cd octopress</div></pre></td></tr></table></figure>\n<p>2、安装Octopress</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">gem install bundler</div><div class=\"line\">bundle install</div><div class=\"line\">rake install</div></pre></td></tr></table></figure>\n<p>如果当你执行“bundle install”这步失败了，请更改一下本地octopress文件夹下Gemfile文件当中的源（路径：/Users/用户名/octopress/Gemfile），将文件中的<figure class=\"highlight plain\"><figcaption><span>\"https://rubygems.org\"```更换成 ```source \"http://ruby.taobao.org/\"```,然后保存文件再重新执行bundle install及其后续操作。</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">3、部署GitHub Pages</div><div class=\"line\">在CitHub中新建一个名为username.github.io的仓库（username为你的GitHub用户名）。</div><div class=\"line\"></div><div class=\"line\">* 开始配置GitHub Pages</div><div class=\"line\"></div><div class=\"line\">在终端继续输入</div></pre></td></tr></table></figure></p>\n<p>rake setup_github_pages<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">在Repository url后面粘贴username.github.io仓库对应的url地址</div></pre></td></tr></table></figure></p>\n<p>Enter the read/write url for your repository<br>(For example, ‘git@github.com:your_username/your_username.github.io.git)<br>           or ‘<a href=\"https://github.com/your_username/your_username.github.io\">https://github.com/your_username/your_username.github.io</a>‘)<br>Repository url:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">把上面代码：</div></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/your_username/your_username.github.io”\">https://github.com/your_username/your_username.github.io”</a><br>或者<br>“git@github.com:your_username/your_username.github.io.git<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">中的your_username替换成自己GitHub用户名即可。（两种地址，前者是HTTPS地址，后者是SSH地址，任选一个粘贴即可）</div><div class=\"line\"></div><div class=\"line\">现在可以开始生成自己的第一篇博客并部署放至GitHub上。</div><div class=\"line\">在终端输入以下命令：生成一篇新的博客</div></pre></td></tr></table></figure></p>\n<p>rake new_post[‘test’]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">其中test是默认的博客标题（当然博客的标题可以在markdown文件里面更改）。当然你也可以输入rake new_post命令，按照终端的提示输入博客的标题。生成完成的文章内容在octopress/source/_posts目录下。文件名为时间＋标题名，如“2015-09-17-test.markdown”。可以用markdown工具（本文用的markdown工具为“Mou”）进行编辑与修改。</div><div class=\"line\"></div><div class=\"line\">接下来在终端输入rake generate命令生成静态文件</div></pre></td></tr></table></figure></p>\n<p>rake generate<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">在部署到GitHub上之前，你可以在本地预览一下博客的效果。</div><div class=\"line\">先在终端输入rake preview命令，生成预览blog。然后在浏览器中输入`http://localhost:4000`查看博客的预览效果。</div></pre></td></tr></table></figure></p>\n<p>rake preview<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">在终端退出预览效果：ctrl+c</div><div class=\"line\"></div><div class=\"line\">确认效果之后，开始部署至GitHub。rake deploy命令会将octopress/public目录下的文件上传至仓库的master分支。</div></pre></td></tr></table></figure></p>\n<p>rake deploy<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">最后一步，将Octopress的源码提交至GitHub</div></pre></td></tr></table></figure></p>\n<p>git add .<br>git commit -m ‘commit source file’<br>git push origin source<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">完工，屌逼的第一篇博客就已经发布到GitHub Pages上了。你现在可以输入:username.github.io在线查看自己的博客了（如：yangshebing.github.io）。</div><div class=\"line\"></div><div class=\"line\">至于其中的相关原理分析我就不一一赘述了。请参看文章末尾的参考文章链接或者自行网上搜索。</div><div class=\"line\"></div><div class=\"line\">#### 二、简单的配置Octopress</div><div class=\"line\"></div><div class=\"line\">###### 1、修改Octopress的配置文件（路径：octopress/_config.yml）</div><div class=\"line\">* 设置博客的标题，子标题以及作者相关信息。</div></pre></td></tr></table></figure></p>\n<p>title: 杨社兵的技术博客<br>subtitle: 业精于勤荒于嬉，行成于思毁于随.<br>author: 杨社兵<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">* 删除twitter相关信息（GFW造成页面加载慢）</div></pre></td></tr></table></figure></p>\n<p>Twitter<br>twitter_user:<br>twitter_tweet_button: true<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">* 修改source/_includes目录下的head.html文件：将```//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.jst```替换成```http://cdn.staticfile.org/jquery/1.9.1/jquery.min.jst```（解决页面加载过慢问题）</div><div class=\"line\">* 修改source/_includes/custom目录下的自定义head.html文件，去掉google自定义字体（解决页面加载过慢问题）</div><div class=\"line\"></div><div class=\"line\">###### 2、添加统计工具（百度统计）</div><div class=\"line\">去&lt;a href=&quot;http://tongji.baidu.com&quot;&gt;百度统计&lt;/a&gt;官网申请一个账号，在管理界面选择“代码获取”，复制代码至```source/_includes/custom/footer.html```文件中。</div><div class=\"line\"></div><div class=\"line\">###### 3、自定义博客导航栏</div><div class=\"line\">部署好博客之后，你会发现导航栏上默认的只有两项：Blog、Archives，无法满足我们的需求。比如我们想在导航栏上添加一个选项为“关于我”。</div><div class=\"line\"></div><div class=\"line\">打开“/source/_includes/custom”目录的navigation.html文件进行编辑：</div></pre></td></tr></table></figure></p>\n<p>*<ul class=\"main-navigation\"><br>  <li><a href=\"/\">我的博客</a></li><br>  <li><a href=\"/blog/archives\">所有文章</a></li><br>  <li><a href=\"http://weibo.com/yangshebing\" target=\"_blank\">新浪微博</a></li><br>  <li><a href=\"/about\">关于我</a></li><br></ul></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">接下来在终端输入rake new_page命令，生成一个index.markdown文件，</div></pre></td></tr></table></figure>\n<p>rake new_page[‘about’]<br>```<br>它的默认保存路径是：“source/about/index.markdown”，编辑index.markdown文件，即可定制“关于我”页面内容。</p>\n<h6 id=\"4、关于博客的评论和分享到微博功能，请参考末尾文章链接《象写程序一样写博客：搭建基于github的博客》一文。\"><a href=\"#4、关于博客的评论和分享到微博功能，请参考末尾文章链接《象写程序一样写博客：搭建基于github的博客》一文。\" class=\"headerlink\" title=\"4、关于博客的评论和分享到微博功能，请参考末尾文章链接《象写程序一样写博客：搭建基于github的博客》一文。\"></a>4、关于博客的评论和分享到微博功能，请参考末尾文章链接《象写程序一样写博客：搭建基于github的博客》一文。</h6><p>参考文章链接：</p>\n<p>（1）<a href=\"http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/\" target=\"_blank\">象写程序一样写博客：搭建基于github的博客</a></p>\n<p>（2）<a href=\"http://matrixzk.github.io/blog/20141020/octopress-setup-and-analysis/#section\" target=\"_blank\">使用 Octopress 2.0 搭建基于 Github Pages 个人博客的详细过程及原理分析</a></p>\n<p>（3）<a href=\"http://www.jianshu.com/p/0ac2ac1a8e45\" target=\"_blank\">octopress博客搭建和个性化配置</a></p>\n<p>（4）<a href=\"https://liuchungui.github.io/blog/2015/09/11/macdian-nao-shang-da-jian-octopressbo-ke/\" target=\"_blank\">Mac电脑上搭建octopress博客</a></p>\n<p>（5）<a href=\"http://www.cnblogs.com/sawyerzhu/p/3710374.html\" target=\"_blank\">Mac环境下octopress个人博客搭建</a></p>\n<p>（6）<a href=\"http://foggry.com/blog/2014/04/28/custom-your-octopress-blog/\" target=\"_blank\">自定义你的Octopress博客</a></p>\n<p>（7）<a href=\"http://blog.devtang.com/blog/2014/06/02/use-gitcafe-to-host-blog/\" target=\"_blank\">将博客从GitHub迁移到GitCafe</a></p>"},{"layout":"post","title":"iOS FFmpeg编译及kxmovie、iFrameExtractor调试详解（无障碍阅读，绝对是你想要的）","date":"2015-11-15T17:44:27.000Z","comments":1,"keywords":"UICollectionView, WaterFlow, FlowLayout, 下拉刷新","_content":"\n**特此声明：本文是通过网上收集整理加上自己亲自实验得来的。感谢所有网上分享的辛勤劳动者，本文仅供iOS学习使用。在学习的过程中，如果有问题或者不清楚的地方，欢迎留言，我们共同探讨互相学习。欢迎批评指正。**\n\n**如需转载，请注明出处：<a href = \"http://blog.csdn.net/yangshebing21/article/details/43986913\">http://blog.csdn.net/yangshebing21/article/details/43986913</a>**\n\n#### 开发环境：最新 ffmpeg-2.5.4/iOS SDK8.1/Xcode6.1/OS X Yosemite版本10.10.2\n\n### 一、编译ffmpeg库\n\n#### 编译调试ffmpeg库的步骤：\n\n**开发环境：ffmpeg-2.5.4/Xcode6.1**\n\n#### （一）、下载ffmpeg源码：\n\n请点击此链接<a href = \"http://ffmpeg.org/download.html\">http://ffmpeg.org/download.html</a>\n\n <font color = \"red\"><b>注：我的ffmpeg-2.5.4是解压放至Desktop的</b></font>\n \n#### （二）、调试编译ffmpeg源码\n \n 1、安装yasm:\n <!--more-->\n \n 方法一:\n \n 在终端输入\n \n ```\n sudo curlhttp://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz >yasm.tar.gz\n ```\n\n方法二：\n\n（1）Download yasm sourcecode from：\n  <a href = \"http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz\">http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz</a>\n  \n（2）Unpack tar xvzfyasm-1.2.0.tar.gz\n\n（3）cd yasm-1.2.0\n\n（4）Configure and build:\n\n```\n./configure && make -j 4 &&sudo make install\n```\n\n2、下载pearl脚本文件：gas-preprocessor.pl：\n\n下载地址： <a href = \"https://github.com/libav/gas-preprocessor\">https://github.com/libav/gas-preprocessor</a>\n\n（1）拷贝gas-preprocessor.pl文件到 /usr/bin 目录下。\n\n如果找不到/usr/bin目录，直接使用”Finder—>前往—> 前往文件夹—>/usr/bin”或者使用快捷键“shift+command+G”前往文件夹，到指定目录下粘贴gas-preprocessor.pl文件\n \n（2）修改gas-preprocessor.pl文件的读写权限，使用 chmod a+rwxgas-preprocessor.pl\n\n用终端命令cd定位到 gas-preprocessor.pl文件夹下执行：`chmod a+rwxgas-preprocessor.pl`命令\n\n3、下载build-shell.sh脚本文件：\n\n下载地址：<a href = \"https://github.com/kewlbear/FFmpeg-iOS-build-script\">https://github.com/kewlbear/FFmpeg-iOS-build-script</a>\n\n\n（1）下载解压build-shell.sh文件\n\n（2）定位至build-shell.sh文件夹执行build-shell.sh脚本文件\n\n使用方式有4种，我们可以根据特定的使用环境来执行对应的脚本，一般我们就直接执行：`./build-ffmpeg.sh`\n\n* To build everything:\n\n**`./build-ffmpeg.sh`**\n                                    \n* To build arm64 libraries：\n\n**`./build-ffmpeg.sh arm64`**\n\n\n* To build fat libraries for armv7 and x86_64 (64-bit simulator)：\n\n**`./build-ffmpeg.sh armv7 x86_64`**\n\n* To build fat libraries from separately built thin libraries:\n\n**`./build-ffmpeg.sh lipo`**\n\n注：我的build-shell.sh是解压放至Desktop的，以上四种shell脚本的使用方式来自<a href = \"https://github.com/kewlbear/FFmpeg-iOS-build-script\">https://github.com/kewlbear/FFmpeg-iOS-build-script</a>，后面几种方式大家可以自己去尝试。\n\n4、脚本执行完成之后，会在桌面上生成三个文件夹：“FFmpeg-iOS”“scratch”和”thin”文件夹\n\nscratch文件夹里面是单独编译的库，FFmpeg-iOS文件夹里面是合并编译的库。在使用的过程中，我们主要会用到FFmpeg-iOS 文件夹下的“include”文件夹和\"lib\"文件夹中的文件。\n\n\n### 二、在工程中使用FFmpeg，网上成熟的有kxmovie。\n\n1、下载kxmovie工程进行测试：\n\n下载地址： <a href = \"https://github.com/kolyvan/kxmovie\">https://github.com/kolyvan/kxmovie</a>\n\n把FFmpeg编译出来的.a文件添加到工程中。\n\n![](http://ww2.sinaimg.cn/large/7f266405jw1ey37q81fp5j205r09xwfq.jpg)\n\n在使用的时候得注意添加下面的动态链接库文件:\n\n```\nlibz.dylib\nlibbz2.dylib\nlibiconv.dylib\n```\n\n**运行工程**\n\n以下是在编译运行工程中可能会报的错误：\n\n注意：如果在FFmpeg编译的时候出现“ffmpeg yasm not found，use --disable for a crippled build”，原因是 yasm是汇编编译器，因为FFmpeg中为了提高效率用到了汇编指令，解决这个问题有两种方法，一是下载一个yasm.exe安装在mingw/bin下面；二是不使用汇编指令，在配置上加上 即 ./configure --disable-yash 。(这就是为什么前面提到了要安装yasm)\n成功通过编译（这里是指FFmpeg编译成静态库文件）\n\n通过后会生成一个compiled(FFmpeg-iOS)的文件夹，里面有include和lib两个文件夹，这两个文件夹都要拷贝至工程目录下面。include是静态链接库要用到的头文件，lib是存放静态链接库的文件，然后把这些文件存放在项目里面即可，一定要把文件也copy进去，然后在项目的build settings中的header search paths字段加入include文件的路径 如：“$(SRCROOT)/ffmpeg/include” 前面的复选框选不选都可以；再在library search paths字段中加入a文件的路径 如：“$(SRCROOT)/ffmpeg/lib” 。否则可能会出现libavformat/avformat.h file not found 的错误。（出现这个错误是指编译kxmovie工程找不到相应的头文件）\n\n![](http://ww2.sinaimg.cn/large/7f266405jw1ey37rw3nknj20m207wwgg.jpg)\n\n上面图示：在工程目录下有个“FFmpeg”的文件夹，分别把编译FFmpeg完成后产生的“ FFmpeg-iOS ”文件夹中的“include”和”lib”文件夹拷贝至”FFmpeg”文件夹中，include文件夹中存放的是头文件，lib文件夹中存放的是.a静态库文件。最后就是在工程目录下的FFmpeg文件夹包含“include”和”lib”两个文件夹。设置Header Search Paths和Library Search Paths时直接include和lib两个文件夹拖上去，自动显示路径。\n\n![](http://ww4.sinaimg.cn/large/7f266405jw1ey37subv8hj20gu06omye.jpg)\n\n如果还出现找不到 avformat_open_input 的错误（我的没有出现过这个错误），说明你的ffmpeg还是太新了，之前的那个方法名已经改成了这个名字，把avformat_open_input改成av_open_input_file 就可以了。其他错误请自行谷歌或者留言，我们共同探讨。\n上面报错总结文章来自：http://www.dnetzj.com/Content/267.html\n\n最后一步，别忘了安装kxmovie.xcworkspace的cocoapods\n\n**`pod install --verbose --no-repo-update`**\n\n否则会报链接错误\n\n以上kxmovie工程编译调试完毕，模拟器真机都通过测试。目前没有进一步的去研究这个工程，发现播放的视频质量有点粗糙。有时间再做进一步的研究。\n\n### 三、iFrameExtractor-master（iFrameExtractor）工程编译和运行\n\n（1）运行iFrameExtractor-master工程，与上面kxmovie工程操作一样，把FFmpeg文件夹拷贝至工程目录下:\n       (工程目录下本来是没有FFmpeg文件夹的)\n\n![](http://ww1.sinaimg.cn/large/7f266405jw1ey37tiypu8j20gx07b75s.jpg)\n\niFrameExtractor-master下载地址：https://github.com/lajos/iFrameExtractor\n\n\u0010(2)设置好Header Search Paths和Library Search Paths\n\n![](http://ww2.sinaimg.cn/large/7f266405jw1ey37u3v6q5j20kj02x0ts.jpg)\n\n![](http://ww2.sinaimg.cn/large/7f266405jw1ey37v057v9j20kg07p40a.jpg)\n\n\n（3）最后还是会报链接错误：\n\n```\nUndefined symbols for architecture i386:\n\"_iconv\", referenced from:      \n    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)  \n\"_iconv_close\", referenced from:\n    _avcodec_open2 in libavcodec.a(utils.o)\n    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)\n\"_iconv_open\", referenced from:\n    _avcodec_open2 in libavcodec.a(utils.o)\n    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)\nld: symbol(s) not found for architecture i386\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n```\n \n![](http://ww2.sinaimg.cn/large/7f266405jw1ey37vhigjfj20fq0a8djf.jpg)\n\n**解决办法：\"TARGETS\" - > \"BuildSettings\" - > \"Other Linker Flags\" 添加other Linker Flags 项：-liconv**\n\n![](http://ww1.sinaimg.cn/large/7f266405jw1ey37wvjqv1j20dl01s74f.jpg)\n\n此报错问题出自：<a href = \"http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851\">http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851</a>\n\n至此完成iFrameExtractor-master工程编译和运行\n\n### 本文参考文章资料：\n\n* <a href = \"http://blog.csdn.net/oqqQuZi1234567/article/details/43152689\">iOS－－kxmovie之FFmpeg编译和使用</a>\n* <a href = \"http://www.th7.cn/Program/Ruby/201502/385491.shtml\">iOS ffmpeg kxmovie 编译 调试</a>\n\n**欢迎共同学习进步，本着分享的精神，只是为了让你学习起来更加轻松。**\n\n**如需转载，请注明出处：<a href = \"http://blog.csdn.net/yangshebing21/article/details/43986913\">http://blog.csdn.net/yangshebing21/article/details/43986913</a>**","source":"_posts/2015-11-16-ios-ffmpegbian-yi-ji-kxmovie,-iframeextractordiao-shi-xiang-jie-(wu-zhang-ai-yue-du-,jue-dui-shi-ni-xiang-yao-de-).markdown","raw":"---\nlayout: post\ntitle: \"iOS FFmpeg编译及kxmovie、iFrameExtractor调试详解（无障碍阅读，绝对是你想要的）\"\ndate: 2015-11-16 01:44:27 +0800\ncomments: true\ntags: [iOS9, Xcode7.1, UICollectionView]\nkeywords: UICollectionView, WaterFlow, FlowLayout, 下拉刷新\ncategories: Others\n---\n\n**特此声明：本文是通过网上收集整理加上自己亲自实验得来的。感谢所有网上分享的辛勤劳动者，本文仅供iOS学习使用。在学习的过程中，如果有问题或者不清楚的地方，欢迎留言，我们共同探讨互相学习。欢迎批评指正。**\n\n**如需转载，请注明出处：<a href = \"http://blog.csdn.net/yangshebing21/article/details/43986913\">http://blog.csdn.net/yangshebing21/article/details/43986913</a>**\n\n#### 开发环境：最新 ffmpeg-2.5.4/iOS SDK8.1/Xcode6.1/OS X Yosemite版本10.10.2\n\n### 一、编译ffmpeg库\n\n#### 编译调试ffmpeg库的步骤：\n\n**开发环境：ffmpeg-2.5.4/Xcode6.1**\n\n#### （一）、下载ffmpeg源码：\n\n请点击此链接<a href = \"http://ffmpeg.org/download.html\">http://ffmpeg.org/download.html</a>\n\n <font color = \"red\"><b>注：我的ffmpeg-2.5.4是解压放至Desktop的</b></font>\n \n#### （二）、调试编译ffmpeg源码\n \n 1、安装yasm:\n <!--more-->\n \n 方法一:\n \n 在终端输入\n \n ```\n sudo curlhttp://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz >yasm.tar.gz\n ```\n\n方法二：\n\n（1）Download yasm sourcecode from：\n  <a href = \"http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz\">http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz</a>\n  \n（2）Unpack tar xvzfyasm-1.2.0.tar.gz\n\n（3）cd yasm-1.2.0\n\n（4）Configure and build:\n\n```\n./configure && make -j 4 &&sudo make install\n```\n\n2、下载pearl脚本文件：gas-preprocessor.pl：\n\n下载地址： <a href = \"https://github.com/libav/gas-preprocessor\">https://github.com/libav/gas-preprocessor</a>\n\n（1）拷贝gas-preprocessor.pl文件到 /usr/bin 目录下。\n\n如果找不到/usr/bin目录，直接使用”Finder—>前往—> 前往文件夹—>/usr/bin”或者使用快捷键“shift+command+G”前往文件夹，到指定目录下粘贴gas-preprocessor.pl文件\n \n（2）修改gas-preprocessor.pl文件的读写权限，使用 chmod a+rwxgas-preprocessor.pl\n\n用终端命令cd定位到 gas-preprocessor.pl文件夹下执行：`chmod a+rwxgas-preprocessor.pl`命令\n\n3、下载build-shell.sh脚本文件：\n\n下载地址：<a href = \"https://github.com/kewlbear/FFmpeg-iOS-build-script\">https://github.com/kewlbear/FFmpeg-iOS-build-script</a>\n\n\n（1）下载解压build-shell.sh文件\n\n（2）定位至build-shell.sh文件夹执行build-shell.sh脚本文件\n\n使用方式有4种，我们可以根据特定的使用环境来执行对应的脚本，一般我们就直接执行：`./build-ffmpeg.sh`\n\n* To build everything:\n\n**`./build-ffmpeg.sh`**\n                                    \n* To build arm64 libraries：\n\n**`./build-ffmpeg.sh arm64`**\n\n\n* To build fat libraries for armv7 and x86_64 (64-bit simulator)：\n\n**`./build-ffmpeg.sh armv7 x86_64`**\n\n* To build fat libraries from separately built thin libraries:\n\n**`./build-ffmpeg.sh lipo`**\n\n注：我的build-shell.sh是解压放至Desktop的，以上四种shell脚本的使用方式来自<a href = \"https://github.com/kewlbear/FFmpeg-iOS-build-script\">https://github.com/kewlbear/FFmpeg-iOS-build-script</a>，后面几种方式大家可以自己去尝试。\n\n4、脚本执行完成之后，会在桌面上生成三个文件夹：“FFmpeg-iOS”“scratch”和”thin”文件夹\n\nscratch文件夹里面是单独编译的库，FFmpeg-iOS文件夹里面是合并编译的库。在使用的过程中，我们主要会用到FFmpeg-iOS 文件夹下的“include”文件夹和\"lib\"文件夹中的文件。\n\n\n### 二、在工程中使用FFmpeg，网上成熟的有kxmovie。\n\n1、下载kxmovie工程进行测试：\n\n下载地址： <a href = \"https://github.com/kolyvan/kxmovie\">https://github.com/kolyvan/kxmovie</a>\n\n把FFmpeg编译出来的.a文件添加到工程中。\n\n![](http://ww2.sinaimg.cn/large/7f266405jw1ey37q81fp5j205r09xwfq.jpg)\n\n在使用的时候得注意添加下面的动态链接库文件:\n\n```\nlibz.dylib\nlibbz2.dylib\nlibiconv.dylib\n```\n\n**运行工程**\n\n以下是在编译运行工程中可能会报的错误：\n\n注意：如果在FFmpeg编译的时候出现“ffmpeg yasm not found，use --disable for a crippled build”，原因是 yasm是汇编编译器，因为FFmpeg中为了提高效率用到了汇编指令，解决这个问题有两种方法，一是下载一个yasm.exe安装在mingw/bin下面；二是不使用汇编指令，在配置上加上 即 ./configure --disable-yash 。(这就是为什么前面提到了要安装yasm)\n成功通过编译（这里是指FFmpeg编译成静态库文件）\n\n通过后会生成一个compiled(FFmpeg-iOS)的文件夹，里面有include和lib两个文件夹，这两个文件夹都要拷贝至工程目录下面。include是静态链接库要用到的头文件，lib是存放静态链接库的文件，然后把这些文件存放在项目里面即可，一定要把文件也copy进去，然后在项目的build settings中的header search paths字段加入include文件的路径 如：“$(SRCROOT)/ffmpeg/include” 前面的复选框选不选都可以；再在library search paths字段中加入a文件的路径 如：“$(SRCROOT)/ffmpeg/lib” 。否则可能会出现libavformat/avformat.h file not found 的错误。（出现这个错误是指编译kxmovie工程找不到相应的头文件）\n\n![](http://ww2.sinaimg.cn/large/7f266405jw1ey37rw3nknj20m207wwgg.jpg)\n\n上面图示：在工程目录下有个“FFmpeg”的文件夹，分别把编译FFmpeg完成后产生的“ FFmpeg-iOS ”文件夹中的“include”和”lib”文件夹拷贝至”FFmpeg”文件夹中，include文件夹中存放的是头文件，lib文件夹中存放的是.a静态库文件。最后就是在工程目录下的FFmpeg文件夹包含“include”和”lib”两个文件夹。设置Header Search Paths和Library Search Paths时直接include和lib两个文件夹拖上去，自动显示路径。\n\n![](http://ww4.sinaimg.cn/large/7f266405jw1ey37subv8hj20gu06omye.jpg)\n\n如果还出现找不到 avformat_open_input 的错误（我的没有出现过这个错误），说明你的ffmpeg还是太新了，之前的那个方法名已经改成了这个名字，把avformat_open_input改成av_open_input_file 就可以了。其他错误请自行谷歌或者留言，我们共同探讨。\n上面报错总结文章来自：http://www.dnetzj.com/Content/267.html\n\n最后一步，别忘了安装kxmovie.xcworkspace的cocoapods\n\n**`pod install --verbose --no-repo-update`**\n\n否则会报链接错误\n\n以上kxmovie工程编译调试完毕，模拟器真机都通过测试。目前没有进一步的去研究这个工程，发现播放的视频质量有点粗糙。有时间再做进一步的研究。\n\n### 三、iFrameExtractor-master（iFrameExtractor）工程编译和运行\n\n（1）运行iFrameExtractor-master工程，与上面kxmovie工程操作一样，把FFmpeg文件夹拷贝至工程目录下:\n       (工程目录下本来是没有FFmpeg文件夹的)\n\n![](http://ww1.sinaimg.cn/large/7f266405jw1ey37tiypu8j20gx07b75s.jpg)\n\niFrameExtractor-master下载地址：https://github.com/lajos/iFrameExtractor\n\n\u0010(2)设置好Header Search Paths和Library Search Paths\n\n![](http://ww2.sinaimg.cn/large/7f266405jw1ey37u3v6q5j20kj02x0ts.jpg)\n\n![](http://ww2.sinaimg.cn/large/7f266405jw1ey37v057v9j20kg07p40a.jpg)\n\n\n（3）最后还是会报链接错误：\n\n```\nUndefined symbols for architecture i386:\n\"_iconv\", referenced from:      \n    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)  \n\"_iconv_close\", referenced from:\n    _avcodec_open2 in libavcodec.a(utils.o)\n    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)\n\"_iconv_open\", referenced from:\n    _avcodec_open2 in libavcodec.a(utils.o)\n    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)\nld: symbol(s) not found for architecture i386\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n```\n \n![](http://ww2.sinaimg.cn/large/7f266405jw1ey37vhigjfj20fq0a8djf.jpg)\n\n**解决办法：\"TARGETS\" - > \"BuildSettings\" - > \"Other Linker Flags\" 添加other Linker Flags 项：-liconv**\n\n![](http://ww1.sinaimg.cn/large/7f266405jw1ey37wvjqv1j20dl01s74f.jpg)\n\n此报错问题出自：<a href = \"http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851\">http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851</a>\n\n至此完成iFrameExtractor-master工程编译和运行\n\n### 本文参考文章资料：\n\n* <a href = \"http://blog.csdn.net/oqqQuZi1234567/article/details/43152689\">iOS－－kxmovie之FFmpeg编译和使用</a>\n* <a href = \"http://www.th7.cn/Program/Ruby/201502/385491.shtml\">iOS ffmpeg kxmovie 编译 调试</a>\n\n**欢迎共同学习进步，本着分享的精神，只是为了让你学习起来更加轻松。**\n\n**如需转载，请注明出处：<a href = \"http://blog.csdn.net/yangshebing21/article/details/43986913\">http://blog.csdn.net/yangshebing21/article/details/43986913</a>**","slug":"ios-ffmpegbian-yi-ji-kxmovie,-iframeextractordiao-shi-xiang-jie-(wu-zhang-ai-yue-du-,jue-dui-shi-ni-xiang-yao-de-)","published":1,"updated":"2016-09-10T05:17:16.000Z","_id":"ciswie9co0009e3u2qokc92en","photos":[],"link":"","content":"<p><strong>特此声明：本文是通过网上收集整理加上自己亲自实验得来的。感谢所有网上分享的辛勤劳动者，本文仅供iOS学习使用。在学习的过程中，如果有问题或者不清楚的地方，欢迎留言，我们共同探讨互相学习。欢迎批评指正。</strong></p>\n<p><strong>如需转载，请注明出处：<a href=\"http://blog.csdn.net/yangshebing21/article/details/43986913\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/yangshebing21/article/details/43986913</a></strong></p>\n<h4 id=\"开发环境：最新-ffmpeg-2-5-4-iOS-SDK8-1-Xcode6-1-OS-X-Yosemite版本10-10-2\"><a href=\"#开发环境：最新-ffmpeg-2-5-4-iOS-SDK8-1-Xcode6-1-OS-X-Yosemite版本10-10-2\" class=\"headerlink\" title=\"开发环境：最新 ffmpeg-2.5.4/iOS SDK8.1/Xcode6.1/OS X Yosemite版本10.10.2\"></a>开发环境：最新 ffmpeg-2.5.4/iOS SDK8.1/Xcode6.1/OS X Yosemite版本10.10.2</h4><h3 id=\"一、编译ffmpeg库\"><a href=\"#一、编译ffmpeg库\" class=\"headerlink\" title=\"一、编译ffmpeg库\"></a>一、编译ffmpeg库</h3><h4 id=\"编译调试ffmpeg库的步骤：\"><a href=\"#编译调试ffmpeg库的步骤：\" class=\"headerlink\" title=\"编译调试ffmpeg库的步骤：\"></a>编译调试ffmpeg库的步骤：</h4><p><strong>开发环境：ffmpeg-2.5.4/Xcode6.1</strong></p>\n<h4 id=\"（一）、下载ffmpeg源码：\"><a href=\"#（一）、下载ffmpeg源码：\" class=\"headerlink\" title=\"（一）、下载ffmpeg源码：\"></a>（一）、下载ffmpeg源码：</h4><p>请点击此链接<a href=\"http://ffmpeg.org/download.html\" target=\"_blank\" rel=\"external\">http://ffmpeg.org/download.html</a></p>\n <font color=\"red\"><b>注：我的ffmpeg-2.5.4是解压放至Desktop的</b></font>\n\n<h4 id=\"（二）、调试编译ffmpeg源码\"><a href=\"#（二）、调试编译ffmpeg源码\" class=\"headerlink\" title=\"（二）、调试编译ffmpeg源码\"></a>（二）、调试编译ffmpeg源码</h4><p> 1、安装yasm:<br> <a id=\"more\"></a></p>\n<p> 方法一:</p>\n<p> 在终端输入</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo curlhttp://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz &gt;yasm.tar.gz</div></pre></td></tr></table></figure>\n<p>方法二：</p>\n<p>（1）Download yasm sourcecode from：<br>  <a href=\"http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz\" target=\"_blank\" rel=\"external\">http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz</a></p>\n<p>（2）Unpack tar xvzfyasm-1.2.0.tar.gz</p>\n<p>（3）cd yasm-1.2.0</p>\n<p>（4）Configure and build:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./configure &amp;&amp; make -j 4 &amp;&amp;sudo make install</div></pre></td></tr></table></figure>\n<p>2、下载pearl脚本文件：gas-preprocessor.pl：</p>\n<p>下载地址： <a href=\"https://github.com/libav/gas-preprocessor\" target=\"_blank\" rel=\"external\">https://github.com/libav/gas-preprocessor</a></p>\n<p>（1）拷贝gas-preprocessor.pl文件到 /usr/bin 目录下。</p>\n<p>如果找不到/usr/bin目录，直接使用”Finder—&gt;前往—&gt; 前往文件夹—&gt;/usr/bin”或者使用快捷键“shift+command+G”前往文件夹，到指定目录下粘贴gas-preprocessor.pl文件</p>\n<p>（2）修改gas-preprocessor.pl文件的读写权限，使用 chmod a+rwxgas-preprocessor.pl</p>\n<p>用终端命令cd定位到 gas-preprocessor.pl文件夹下执行：<code>chmod a+rwxgas-preprocessor.pl</code>命令</p>\n<p>3、下载build-shell.sh脚本文件：</p>\n<p>下载地址：<a href=\"https://github.com/kewlbear/FFmpeg-iOS-build-script\" target=\"_blank\" rel=\"external\">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></p>\n<p>（1）下载解压build-shell.sh文件</p>\n<p>（2）定位至build-shell.sh文件夹执行build-shell.sh脚本文件</p>\n<p>使用方式有4种，我们可以根据特定的使用环境来执行对应的脚本，一般我们就直接执行：<code>./build-ffmpeg.sh</code></p>\n<ul>\n<li>To build everything:</li>\n</ul>\n<p><strong><code>./build-ffmpeg.sh</code></strong></p>\n<ul>\n<li>To build arm64 libraries：</li>\n</ul>\n<p><strong><code>./build-ffmpeg.sh arm64</code></strong></p>\n<ul>\n<li>To build fat libraries for armv7 and x86_64 (64-bit simulator)：</li>\n</ul>\n<p><strong><code>./build-ffmpeg.sh armv7 x86_64</code></strong></p>\n<ul>\n<li>To build fat libraries from separately built thin libraries:</li>\n</ul>\n<p><strong><code>./build-ffmpeg.sh lipo</code></strong></p>\n<p>注：我的build-shell.sh是解压放至Desktop的，以上四种shell脚本的使用方式来自<a href=\"https://github.com/kewlbear/FFmpeg-iOS-build-script\" target=\"_blank\" rel=\"external\">https://github.com/kewlbear/FFmpeg-iOS-build-script</a>，后面几种方式大家可以自己去尝试。</p>\n<p>4、脚本执行完成之后，会在桌面上生成三个文件夹：“FFmpeg-iOS”“scratch”和”thin”文件夹</p>\n<p>scratch文件夹里面是单独编译的库，FFmpeg-iOS文件夹里面是合并编译的库。在使用的过程中，我们主要会用到FFmpeg-iOS 文件夹下的“include”文件夹和”lib”文件夹中的文件。</p>\n<h3 id=\"二、在工程中使用FFmpeg，网上成熟的有kxmovie。\"><a href=\"#二、在工程中使用FFmpeg，网上成熟的有kxmovie。\" class=\"headerlink\" title=\"二、在工程中使用FFmpeg，网上成熟的有kxmovie。\"></a>二、在工程中使用FFmpeg，网上成熟的有kxmovie。</h3><p>1、下载kxmovie工程进行测试：</p>\n<p>下载地址： <a href=\"https://github.com/kolyvan/kxmovie\" target=\"_blank\" rel=\"external\">https://github.com/kolyvan/kxmovie</a></p>\n<p>把FFmpeg编译出来的.a文件添加到工程中。</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/7f266405jw1ey37q81fp5j205r09xwfq.jpg\" alt=\"\"></p>\n<p>在使用的时候得注意添加下面的动态链接库文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">libz.dylib</div><div class=\"line\">libbz2.dylib</div><div class=\"line\">libiconv.dylib</div></pre></td></tr></table></figure>\n<p><strong>运行工程</strong></p>\n<p>以下是在编译运行工程中可能会报的错误：</p>\n<p>注意：如果在FFmpeg编译的时候出现“ffmpeg yasm not found，use –disable for a crippled build”，原因是 yasm是汇编编译器，因为FFmpeg中为了提高效率用到了汇编指令，解决这个问题有两种方法，一是下载一个yasm.exe安装在mingw/bin下面；二是不使用汇编指令，在配置上加上 即 ./configure –disable-yash 。(这就是为什么前面提到了要安装yasm)<br>成功通过编译（这里是指FFmpeg编译成静态库文件）</p>\n<p>通过后会生成一个compiled(FFmpeg-iOS)的文件夹，里面有include和lib两个文件夹，这两个文件夹都要拷贝至工程目录下面。include是静态链接库要用到的头文件，lib是存放静态链接库的文件，然后把这些文件存放在项目里面即可，一定要把文件也copy进去，然后在项目的build settings中的header search paths字段加入include文件的路径 如：“$(SRCROOT)/ffmpeg/include” 前面的复选框选不选都可以；再在library search paths字段中加入a文件的路径 如：“$(SRCROOT)/ffmpeg/lib” 。否则可能会出现libavformat/avformat.h file not found 的错误。（出现这个错误是指编译kxmovie工程找不到相应的头文件）</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/7f266405jw1ey37rw3nknj20m207wwgg.jpg\" alt=\"\"></p>\n<p>上面图示：在工程目录下有个“FFmpeg”的文件夹，分别把编译FFmpeg完成后产生的“ FFmpeg-iOS ”文件夹中的“include”和”lib”文件夹拷贝至”FFmpeg”文件夹中，include文件夹中存放的是头文件，lib文件夹中存放的是.a静态库文件。最后就是在工程目录下的FFmpeg文件夹包含“include”和”lib”两个文件夹。设置Header Search Paths和Library Search Paths时直接include和lib两个文件夹拖上去，自动显示路径。</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/7f266405jw1ey37subv8hj20gu06omye.jpg\" alt=\"\"></p>\n<p>如果还出现找不到 avformat_open_input 的错误（我的没有出现过这个错误），说明你的ffmpeg还是太新了，之前的那个方法名已经改成了这个名字，把avformat_open_input改成av_open_input_file 就可以了。其他错误请自行谷歌或者留言，我们共同探讨。<br>上面报错总结文章来自：<a href=\"http://www.dnetzj.com/Content/267.html\" target=\"_blank\" rel=\"external\">http://www.dnetzj.com/Content/267.html</a></p>\n<p>最后一步，别忘了安装kxmovie.xcworkspace的cocoapods</p>\n<p><strong><code>pod install --verbose --no-repo-update</code></strong></p>\n<p>否则会报链接错误</p>\n<p>以上kxmovie工程编译调试完毕，模拟器真机都通过测试。目前没有进一步的去研究这个工程，发现播放的视频质量有点粗糙。有时间再做进一步的研究。</p>\n<h3 id=\"三、iFrameExtractor-master（iFrameExtractor）工程编译和运行\"><a href=\"#三、iFrameExtractor-master（iFrameExtractor）工程编译和运行\" class=\"headerlink\" title=\"三、iFrameExtractor-master（iFrameExtractor）工程编译和运行\"></a>三、iFrameExtractor-master（iFrameExtractor）工程编译和运行</h3><p>（1）运行iFrameExtractor-master工程，与上面kxmovie工程操作一样，把FFmpeg文件夹拷贝至工程目录下:<br>       (工程目录下本来是没有FFmpeg文件夹的)</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/7f266405jw1ey37tiypu8j20gx07b75s.jpg\" alt=\"\"></p>\n<p>iFrameExtractor-master下载地址：<a href=\"https://github.com/lajos/iFrameExtractor\" target=\"_blank\" rel=\"external\">https://github.com/lajos/iFrameExtractor</a></p>\n<p>\u0010(2)设置好Header Search Paths和Library Search Paths</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/7f266405jw1ey37u3v6q5j20kj02x0ts.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww2.sinaimg.cn/large/7f266405jw1ey37v057v9j20kg07p40a.jpg\" alt=\"\"></p>\n<p>（3）最后还是会报链接错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Undefined symbols for architecture i386:</div><div class=\"line\">&quot;_iconv&quot;, referenced from:      </div><div class=\"line\">    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)  </div><div class=\"line\">&quot;_iconv_close&quot;, referenced from:</div><div class=\"line\">    _avcodec_open2 in libavcodec.a(utils.o)</div><div class=\"line\">    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)</div><div class=\"line\">&quot;_iconv_open&quot;, referenced from:</div><div class=\"line\">    _avcodec_open2 in libavcodec.a(utils.o)</div><div class=\"line\">    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)</div><div class=\"line\">ld: symbol(s) not found for architecture i386</div><div class=\"line\">clang: error: linker command failed with exit code 1 (use -v to see invocation)</div></pre></td></tr></table></figure>\n<p><img src=\"http://ww2.sinaimg.cn/large/7f266405jw1ey37vhigjfj20fq0a8djf.jpg\" alt=\"\"></p>\n<p><strong>解决办法：”TARGETS” - &gt; “BuildSettings” - &gt; “Other Linker Flags” 添加other Linker Flags 项：-liconv</strong></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/7f266405jw1ey37wvjqv1j20dl01s74f.jpg\" alt=\"\"></p>\n<p>此报错问题出自：<a href=\"http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851</a></p>\n<p>至此完成iFrameExtractor-master工程编译和运行</p>\n<h3 id=\"本文参考文章资料：\"><a href=\"#本文参考文章资料：\" class=\"headerlink\" title=\"本文参考文章资料：\"></a>本文参考文章资料：</h3><ul>\n<li><a href=\"http://blog.csdn.net/oqqQuZi1234567/article/details/43152689\" target=\"_blank\" rel=\"external\">iOS－－kxmovie之FFmpeg编译和使用</a></li>\n<li><a href=\"http://www.th7.cn/Program/Ruby/201502/385491.shtml\" target=\"_blank\" rel=\"external\">iOS ffmpeg kxmovie 编译 调试</a></li>\n</ul>\n<p><strong>欢迎共同学习进步，本着分享的精神，只是为了让你学习起来更加轻松。</strong></p>\n<p><strong>如需转载，请注明出处：<a href=\"http://blog.csdn.net/yangshebing21/article/details/43986913\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/yangshebing21/article/details/43986913</a></strong></p>\n","excerpt":"<p><strong>特此声明：本文是通过网上收集整理加上自己亲自实验得来的。感谢所有网上分享的辛勤劳动者，本文仅供iOS学习使用。在学习的过程中，如果有问题或者不清楚的地方，欢迎留言，我们共同探讨互相学习。欢迎批评指正。</strong></p>\n<p><strong>如需转载，请注明出处：<a href = \"http://blog.csdn.net/yangshebing21/article/details/43986913\">http://blog.csdn.net/yangshebing21/article/details/43986913</a></strong></p>\n<h4 id=\"开发环境：最新-ffmpeg-2-5-4-iOS-SDK8-1-Xcode6-1-OS-X-Yosemite版本10-10-2\"><a href=\"#开发环境：最新-ffmpeg-2-5-4-iOS-SDK8-1-Xcode6-1-OS-X-Yosemite版本10-10-2\" class=\"headerlink\" title=\"开发环境：最新 ffmpeg-2.5.4/iOS SDK8.1/Xcode6.1/OS X Yosemite版本10.10.2\"></a>开发环境：最新 ffmpeg-2.5.4/iOS SDK8.1/Xcode6.1/OS X Yosemite版本10.10.2</h4><h3 id=\"一、编译ffmpeg库\"><a href=\"#一、编译ffmpeg库\" class=\"headerlink\" title=\"一、编译ffmpeg库\"></a>一、编译ffmpeg库</h3><h4 id=\"编译调试ffmpeg库的步骤：\"><a href=\"#编译调试ffmpeg库的步骤：\" class=\"headerlink\" title=\"编译调试ffmpeg库的步骤：\"></a>编译调试ffmpeg库的步骤：</h4><p><strong>开发环境：ffmpeg-2.5.4/Xcode6.1</strong></p>\n<h4 id=\"（一）、下载ffmpeg源码：\"><a href=\"#（一）、下载ffmpeg源码：\" class=\"headerlink\" title=\"（一）、下载ffmpeg源码：\"></a>（一）、下载ffmpeg源码：</h4><p>请点击此链接<a href = \"http://ffmpeg.org/download.html\">http://ffmpeg.org/download.html</a></p>\n <font color = \"red\"><b>注：我的ffmpeg-2.5.4是解压放至Desktop的</b></font>\n\n<h4 id=\"（二）、调试编译ffmpeg源码\"><a href=\"#（二）、调试编译ffmpeg源码\" class=\"headerlink\" title=\"（二）、调试编译ffmpeg源码\"></a>（二）、调试编译ffmpeg源码</h4><p> 1、安装yasm:<br>","more":"</p>\n<p> 方法一:</p>\n<p> 在终端输入</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo curlhttp://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz &gt;yasm.tar.gz</div></pre></td></tr></table></figure>\n<p>方法二：</p>\n<p>（1）Download yasm sourcecode from：<br>  <a href = \"http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz\">http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz</a></p>\n<p>（2）Unpack tar xvzfyasm-1.2.0.tar.gz</p>\n<p>（3）cd yasm-1.2.0</p>\n<p>（4）Configure and build:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./configure &amp;&amp; make -j 4 &amp;&amp;sudo make install</div></pre></td></tr></table></figure>\n<p>2、下载pearl脚本文件：gas-preprocessor.pl：</p>\n<p>下载地址： <a href = \"https://github.com/libav/gas-preprocessor\">https://github.com/libav/gas-preprocessor</a></p>\n<p>（1）拷贝gas-preprocessor.pl文件到 /usr/bin 目录下。</p>\n<p>如果找不到/usr/bin目录，直接使用”Finder—&gt;前往—&gt; 前往文件夹—&gt;/usr/bin”或者使用快捷键“shift+command+G”前往文件夹，到指定目录下粘贴gas-preprocessor.pl文件</p>\n<p>（2）修改gas-preprocessor.pl文件的读写权限，使用 chmod a+rwxgas-preprocessor.pl</p>\n<p>用终端命令cd定位到 gas-preprocessor.pl文件夹下执行：<code>chmod a+rwxgas-preprocessor.pl</code>命令</p>\n<p>3、下载build-shell.sh脚本文件：</p>\n<p>下载地址：<a href = \"https://github.com/kewlbear/FFmpeg-iOS-build-script\">https://github.com/kewlbear/FFmpeg-iOS-build-script</a></p>\n<p>（1）下载解压build-shell.sh文件</p>\n<p>（2）定位至build-shell.sh文件夹执行build-shell.sh脚本文件</p>\n<p>使用方式有4种，我们可以根据特定的使用环境来执行对应的脚本，一般我们就直接执行：<code>./build-ffmpeg.sh</code></p>\n<ul>\n<li>To build everything:</li>\n</ul>\n<p><strong><code>./build-ffmpeg.sh</code></strong></p>\n<ul>\n<li>To build arm64 libraries：</li>\n</ul>\n<p><strong><code>./build-ffmpeg.sh arm64</code></strong></p>\n<ul>\n<li>To build fat libraries for armv7 and x86_64 (64-bit simulator)：</li>\n</ul>\n<p><strong><code>./build-ffmpeg.sh armv7 x86_64</code></strong></p>\n<ul>\n<li>To build fat libraries from separately built thin libraries:</li>\n</ul>\n<p><strong><code>./build-ffmpeg.sh lipo</code></strong></p>\n<p>注：我的build-shell.sh是解压放至Desktop的，以上四种shell脚本的使用方式来自<a href = \"https://github.com/kewlbear/FFmpeg-iOS-build-script\">https://github.com/kewlbear/FFmpeg-iOS-build-script</a>，后面几种方式大家可以自己去尝试。</p>\n<p>4、脚本执行完成之后，会在桌面上生成三个文件夹：“FFmpeg-iOS”“scratch”和”thin”文件夹</p>\n<p>scratch文件夹里面是单独编译的库，FFmpeg-iOS文件夹里面是合并编译的库。在使用的过程中，我们主要会用到FFmpeg-iOS 文件夹下的“include”文件夹和”lib”文件夹中的文件。</p>\n<h3 id=\"二、在工程中使用FFmpeg，网上成熟的有kxmovie。\"><a href=\"#二、在工程中使用FFmpeg，网上成熟的有kxmovie。\" class=\"headerlink\" title=\"二、在工程中使用FFmpeg，网上成熟的有kxmovie。\"></a>二、在工程中使用FFmpeg，网上成熟的有kxmovie。</h3><p>1、下载kxmovie工程进行测试：</p>\n<p>下载地址： <a href = \"https://github.com/kolyvan/kxmovie\">https://github.com/kolyvan/kxmovie</a></p>\n<p>把FFmpeg编译出来的.a文件添加到工程中。</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/7f266405jw1ey37q81fp5j205r09xwfq.jpg\" alt=\"\"></p>\n<p>在使用的时候得注意添加下面的动态链接库文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">libz.dylib</div><div class=\"line\">libbz2.dylib</div><div class=\"line\">libiconv.dylib</div></pre></td></tr></table></figure>\n<p><strong>运行工程</strong></p>\n<p>以下是在编译运行工程中可能会报的错误：</p>\n<p>注意：如果在FFmpeg编译的时候出现“ffmpeg yasm not found，use –disable for a crippled build”，原因是 yasm是汇编编译器，因为FFmpeg中为了提高效率用到了汇编指令，解决这个问题有两种方法，一是下载一个yasm.exe安装在mingw/bin下面；二是不使用汇编指令，在配置上加上 即 ./configure –disable-yash 。(这就是为什么前面提到了要安装yasm)<br>成功通过编译（这里是指FFmpeg编译成静态库文件）</p>\n<p>通过后会生成一个compiled(FFmpeg-iOS)的文件夹，里面有include和lib两个文件夹，这两个文件夹都要拷贝至工程目录下面。include是静态链接库要用到的头文件，lib是存放静态链接库的文件，然后把这些文件存放在项目里面即可，一定要把文件也copy进去，然后在项目的build settings中的header search paths字段加入include文件的路径 如：“$(SRCROOT)/ffmpeg/include” 前面的复选框选不选都可以；再在library search paths字段中加入a文件的路径 如：“$(SRCROOT)/ffmpeg/lib” 。否则可能会出现libavformat/avformat.h file not found 的错误。（出现这个错误是指编译kxmovie工程找不到相应的头文件）</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/7f266405jw1ey37rw3nknj20m207wwgg.jpg\" alt=\"\"></p>\n<p>上面图示：在工程目录下有个“FFmpeg”的文件夹，分别把编译FFmpeg完成后产生的“ FFmpeg-iOS ”文件夹中的“include”和”lib”文件夹拷贝至”FFmpeg”文件夹中，include文件夹中存放的是头文件，lib文件夹中存放的是.a静态库文件。最后就是在工程目录下的FFmpeg文件夹包含“include”和”lib”两个文件夹。设置Header Search Paths和Library Search Paths时直接include和lib两个文件夹拖上去，自动显示路径。</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/7f266405jw1ey37subv8hj20gu06omye.jpg\" alt=\"\"></p>\n<p>如果还出现找不到 avformat_open_input 的错误（我的没有出现过这个错误），说明你的ffmpeg还是太新了，之前的那个方法名已经改成了这个名字，把avformat_open_input改成av_open_input_file 就可以了。其他错误请自行谷歌或者留言，我们共同探讨。<br>上面报错总结文章来自：<a href=\"http://www.dnetzj.com/Content/267.html\">http://www.dnetzj.com/Content/267.html</a></p>\n<p>最后一步，别忘了安装kxmovie.xcworkspace的cocoapods</p>\n<p><strong><code>pod install --verbose --no-repo-update</code></strong></p>\n<p>否则会报链接错误</p>\n<p>以上kxmovie工程编译调试完毕，模拟器真机都通过测试。目前没有进一步的去研究这个工程，发现播放的视频质量有点粗糙。有时间再做进一步的研究。</p>\n<h3 id=\"三、iFrameExtractor-master（iFrameExtractor）工程编译和运行\"><a href=\"#三、iFrameExtractor-master（iFrameExtractor）工程编译和运行\" class=\"headerlink\" title=\"三、iFrameExtractor-master（iFrameExtractor）工程编译和运行\"></a>三、iFrameExtractor-master（iFrameExtractor）工程编译和运行</h3><p>（1）运行iFrameExtractor-master工程，与上面kxmovie工程操作一样，把FFmpeg文件夹拷贝至工程目录下:<br>       (工程目录下本来是没有FFmpeg文件夹的)</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/7f266405jw1ey37tiypu8j20gx07b75s.jpg\" alt=\"\"></p>\n<p>iFrameExtractor-master下载地址：<a href=\"https://github.com/lajos/iFrameExtractor\">https://github.com/lajos/iFrameExtractor</a></p>\n<p>\u0010(2)设置好Header Search Paths和Library Search Paths</p>\n<p><img src=\"http://ww2.sinaimg.cn/large/7f266405jw1ey37u3v6q5j20kj02x0ts.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww2.sinaimg.cn/large/7f266405jw1ey37v057v9j20kg07p40a.jpg\" alt=\"\"></p>\n<p>（3）最后还是会报链接错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Undefined symbols for architecture i386:</div><div class=\"line\">&quot;_iconv&quot;, referenced from:      </div><div class=\"line\">    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)  </div><div class=\"line\">&quot;_iconv_close&quot;, referenced from:</div><div class=\"line\">    _avcodec_open2 in libavcodec.a(utils.o)</div><div class=\"line\">    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)</div><div class=\"line\">&quot;_iconv_open&quot;, referenced from:</div><div class=\"line\">    _avcodec_open2 in libavcodec.a(utils.o)</div><div class=\"line\">    _avcodec_decode_subtitle2 in libavcodec.a(utils.o)</div><div class=\"line\">ld: symbol(s) not found for architecture i386</div><div class=\"line\">clang: error: linker command failed with exit code 1 (use -v to see invocation)</div></pre></td></tr></table></figure>\n<p><img src=\"http://ww2.sinaimg.cn/large/7f266405jw1ey37vhigjfj20fq0a8djf.jpg\" alt=\"\"></p>\n<p><strong>解决办法：”TARGETS” - &gt; “BuildSettings” - &gt; “Other Linker Flags” 添加other Linker Flags 项：-liconv</strong></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/7f266405jw1ey37wvjqv1j20dl01s74f.jpg\" alt=\"\"></p>\n<p>此报错问题出自：<a href = \"http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851\">http://stackoverflow.com/questions/21211215/ffmpeg-wont-build-in-my-project-works-fine-in-example-app/28777851#28777851</a></p>\n<p>至此完成iFrameExtractor-master工程编译和运行</p>\n<h3 id=\"本文参考文章资料：\"><a href=\"#本文参考文章资料：\" class=\"headerlink\" title=\"本文参考文章资料：\"></a>本文参考文章资料：</h3><ul>\n<li><a href = \"http://blog.csdn.net/oqqQuZi1234567/article/details/43152689\">iOS－－kxmovie之FFmpeg编译和使用</a></li>\n<li><a href = \"http://www.th7.cn/Program/Ruby/201502/385491.shtml\">iOS ffmpeg kxmovie 编译 调试</a></li>\n</ul>\n<p><strong>欢迎共同学习进步，本着分享的精神，只是为了让你学习起来更加轻松。</strong></p>\n<p><strong>如需转载，请注明出处：<a href = \"http://blog.csdn.net/yangshebing21/article/details/43986913\">http://blog.csdn.net/yangshebing21/article/details/43986913</a></strong></p>"},{"layout":"post","title":"iOS绘制虚线方式总结","date":"2015-10-12T15:44:28.000Z","comments":1,"keywords":"ios开发, 绘制虚线","_content":"### 一、iOS中绘制虚线常见的几种方式：\n\n1、重写drawRect方法。\n\n```\n- (void)drawRect:(CGRect)rect\n{\n    [super drawRect:rect];\nCGContextRef currentContext = UIGraphicsGetCurrentContext();\n//设置虚线颜色\n    CGContextSetStrokeColorWithColor(currentContext, [UIColor BlackColor].CGColor);\n    //设置虚线宽度\n    CGContextSetLineWidth(currentContext, 1);\n    //设置虚线绘制起点\n    CGContextMoveToPoint(currentContext, 0, 0);\n    //设置虚线绘制终点\n    CGContextAddLineToPoint(currentContext, self.frame.origin.x + self.frame.size.width, 0);\n    //设置虚线排列的宽度间隔:下面的arr中的数字表示先绘制3个点再绘制1个点\n    CGFloat arr[] = {3,1};\n    //下面最后一个参数“2”代表排列的个数。\n    CGContextSetLineDash(currentContext, 0, arr, 2);\n    CGContextDrawPath(currentContext, kCGPathStroke);\n    \n}\n```\n<!--more-->\n\n2、采用CAShapeLayer方式绘制虚线\n\n```\nCAShapeLayer *shapeLayer = [CAShapeLayer layer];\n[shapeLayer setBounds:self.bounds];\n[shapeLayer setPosition:CGPointMake(self.frame.size.width / 2.0, self.frame.size.height)];\n[shapeLayer setFillColor:[UIColor clearColor].CGColor];\n//设置虚线颜色\nshapeLayer setStrokeColor:[UIColor BlackColor].CGColor];\n//设置虚线宽度\n[shapeLayer setLineWidth:self.frame.size.height];\n[shapeLayer setLineJoin:kCALineJoinRound];\n//设置虚线的线宽及间距\n [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:3], [NSNumber numberWithInt:1], nil]];\n //创建虚线绘制路径\n CGMutablePathRef path = CGPathCreateMutable();\n //设置虚线绘制路径起点\n CGPathMoveToPoint(path, NULL, 0, 0);\n //设置虚线绘制路径终点\n CGPathAddLineToPoint(path, NULL, self.frame.size.width, 0);\n //设置虚线绘制路径\n [shapeLayer setPath:path];\n CGPathRelease(path);\n //添加虚线\n [self.layer addSublayer:shapeLayer];\n    \n```\n\n##### 关于这种方式已经有人整理出了一个非常好用的类方法，具体请参看文章末尾的参考博客地址：“iOS绘制虚线方法【原创】”一文，此方法使用起来非常简单方便。\n###### **<font color=\"red\">注意：下面非完整代码，如有需要，请自行前往该博文中直接复制使用。</font>**\n\n```\n/**\n ** lineView:       需要绘制成虚线的view\n ** lineLength:     虚线的宽度\n ** lineSpacing:    虚线的间距\n ** lineColor:      虚线的颜色\n **/\n \n+ (void)drawDashLine:(UIView *)lineView lineLength:(int)lineLength lineSpacing:(int)lineSpacing lineColor:(UIColor *)lineColor\n{\n    CAShapeLayer *shapeLayer = [CAShapeLayer layer];\n    .....\n    [shapeLayer setStrokeColor:lineColor.CGColor];\n    ......\n    [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:lineLength], [NSNumber numberWithInt:lineSpacing], nil]];\n\t　......\n    [lineView.layer addSublayer:shapeLayer];\n    \n}\n\n```\n\n3、经济实惠型：采用贴图的方式绘制虚线（需要设计师切图配合）\n\n```\nUIImageView *imgDashLineView =[[UIImageView alloc] initWithFrame:CGRectMake(15, 200, self.view.frame.size.width - 30, 1)];\n\n[imgDashLineView setBackgroundColor:[UIColor colorWithPatternImage:[UIImage imageNamed:@\"xuxian.png\"]]];\n\n[self.view addSubview:imgDashLineView];\n\n```\n在以上这几种方式中我个人比较偏爱最后一种，简单粗暴。\n\n以上内容部分来自于网络，本着分享的学习精神，如有涉及侵权问题，请及时告知。欢迎一起探讨学习，有问题请留言。我将会在第一时间对你的问题进行回复。如需转载，请注明出处。\n###### 参考博客地址：\n* 1、<a href=\"http://blog.it985.com/14080.html\">iOS绘制虚线方法【原创】</a>","source":"_posts/2015-10-12-ioshui-zhi-xu-xian-fang-shi-zong-jie.markdown","raw":"---\nlayout: post\ntitle: \"iOS绘制虚线方式总结\"\ndate: 2015-10-12 23:44:28 +0800\ncomments: true\ntags: [iOS, xcode, Objective-C]\nkeywords: ios开发, 绘制虚线\ncategories: Objective-C\n---\n### 一、iOS中绘制虚线常见的几种方式：\n\n1、重写drawRect方法。\n\n```\n- (void)drawRect:(CGRect)rect\n{\n    [super drawRect:rect];\nCGContextRef currentContext = UIGraphicsGetCurrentContext();\n//设置虚线颜色\n    CGContextSetStrokeColorWithColor(currentContext, [UIColor BlackColor].CGColor);\n    //设置虚线宽度\n    CGContextSetLineWidth(currentContext, 1);\n    //设置虚线绘制起点\n    CGContextMoveToPoint(currentContext, 0, 0);\n    //设置虚线绘制终点\n    CGContextAddLineToPoint(currentContext, self.frame.origin.x + self.frame.size.width, 0);\n    //设置虚线排列的宽度间隔:下面的arr中的数字表示先绘制3个点再绘制1个点\n    CGFloat arr[] = {3,1};\n    //下面最后一个参数“2”代表排列的个数。\n    CGContextSetLineDash(currentContext, 0, arr, 2);\n    CGContextDrawPath(currentContext, kCGPathStroke);\n    \n}\n```\n<!--more-->\n\n2、采用CAShapeLayer方式绘制虚线\n\n```\nCAShapeLayer *shapeLayer = [CAShapeLayer layer];\n[shapeLayer setBounds:self.bounds];\n[shapeLayer setPosition:CGPointMake(self.frame.size.width / 2.0, self.frame.size.height)];\n[shapeLayer setFillColor:[UIColor clearColor].CGColor];\n//设置虚线颜色\nshapeLayer setStrokeColor:[UIColor BlackColor].CGColor];\n//设置虚线宽度\n[shapeLayer setLineWidth:self.frame.size.height];\n[shapeLayer setLineJoin:kCALineJoinRound];\n//设置虚线的线宽及间距\n [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:3], [NSNumber numberWithInt:1], nil]];\n //创建虚线绘制路径\n CGMutablePathRef path = CGPathCreateMutable();\n //设置虚线绘制路径起点\n CGPathMoveToPoint(path, NULL, 0, 0);\n //设置虚线绘制路径终点\n CGPathAddLineToPoint(path, NULL, self.frame.size.width, 0);\n //设置虚线绘制路径\n [shapeLayer setPath:path];\n CGPathRelease(path);\n //添加虚线\n [self.layer addSublayer:shapeLayer];\n    \n```\n\n##### 关于这种方式已经有人整理出了一个非常好用的类方法，具体请参看文章末尾的参考博客地址：“iOS绘制虚线方法【原创】”一文，此方法使用起来非常简单方便。\n###### **<font color=\"red\">注意：下面非完整代码，如有需要，请自行前往该博文中直接复制使用。</font>**\n\n```\n/**\n ** lineView:       需要绘制成虚线的view\n ** lineLength:     虚线的宽度\n ** lineSpacing:    虚线的间距\n ** lineColor:      虚线的颜色\n **/\n \n+ (void)drawDashLine:(UIView *)lineView lineLength:(int)lineLength lineSpacing:(int)lineSpacing lineColor:(UIColor *)lineColor\n{\n    CAShapeLayer *shapeLayer = [CAShapeLayer layer];\n    .....\n    [shapeLayer setStrokeColor:lineColor.CGColor];\n    ......\n    [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:lineLength], [NSNumber numberWithInt:lineSpacing], nil]];\n\t　......\n    [lineView.layer addSublayer:shapeLayer];\n    \n}\n\n```\n\n3、经济实惠型：采用贴图的方式绘制虚线（需要设计师切图配合）\n\n```\nUIImageView *imgDashLineView =[[UIImageView alloc] initWithFrame:CGRectMake(15, 200, self.view.frame.size.width - 30, 1)];\n\n[imgDashLineView setBackgroundColor:[UIColor colorWithPatternImage:[UIImage imageNamed:@\"xuxian.png\"]]];\n\n[self.view addSubview:imgDashLineView];\n\n```\n在以上这几种方式中我个人比较偏爱最后一种，简单粗暴。\n\n以上内容部分来自于网络，本着分享的学习精神，如有涉及侵权问题，请及时告知。欢迎一起探讨学习，有问题请留言。我将会在第一时间对你的问题进行回复。如需转载，请注明出处。\n###### 参考博客地址：\n* 1、<a href=\"http://blog.it985.com/14080.html\">iOS绘制虚线方法【原创】</a>","slug":"ioshui-zhi-xu-xian-fang-shi-zong-jie","published":1,"updated":"2016-09-10T05:17:03.000Z","_id":"ciswie9cq000be3u2gz6jx9l9","photos":[],"link":"","content":"<h3 id=\"一、iOS中绘制虚线常见的几种方式：\"><a href=\"#一、iOS中绘制虚线常见的几种方式：\" class=\"headerlink\" title=\"一、iOS中绘制虚线常见的几种方式：\"></a>一、iOS中绘制虚线常见的几种方式：</h3><p>1、重写drawRect方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)drawRect:(CGRect)rect</div><div class=\"line\">&#123;</div><div class=\"line\">    [super drawRect:rect];</div><div class=\"line\">CGContextRef currentContext = UIGraphicsGetCurrentContext();</div><div class=\"line\">//设置虚线颜色</div><div class=\"line\">    CGContextSetStrokeColorWithColor(currentContext, [UIColor BlackColor].CGColor);</div><div class=\"line\">    //设置虚线宽度</div><div class=\"line\">    CGContextSetLineWidth(currentContext, 1);</div><div class=\"line\">    //设置虚线绘制起点</div><div class=\"line\">    CGContextMoveToPoint(currentContext, 0, 0);</div><div class=\"line\">    //设置虚线绘制终点</div><div class=\"line\">    CGContextAddLineToPoint(currentContext, self.frame.origin.x + self.frame.size.width, 0);</div><div class=\"line\">    //设置虚线排列的宽度间隔:下面的arr中的数字表示先绘制3个点再绘制1个点</div><div class=\"line\">    CGFloat arr[] = &#123;3,1&#125;;</div><div class=\"line\">    //下面最后一个参数“2”代表排列的个数。</div><div class=\"line\">    CGContextSetLineDash(currentContext, 0, arr, 2);</div><div class=\"line\">    CGContextDrawPath(currentContext, kCGPathStroke);</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>2、采用CAShapeLayer方式绘制虚线</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">CAShapeLayer *shapeLayer = [CAShapeLayer layer];</div><div class=\"line\">[shapeLayer setBounds:self.bounds];</div><div class=\"line\">[shapeLayer setPosition:CGPointMake(self.frame.size.width / 2.0, self.frame.size.height)];</div><div class=\"line\">[shapeLayer setFillColor:[UIColor clearColor].CGColor];</div><div class=\"line\">//设置虚线颜色</div><div class=\"line\">shapeLayer setStrokeColor:[UIColor BlackColor].CGColor];</div><div class=\"line\">//设置虚线宽度</div><div class=\"line\">[shapeLayer setLineWidth:self.frame.size.height];</div><div class=\"line\">[shapeLayer setLineJoin:kCALineJoinRound];</div><div class=\"line\">//设置虚线的线宽及间距</div><div class=\"line\"> [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:3], [NSNumber numberWithInt:1], nil]];</div><div class=\"line\"> //创建虚线绘制路径</div><div class=\"line\"> CGMutablePathRef path = CGPathCreateMutable();</div><div class=\"line\"> //设置虚线绘制路径起点</div><div class=\"line\"> CGPathMoveToPoint(path, NULL, 0, 0);</div><div class=\"line\"> //设置虚线绘制路径终点</div><div class=\"line\"> CGPathAddLineToPoint(path, NULL, self.frame.size.width, 0);</div><div class=\"line\"> //设置虚线绘制路径</div><div class=\"line\"> [shapeLayer setPath:path];</div><div class=\"line\"> CGPathRelease(path);</div><div class=\"line\"> //添加虚线</div><div class=\"line\"> [self.layer addSublayer:shapeLayer];</div></pre></td></tr></table></figure>\n<h5 id=\"关于这种方式已经有人整理出了一个非常好用的类方法，具体请参看文章末尾的参考博客地址：“iOS绘制虚线方法【原创】”一文，此方法使用起来非常简单方便。\"><a href=\"#关于这种方式已经有人整理出了一个非常好用的类方法，具体请参看文章末尾的参考博客地址：“iOS绘制虚线方法【原创】”一文，此方法使用起来非常简单方便。\" class=\"headerlink\" title=\"关于这种方式已经有人整理出了一个非常好用的类方法，具体请参看文章末尾的参考博客地址：“iOS绘制虚线方法【原创】”一文，此方法使用起来非常简单方便。\"></a>关于这种方式已经有人整理出了一个非常好用的类方法，具体请参看文章末尾的参考博客地址：“iOS绘制虚线方法【原创】”一文，此方法使用起来非常简单方便。</h5><h6 id=\"注意：下面非完整代码，如有需要，请自行前往该博文中直接复制使用。\"><a href=\"#注意：下面非完整代码，如有需要，请自行前往该博文中直接复制使用。\" class=\"headerlink\" title=\"注意：下面非完整代码，如有需要，请自行前往该博文中直接复制使用。\"></a><strong><font color=\"red\">注意：下面非完整代码，如有需要，请自行前往该博文中直接复制使用。</font></strong></h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> ** lineView:       需要绘制成虚线的view</div><div class=\"line\"> ** lineLength:     虚线的宽度</div><div class=\"line\"> ** lineSpacing:    虚线的间距</div><div class=\"line\"> ** lineColor:      虚线的颜色</div><div class=\"line\"> **/</div><div class=\"line\"> </div><div class=\"line\">+ (void)drawDashLine:(UIView *)lineView lineLength:(int)lineLength lineSpacing:(int)lineSpacing lineColor:(UIColor *)lineColor</div><div class=\"line\">&#123;</div><div class=\"line\">    CAShapeLayer *shapeLayer = [CAShapeLayer layer];</div><div class=\"line\">    .....</div><div class=\"line\">    [shapeLayer setStrokeColor:lineColor.CGColor];</div><div class=\"line\">    ......</div><div class=\"line\">    [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:lineLength], [NSNumber numberWithInt:lineSpacing], nil]];</div><div class=\"line\">\t　......</div><div class=\"line\">    [lineView.layer addSublayer:shapeLayer];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>3、经济实惠型：采用贴图的方式绘制虚线（需要设计师切图配合）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIImageView *imgDashLineView =[[UIImageView alloc] initWithFrame:CGRectMake(15, 200, self.view.frame.size.width - 30, 1)];</div><div class=\"line\"></div><div class=\"line\">[imgDashLineView setBackgroundColor:[UIColor colorWithPatternImage:[UIImage imageNamed:@&quot;xuxian.png&quot;]]];</div><div class=\"line\"></div><div class=\"line\">[self.view addSubview:imgDashLineView];</div></pre></td></tr></table></figure>\n<p>在以上这几种方式中我个人比较偏爱最后一种，简单粗暴。</p>\n<p>以上内容部分来自于网络，本着分享的学习精神，如有涉及侵权问题，请及时告知。欢迎一起探讨学习，有问题请留言。我将会在第一时间对你的问题进行回复。如需转载，请注明出处。</p>\n<h6 id=\"参考博客地址：\"><a href=\"#参考博客地址：\" class=\"headerlink\" title=\"参考博客地址：\"></a>参考博客地址：</h6><ul>\n<li>1、<a href=\"http://blog.it985.com/14080.html\" target=\"_blank\" rel=\"external\">iOS绘制虚线方法【原创】</a></li>\n</ul>\n","excerpt":"<h3 id=\"一、iOS中绘制虚线常见的几种方式：\"><a href=\"#一、iOS中绘制虚线常见的几种方式：\" class=\"headerlink\" title=\"一、iOS中绘制虚线常见的几种方式：\"></a>一、iOS中绘制虚线常见的几种方式：</h3><p>1、重写drawRect方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)drawRect:(CGRect)rect</div><div class=\"line\">&#123;</div><div class=\"line\">    [super drawRect:rect];</div><div class=\"line\">CGContextRef currentContext = UIGraphicsGetCurrentContext();</div><div class=\"line\">//设置虚线颜色</div><div class=\"line\">    CGContextSetStrokeColorWithColor(currentContext, [UIColor BlackColor].CGColor);</div><div class=\"line\">    //设置虚线宽度</div><div class=\"line\">    CGContextSetLineWidth(currentContext, 1);</div><div class=\"line\">    //设置虚线绘制起点</div><div class=\"line\">    CGContextMoveToPoint(currentContext, 0, 0);</div><div class=\"line\">    //设置虚线绘制终点</div><div class=\"line\">    CGContextAddLineToPoint(currentContext, self.frame.origin.x + self.frame.size.width, 0);</div><div class=\"line\">    //设置虚线排列的宽度间隔:下面的arr中的数字表示先绘制3个点再绘制1个点</div><div class=\"line\">    CGFloat arr[] = &#123;3,1&#125;;</div><div class=\"line\">    //下面最后一个参数“2”代表排列的个数。</div><div class=\"line\">    CGContextSetLineDash(currentContext, 0, arr, 2);</div><div class=\"line\">    CGContextDrawPath(currentContext, kCGPathStroke);</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>2、采用CAShapeLayer方式绘制虚线</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">CAShapeLayer *shapeLayer = [CAShapeLayer layer];</div><div class=\"line\">[shapeLayer setBounds:self.bounds];</div><div class=\"line\">[shapeLayer setPosition:CGPointMake(self.frame.size.width / 2.0, self.frame.size.height)];</div><div class=\"line\">[shapeLayer setFillColor:[UIColor clearColor].CGColor];</div><div class=\"line\">//设置虚线颜色</div><div class=\"line\">shapeLayer setStrokeColor:[UIColor BlackColor].CGColor];</div><div class=\"line\">//设置虚线宽度</div><div class=\"line\">[shapeLayer setLineWidth:self.frame.size.height];</div><div class=\"line\">[shapeLayer setLineJoin:kCALineJoinRound];</div><div class=\"line\">//设置虚线的线宽及间距</div><div class=\"line\"> [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:3], [NSNumber numberWithInt:1], nil]];</div><div class=\"line\"> //创建虚线绘制路径</div><div class=\"line\"> CGMutablePathRef path = CGPathCreateMutable();</div><div class=\"line\"> //设置虚线绘制路径起点</div><div class=\"line\"> CGPathMoveToPoint(path, NULL, 0, 0);</div><div class=\"line\"> //设置虚线绘制路径终点</div><div class=\"line\"> CGPathAddLineToPoint(path, NULL, self.frame.size.width, 0);</div><div class=\"line\"> //设置虚线绘制路径</div><div class=\"line\"> [shapeLayer setPath:path];</div><div class=\"line\"> CGPathRelease(path);</div><div class=\"line\"> //添加虚线</div><div class=\"line\"> [self.layer addSublayer:shapeLayer];</div></pre></td></tr></table></figure>\n<h5 id=\"关于这种方式已经有人整理出了一个非常好用的类方法，具体请参看文章末尾的参考博客地址：“iOS绘制虚线方法【原创】”一文，此方法使用起来非常简单方便。\"><a href=\"#关于这种方式已经有人整理出了一个非常好用的类方法，具体请参看文章末尾的参考博客地址：“iOS绘制虚线方法【原创】”一文，此方法使用起来非常简单方便。\" class=\"headerlink\" title=\"关于这种方式已经有人整理出了一个非常好用的类方法，具体请参看文章末尾的参考博客地址：“iOS绘制虚线方法【原创】”一文，此方法使用起来非常简单方便。\"></a>关于这种方式已经有人整理出了一个非常好用的类方法，具体请参看文章末尾的参考博客地址：“iOS绘制虚线方法【原创】”一文，此方法使用起来非常简单方便。</h5><h6 id=\"注意：下面非完整代码，如有需要，请自行前往该博文中直接复制使用。\"><a href=\"#注意：下面非完整代码，如有需要，请自行前往该博文中直接复制使用。\" class=\"headerlink\" title=\"注意：下面非完整代码，如有需要，请自行前往该博文中直接复制使用。\"></a><strong><font color=\"red\">注意：下面非完整代码，如有需要，请自行前往该博文中直接复制使用。</font></strong></h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> ** lineView:       需要绘制成虚线的view</div><div class=\"line\"> ** lineLength:     虚线的宽度</div><div class=\"line\"> ** lineSpacing:    虚线的间距</div><div class=\"line\"> ** lineColor:      虚线的颜色</div><div class=\"line\"> **/</div><div class=\"line\"> </div><div class=\"line\">+ (void)drawDashLine:(UIView *)lineView lineLength:(int)lineLength lineSpacing:(int)lineSpacing lineColor:(UIColor *)lineColor</div><div class=\"line\">&#123;</div><div class=\"line\">    CAShapeLayer *shapeLayer = [CAShapeLayer layer];</div><div class=\"line\">    .....</div><div class=\"line\">    [shapeLayer setStrokeColor:lineColor.CGColor];</div><div class=\"line\">    ......</div><div class=\"line\">    [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:lineLength], [NSNumber numberWithInt:lineSpacing], nil]];</div><div class=\"line\">\t　......</div><div class=\"line\">    [lineView.layer addSublayer:shapeLayer];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>3、经济实惠型：采用贴图的方式绘制虚线（需要设计师切图配合）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIImageView *imgDashLineView =[[UIImageView alloc] initWithFrame:CGRectMake(15, 200, self.view.frame.size.width - 30, 1)];</div><div class=\"line\"></div><div class=\"line\">[imgDashLineView setBackgroundColor:[UIColor colorWithPatternImage:[UIImage imageNamed:@&quot;xuxian.png&quot;]]];</div><div class=\"line\"></div><div class=\"line\">[self.view addSubview:imgDashLineView];</div></pre></td></tr></table></figure>\n<p>在以上这几种方式中我个人比较偏爱最后一种，简单粗暴。</p>\n<p>以上内容部分来自于网络，本着分享的学习精神，如有涉及侵权问题，请及时告知。欢迎一起探讨学习，有问题请留言。我将会在第一时间对你的问题进行回复。如需转载，请注明出处。</p>\n<h6 id=\"参考博客地址：\"><a href=\"#参考博客地址：\" class=\"headerlink\" title=\"参考博客地址：\"></a>参考博客地址：</h6><ul>\n<li>1、<a href=\"http://blog.it985.com/14080.html\">iOS绘制虚线方法【原创】</a></li>\n</ul>"},{"layout":"post","title":"Swift中UITableView的用法(自定义UITableView和UITableViewCell)","date":"2016-01-04T13:23:33.000Z","comments":1,"keywords":"Swift, UITableView, UITableViewCell","_content":"一、自定义表视图（UITableView）\n<!--more-->\n```\n\nimport UIKit\nclass HomeTableView: UITableView, UITableViewDataSource, UITableViewDelegate {\n//表视图的数据源：dataList\n    var dataList = [AnyObject]()\n//单元格的标识符：homeCellId\n    let identify = \"homeCellId\"\n    //重写表视图初始化方法\n    override init(frame: CGRect, style: UITableViewStyle) {\n        super.init(frame:frame, style:style)\n        //调用初始化子视图方法\n        initSubviews()\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n    //初始化表视图的子视图方法\n    func initSubviews () {\n    //设置数据源代理\n        dataSource = self;\n   //设置表视图代理\n        delegate = self;\n        //注册单元格class方式\n        registerClass(HomeCell.self, forCellReuseIdentifier: identify)\n       //设置表视图的分割线显示风格\n        separatorStyle = .None;\n        //注册单元格xib方式\n        //registerNib(UINib(nibName: \"HomeCell\", bundle: nil), forCellReuseIdentifier:identify)\n    }\n   //实现表视图返回组数代理方法：不实现默认为1\n    func numberOfSectionsInTableView(tableView: UITableView) -> Int {\n        return 1;\n    }\n//实现表视图返回行数代理方法\n    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return dataList.count;\n    }\n    //实现表视图返回单元格代理方法\n    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {\n    //取单元格\n        let cell = tableView.dequeueReusableCellWithIdentifier(identify) as! HomeCell\n        //设置单元格的选中风格\n        cell.selectionStyle = .None;\n        cell.titleStr = dataList[indexPath.row] as? String\n        return cell\n    }\n    //选中单元格的代理方法\n    func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {\n        print(\"the indexpath row is \\(indexPath.row)\")\n    }\n    //返回单元格高度的代理方法\n    func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat {\n        return 80;\n    }\n}\n```\n\n二、自定义单元格（UITableViewCell）\n\n```\nimport UIKit\n\nclass HomeCell: UITableViewCell {\n//定义子视图变量\n    var imgView: UIImageView!\n    var titleLabel: UILabel!\n    var button: UIButton!\n    var titleStr: String?\n    // 重写单元格初始化方法\n    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier);\n        //调用单元格初始化方法\n        initSubviews()\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:)has not been implemented\")\n    }\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n        // Initialization code\n    }\n    //单元格子视图初始化方法\n    func initSubviews () {\n        imgView = UIImageView(frame: CGRectMake(0, 0, 30, 30))\n        imgView.image = UIImage(named: \"exam.png\")\n        contentView.addSubview(imgView);\n        \n        titleLabel = UILabel(frame: CGRectMake(0, 0, frame.size.width, frame.size.height))\n        titleLabel.textAlignment = .Left;\n        titleLabel.textColor = UIColor.lightGrayColor();\n        titleLabel.font = UIFont.systemFontOfSize(15);\n        titleLabel.text = \"心灵鸡汤，每天一起干\"\n        contentView.addSubview(titleLabel)\n        \n        button = UIButton(type: .Custom)\n        button.frame = CGRectMake(0, 0, frame.size.width, frame.size.height)\n        button.setTitle(\"关注\", forState: .Normal)\n        button.setTitleColor(UIColor.whiteColor(), forState: .Normal)\n        button.backgroundColor = UIColor.grayColor()\n        contentView.addSubview(button)\n    }\n    //重写单元格布局子视图方法\n    override func layoutSubviews() {\n        super.layoutSubviews()\n        titleLabel.text = titleStr\n      //...\n      //布局单元格子视图\n      //...\n    override func setSelected(selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n        // Configure the view for the selected state\n    }\n}\n```","source":"_posts/2016-01-04-swiftzhong-uitableviewde-yong-fa-zi-ding-yi-uitableviewhe-uitableviewcell.markdown","raw":"---\nlayout: post\ntitle: \"Swift中UITableView的用法(自定义UITableView和UITableViewCell)\"\ndate: 2016-01-04 21:23:33 +0800\ncomments: true\ntags: [iOS, Xcode, Swift, UITableView, UITableViewCell]\nkeywords: Swift, UITableView, UITableViewCell\ncategories: Swift\n---\n一、自定义表视图（UITableView）\n<!--more-->\n```\n\nimport UIKit\nclass HomeTableView: UITableView, UITableViewDataSource, UITableViewDelegate {\n//表视图的数据源：dataList\n    var dataList = [AnyObject]()\n//单元格的标识符：homeCellId\n    let identify = \"homeCellId\"\n    //重写表视图初始化方法\n    override init(frame: CGRect, style: UITableViewStyle) {\n        super.init(frame:frame, style:style)\n        //调用初始化子视图方法\n        initSubviews()\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n    //初始化表视图的子视图方法\n    func initSubviews () {\n    //设置数据源代理\n        dataSource = self;\n   //设置表视图代理\n        delegate = self;\n        //注册单元格class方式\n        registerClass(HomeCell.self, forCellReuseIdentifier: identify)\n       //设置表视图的分割线显示风格\n        separatorStyle = .None;\n        //注册单元格xib方式\n        //registerNib(UINib(nibName: \"HomeCell\", bundle: nil), forCellReuseIdentifier:identify)\n    }\n   //实现表视图返回组数代理方法：不实现默认为1\n    func numberOfSectionsInTableView(tableView: UITableView) -> Int {\n        return 1;\n    }\n//实现表视图返回行数代理方法\n    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return dataList.count;\n    }\n    //实现表视图返回单元格代理方法\n    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {\n    //取单元格\n        let cell = tableView.dequeueReusableCellWithIdentifier(identify) as! HomeCell\n        //设置单元格的选中风格\n        cell.selectionStyle = .None;\n        cell.titleStr = dataList[indexPath.row] as? String\n        return cell\n    }\n    //选中单元格的代理方法\n    func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {\n        print(\"the indexpath row is \\(indexPath.row)\")\n    }\n    //返回单元格高度的代理方法\n    func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -> CGFloat {\n        return 80;\n    }\n}\n```\n\n二、自定义单元格（UITableViewCell）\n\n```\nimport UIKit\n\nclass HomeCell: UITableViewCell {\n//定义子视图变量\n    var imgView: UIImageView!\n    var titleLabel: UILabel!\n    var button: UIButton!\n    var titleStr: String?\n    // 重写单元格初始化方法\n    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {\n        super.init(style: style, reuseIdentifier: reuseIdentifier);\n        //调用单元格初始化方法\n        initSubviews()\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:)has not been implemented\")\n    }\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n        // Initialization code\n    }\n    //单元格子视图初始化方法\n    func initSubviews () {\n        imgView = UIImageView(frame: CGRectMake(0, 0, 30, 30))\n        imgView.image = UIImage(named: \"exam.png\")\n        contentView.addSubview(imgView);\n        \n        titleLabel = UILabel(frame: CGRectMake(0, 0, frame.size.width, frame.size.height))\n        titleLabel.textAlignment = .Left;\n        titleLabel.textColor = UIColor.lightGrayColor();\n        titleLabel.font = UIFont.systemFontOfSize(15);\n        titleLabel.text = \"心灵鸡汤，每天一起干\"\n        contentView.addSubview(titleLabel)\n        \n        button = UIButton(type: .Custom)\n        button.frame = CGRectMake(0, 0, frame.size.width, frame.size.height)\n        button.setTitle(\"关注\", forState: .Normal)\n        button.setTitleColor(UIColor.whiteColor(), forState: .Normal)\n        button.backgroundColor = UIColor.grayColor()\n        contentView.addSubview(button)\n    }\n    //重写单元格布局子视图方法\n    override func layoutSubviews() {\n        super.layoutSubviews()\n        titleLabel.text = titleStr\n      //...\n      //布局单元格子视图\n      //...\n    override func setSelected(selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n        // Configure the view for the selected state\n    }\n}\n```","slug":"swiftzhong-uitableviewde-yong-fa-zi-ding-yi-uitableviewhe-uitableviewcell","published":1,"updated":"2016-09-10T05:17:43.000Z","_id":"ciswie9cy000ee3u2w8lf47sv","photos":[],"link":"","content":"<p>一、自定义表视图（UITableView）<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">import UIKit</div><div class=\"line\">class HomeTableView: UITableView, UITableViewDataSource, UITableViewDelegate &#123;</div><div class=\"line\">//表视图的数据源：dataList</div><div class=\"line\">    var dataList = [AnyObject]()</div><div class=\"line\">//单元格的标识符：homeCellId</div><div class=\"line\">    let identify = &quot;homeCellId&quot;</div><div class=\"line\">    //重写表视图初始化方法</div><div class=\"line\">    override init(frame: CGRect, style: UITableViewStyle) &#123;</div><div class=\"line\">        super.init(frame:frame, style:style)</div><div class=\"line\">        //调用初始化子视图方法</div><div class=\"line\">        initSubviews()</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    required init?(coder aDecoder: NSCoder) &#123;</div><div class=\"line\">        fatalError(&quot;init(coder:) has not been implemented&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    //初始化表视图的子视图方法</div><div class=\"line\">    func initSubviews () &#123;</div><div class=\"line\">    //设置数据源代理</div><div class=\"line\">        dataSource = self;</div><div class=\"line\">   //设置表视图代理</div><div class=\"line\">        delegate = self;</div><div class=\"line\">        //注册单元格class方式</div><div class=\"line\">        registerClass(HomeCell.self, forCellReuseIdentifier: identify)</div><div class=\"line\">       //设置表视图的分割线显示风格</div><div class=\"line\">        separatorStyle = .None;</div><div class=\"line\">        //注册单元格xib方式</div><div class=\"line\">        //registerNib(UINib(nibName: &quot;HomeCell&quot;, bundle: nil), forCellReuseIdentifier:identify)</div><div class=\"line\">    &#125;</div><div class=\"line\">   //实现表视图返回组数代理方法：不实现默认为1</div><div class=\"line\">    func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123;</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">//实现表视图返回行数代理方法</div><div class=\"line\">    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</div><div class=\"line\">        return dataList.count;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //实现表视图返回单元格代理方法</div><div class=\"line\">    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</div><div class=\"line\">    //取单元格</div><div class=\"line\">        let cell = tableView.dequeueReusableCellWithIdentifier(identify) as! HomeCell</div><div class=\"line\">        //设置单元格的选中风格</div><div class=\"line\">        cell.selectionStyle = .None;</div><div class=\"line\">        cell.titleStr = dataList[indexPath.row] as? String</div><div class=\"line\">        return cell</div><div class=\"line\">    &#125;</div><div class=\"line\">    //选中单元格的代理方法</div><div class=\"line\">    func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) &#123;</div><div class=\"line\">        print(&quot;the indexpath row is \\(indexPath.row)&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    //返回单元格高度的代理方法</div><div class=\"line\">    func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat &#123;</div><div class=\"line\">        return 80;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>二、自定义单元格（UITableViewCell）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">import UIKit</div><div class=\"line\"></div><div class=\"line\">class HomeCell: UITableViewCell &#123;</div><div class=\"line\">//定义子视图变量</div><div class=\"line\">    var imgView: UIImageView!</div><div class=\"line\">    var titleLabel: UILabel!</div><div class=\"line\">    var button: UIButton!</div><div class=\"line\">    var titleStr: String?</div><div class=\"line\">    // 重写单元格初始化方法</div><div class=\"line\">    override init(style: UITableViewCellStyle, reuseIdentifier: String?) &#123;</div><div class=\"line\">        super.init(style: style, reuseIdentifier: reuseIdentifier);</div><div class=\"line\">        //调用单元格初始化方法</div><div class=\"line\">        initSubviews()</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    required init?(coder aDecoder: NSCoder) &#123;</div><div class=\"line\">        fatalError(&quot;init(coder:)has not been implemented&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    override func awakeFromNib() &#123;</div><div class=\"line\">        super.awakeFromNib()</div><div class=\"line\">        // Initialization code</div><div class=\"line\">    &#125;</div><div class=\"line\">    //单元格子视图初始化方法</div><div class=\"line\">    func initSubviews () &#123;</div><div class=\"line\">        imgView = UIImageView(frame: CGRectMake(0, 0, 30, 30))</div><div class=\"line\">        imgView.image = UIImage(named: &quot;exam.png&quot;)</div><div class=\"line\">        contentView.addSubview(imgView);</div><div class=\"line\">        </div><div class=\"line\">        titleLabel = UILabel(frame: CGRectMake(0, 0, frame.size.width, frame.size.height))</div><div class=\"line\">        titleLabel.textAlignment = .Left;</div><div class=\"line\">        titleLabel.textColor = UIColor.lightGrayColor();</div><div class=\"line\">        titleLabel.font = UIFont.systemFontOfSize(15);</div><div class=\"line\">        titleLabel.text = &quot;心灵鸡汤，每天一起干&quot;</div><div class=\"line\">        contentView.addSubview(titleLabel)</div><div class=\"line\">        </div><div class=\"line\">        button = UIButton(type: .Custom)</div><div class=\"line\">        button.frame = CGRectMake(0, 0, frame.size.width, frame.size.height)</div><div class=\"line\">        button.setTitle(&quot;关注&quot;, forState: .Normal)</div><div class=\"line\">        button.setTitleColor(UIColor.whiteColor(), forState: .Normal)</div><div class=\"line\">        button.backgroundColor = UIColor.grayColor()</div><div class=\"line\">        contentView.addSubview(button)</div><div class=\"line\">    &#125;</div><div class=\"line\">    //重写单元格布局子视图方法</div><div class=\"line\">    override func layoutSubviews() &#123;</div><div class=\"line\">        super.layoutSubviews()</div><div class=\"line\">        titleLabel.text = titleStr</div><div class=\"line\">      //...</div><div class=\"line\">      //布局单元格子视图</div><div class=\"line\">      //...</div><div class=\"line\">    override func setSelected(selected: Bool, animated: Bool) &#123;</div><div class=\"line\">        super.setSelected(selected, animated: animated)</div><div class=\"line\">        // Configure the view for the selected state</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"<p>一、自定义表视图（UITableView）<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">import UIKit</div><div class=\"line\">class HomeTableView: UITableView, UITableViewDataSource, UITableViewDelegate &#123;</div><div class=\"line\">//表视图的数据源：dataList</div><div class=\"line\">    var dataList = [AnyObject]()</div><div class=\"line\">//单元格的标识符：homeCellId</div><div class=\"line\">    let identify = &quot;homeCellId&quot;</div><div class=\"line\">    //重写表视图初始化方法</div><div class=\"line\">    override init(frame: CGRect, style: UITableViewStyle) &#123;</div><div class=\"line\">        super.init(frame:frame, style:style)</div><div class=\"line\">        //调用初始化子视图方法</div><div class=\"line\">        initSubviews()</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    required init?(coder aDecoder: NSCoder) &#123;</div><div class=\"line\">        fatalError(&quot;init(coder:) has not been implemented&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    //初始化表视图的子视图方法</div><div class=\"line\">    func initSubviews () &#123;</div><div class=\"line\">    //设置数据源代理</div><div class=\"line\">        dataSource = self;</div><div class=\"line\">   //设置表视图代理</div><div class=\"line\">        delegate = self;</div><div class=\"line\">        //注册单元格class方式</div><div class=\"line\">        registerClass(HomeCell.self, forCellReuseIdentifier: identify)</div><div class=\"line\">       //设置表视图的分割线显示风格</div><div class=\"line\">        separatorStyle = .None;</div><div class=\"line\">        //注册单元格xib方式</div><div class=\"line\">        //registerNib(UINib(nibName: &quot;HomeCell&quot;, bundle: nil), forCellReuseIdentifier:identify)</div><div class=\"line\">    &#125;</div><div class=\"line\">   //实现表视图返回组数代理方法：不实现默认为1</div><div class=\"line\">    func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123;</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">//实现表视图返回行数代理方法</div><div class=\"line\">    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</div><div class=\"line\">        return dataList.count;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //实现表视图返回单元格代理方法</div><div class=\"line\">    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</div><div class=\"line\">    //取单元格</div><div class=\"line\">        let cell = tableView.dequeueReusableCellWithIdentifier(identify) as! HomeCell</div><div class=\"line\">        //设置单元格的选中风格</div><div class=\"line\">        cell.selectionStyle = .None;</div><div class=\"line\">        cell.titleStr = dataList[indexPath.row] as? String</div><div class=\"line\">        return cell</div><div class=\"line\">    &#125;</div><div class=\"line\">    //选中单元格的代理方法</div><div class=\"line\">    func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) &#123;</div><div class=\"line\">        print(&quot;the indexpath row is \\(indexPath.row)&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    //返回单元格高度的代理方法</div><div class=\"line\">    func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat &#123;</div><div class=\"line\">        return 80;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>二、自定义单元格（UITableViewCell）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">import UIKit</div><div class=\"line\"></div><div class=\"line\">class HomeCell: UITableViewCell &#123;</div><div class=\"line\">//定义子视图变量</div><div class=\"line\">    var imgView: UIImageView!</div><div class=\"line\">    var titleLabel: UILabel!</div><div class=\"line\">    var button: UIButton!</div><div class=\"line\">    var titleStr: String?</div><div class=\"line\">    // 重写单元格初始化方法</div><div class=\"line\">    override init(style: UITableViewCellStyle, reuseIdentifier: String?) &#123;</div><div class=\"line\">        super.init(style: style, reuseIdentifier: reuseIdentifier);</div><div class=\"line\">        //调用单元格初始化方法</div><div class=\"line\">        initSubviews()</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    required init?(coder aDecoder: NSCoder) &#123;</div><div class=\"line\">        fatalError(&quot;init(coder:)has not been implemented&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    override func awakeFromNib() &#123;</div><div class=\"line\">        super.awakeFromNib()</div><div class=\"line\">        // Initialization code</div><div class=\"line\">    &#125;</div><div class=\"line\">    //单元格子视图初始化方法</div><div class=\"line\">    func initSubviews () &#123;</div><div class=\"line\">        imgView = UIImageView(frame: CGRectMake(0, 0, 30, 30))</div><div class=\"line\">        imgView.image = UIImage(named: &quot;exam.png&quot;)</div><div class=\"line\">        contentView.addSubview(imgView);</div><div class=\"line\">        </div><div class=\"line\">        titleLabel = UILabel(frame: CGRectMake(0, 0, frame.size.width, frame.size.height))</div><div class=\"line\">        titleLabel.textAlignment = .Left;</div><div class=\"line\">        titleLabel.textColor = UIColor.lightGrayColor();</div><div class=\"line\">        titleLabel.font = UIFont.systemFontOfSize(15);</div><div class=\"line\">        titleLabel.text = &quot;心灵鸡汤，每天一起干&quot;</div><div class=\"line\">        contentView.addSubview(titleLabel)</div><div class=\"line\">        </div><div class=\"line\">        button = UIButton(type: .Custom)</div><div class=\"line\">        button.frame = CGRectMake(0, 0, frame.size.width, frame.size.height)</div><div class=\"line\">        button.setTitle(&quot;关注&quot;, forState: .Normal)</div><div class=\"line\">        button.setTitleColor(UIColor.whiteColor(), forState: .Normal)</div><div class=\"line\">        button.backgroundColor = UIColor.grayColor()</div><div class=\"line\">        contentView.addSubview(button)</div><div class=\"line\">    &#125;</div><div class=\"line\">    //重写单元格布局子视图方法</div><div class=\"line\">    override func layoutSubviews() &#123;</div><div class=\"line\">        super.layoutSubviews()</div><div class=\"line\">        titleLabel.text = titleStr</div><div class=\"line\">      //...</div><div class=\"line\">      //布局单元格子视图</div><div class=\"line\">      //...</div><div class=\"line\">    override func setSelected(selected: Bool, animated: Bool) &#123;</div><div class=\"line\">        super.setSelected(selected, animated: animated)</div><div class=\"line\">        // Configure the view for the selected state</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"layout":"post","title":"Swift内存管理（ARC）之循环引用","date":"2016-01-14T17:37:31.000Z","comments":1,"keywords":"Swift, ARC, 循环引用, 内存管理","_content":"Swift中是采用自动引用计数(ARC，AutomaticReferenceCounting)机制来对内存进行管理的。\n\n#### 一、简述ARC如何工作：\n每当你每创建一个新的对象，它便会分配一块内存来存储该对象的相关信息。当你不再需要这个对象的时候，它就会自动释放这个对象，避免它再占用内存空间。当然，如果该对象只要至少存在一个引用就不会被释放。另外，你如果访问了一个已经被释放的对象，则很有可能会出现崩溃（野指针）。\n拿《The Swift Programming Language》里面的例子来套一下：\n\n```\n//创建一个Cat类，自带常量name属性\nclass Cat {\n    let name: String\n    init(name: String) {\n    //初始化name属性\n        self.name = name;\n        print(\"\\(name) 对象已经被初始化\")\n    }\n    \n    deinit {\n        print(\"\\(name) 对象释放成功！\")\n    }\n}\n\n```\n<!--more-->\n接下来定义三个变量类型为:Cat?用来对一个新的Cat对象建立多个引用。因为变量是一个可选类型（是Cat?而不是Cat）， 他们会自动给变量初始化为nil，所有当前它不需要引用一个Cat对象。\n\n```\nvar cat1: Cat?\nvar cat2: Cat?\nvar cat3: Cat?\n```\n\n创建一个新的Cat对象，并对之前定义的三个变量进行赋值操作：\n\n```\ncat1 = Cat(name: \"jack\")\n//输出：jack 对象已经被初始化\n\n```\n当你调用Cat类构造器，它会输出：\"jack 对象已经被初始化\"。这就代表已经完成了对象初始化操作。接下来，一个新的Cat对象被赋值给了 cat1变量，从而建立了cat1对新Cat实例对象的强引用。因此，它存在了至少一个强引用。这个新的Cat对象就不会被释放。\n如果你把同一个Cat实例对象赋值给另外两个变量，它则又多建立了两个强引用。\n\n```\n//通过赋值对Cat实例对象建立强引用\ncat2 = cat1\ncat3 = cat1\n```\n\n此时这个Cat实例对象已经有三个强引用了。\n如果你用把其中两个变量赋值为nil的方式来打破这些强引用，对象是不会被释放的。因为它还存在一个强引用。\n\n```\n//通过把置nil来打破cat1,cat2对Cat实例对象的强引用\ncat1 = nil\ncat2 = nil\n```\n只有直到对象所有的引用被打破，ARC才会释放该对象\n\n```\n//打破最后一个强引用\ncat3 = nil\n//输出：jack 对象释放成功！\n```\n当最后一个强引用被打破后，这个Cat对象被成功释放，输出：jack 对象释放成功！\n\n#### 二、循环引用\n\n1、什么是循环引用？\n简单的来说就是两个对象互相持有对方，使对方处于活跃状态不被释放，从而导致了循环引用。套个例子：\n\n```\n//创建一个Cat类，拥有一个String类型的name属性与一个可选类型的dog属性。\nclass Cat {\n    let name: String\n    init(name: String) {\n        self.name = name;\n        print(\"\\(name) 对象已经被初始化\")\n    }\n    var dog: Dog?\n    \n    deinit {\n        print(\"\\(name) 对象释放成功！\")\n    }\n}\n\n//创建一个Dog类，拥有一个String类型的type属性与一个可选类型的jack属性。\nclass Dog {\n    let type: String\n    init(type: String) {\n        self.type = type\n        print(\"\\(type) 对象已经被初始化\")\n    }\n    \n    var cat: Cat?\n    deinit {\n        print(\"\\(type) 对象释放成功\")\n    }\n}\n```\n定义两个变量并初始化\n\n```\nvar jack: Cat?\nvar tom: Dog?\n\njack = Cat(name: \"jack\")\n//print:jack 对象已经被初始化\ntom = Dog(type: \"red\")\n//print:red 对象已经被初始化\n```\n建立强引用\n\n```\njack!.dog = tom\ntom!.cat = jack\n```\n通过把对象置nil打破强引用\n\n```\njack = nil\ntom = nil\n```\n这个地方Cat对象和Dog对象都不会被释放，因为他们两个之间还存在强引用。\n\n* 解决循环引用办法\n\tSwift提供了两种方法来解决循环引用问题：\n\t\n\t（1）弱引用（weak）\n\t\n\t（2）无主引用（unowned）\n\t\n声明变量或属性时，在前面加上\"weak\"关键词表示它是一个弱引用。如果确定访问属性或函数的时候该对象不会被释放，也可以用无主引用（unowned）来取代。unowned跟Objective-C中的unsafe_unretained类似。它与weak的区别在于weak在引用的对象被释放后，会自动置nil。所以它必须声明成可选类型（？）。而unowned在引用对象被释放后不会自动置nil(因为非可选类型的变量不能被设置成nil)，而是保留对原有对象的无效引用，一旦对象被释放，再访问该对象的属性或函数就会造成崩溃。官方建议是当你在可以确定访问属性或函数所属对象不会被释放时，使用unowned。否则，还是使用weak吧！\n\n解决上面代码的循环引用问题，可做如下修改：\n\n```\nclass Dog {\n    let type: String\n    init(type: String) {\n        self.type = type\n        print(\"\\(type) 对象已经被初始化\")\n    }\n    \n    weak var jack: Cat\n    deinit {\n        print(\"\\(type) 对象释放成功\")\n    }\n}\n\n```\n\n```\njack = nil\ntom = nil\n```\n\n2、常见的循环引用问题：\n\n（1）delegate\n在项目中我们经常会用到代理模式，在Objective-C中我们一般在delegate前面加上weak关键词，表示它是一个弱引用。从而达到打破循环引用的效果。\n\n```\n//在前面加上@objc是指定这里的代码属于Objective-C的代码，因为Swift中协议可以用于class、struct、enum。对于基本数据类型，它不是对象，没有引用计数这个概念，因此无法使用weak关键词。  Objective-C中的协议只适用于类，所以这里需要加上@objc。\n@objc protocol AClassDelegate {\n    func wash()\n}\n\nclass A {\n    weak var delegate: AClassDelegate!\n    func cry() {\n        \n    }\n    func play() {\n        delegate.wash()\n    }\n}\n\nclass B: AClassDelegate {\n    \n    func feed() {\n        let nurse = A()\n        nurse.delegate = self\n        nurse.cry()\n    }\n    \n    @objc func wash() {\n        print(\"begin wash and sleep\")\n    }\n}\n```\n\n（2）Block(闭包)中的循环引用\nBlock(闭包)的循环引用在于它会持有所有引用的元素。比如我们在Block(闭包)中访问了self，那么它就持有了self。这样一来就形成了一个环：self持有Block(闭包)，Block(闭包)持有self。下面我们举个栗子加以说明：类A中有个闭包，我们在闭包中访问了self的name属性。\n\n```\nclass A {\n    let name: String\n    lazy var wash: Void ->Void = {\n        var name = self.name + \" nurse\"\n        print(\"wash room is \\(name)\")\n    }\n    \n    init(name: String) {\n        self.name = name\n        print(\"\\(self.name) 创建了\")\n    }\n    \n    deinit {\n        print(\"\\(self.name) 释放了\")\n    }\n}\n\nclass B {\n    func play() {\n        var nurse: A?\n        nurse = A(name: \"jack\")\n        nurse?.wash()\n    }\n}\n\nvar baby: B?\nbaby = B()\nbaby?.play()\n\n输出结果：\njack 创建了\nwash room is jack nurse\n```\n\n 因为wash是self的一个属性，所以wash被self持有。这个时候我们又在闭包中访问了self的name属性，所以它又在闭包中持有了self。这样便导致了循环引用。为了解决闭包中的循环引用问题，Swift中提供了一个叫”闭包捕获列表”的解决方案。\n \n * 定义一个捕获列表\n \n 捕获列表中的每一项都是一个用weak或 unowned关键字与一个实例对象的引用（如self）或者是一个用初始化值的变量（如delegate = self.delegate!）搭配成对，配对之间用逗号隔开，最后用方括号括起来。如下所示：\n \n ```\n \n  lazy var someClosure:(Int, String) -> String = {\n        [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -> String in\n        \n    }\n    \n ```\n \n 如果闭包中没有指定参数列表或者返回类型，可直接把捕获列表放置在闭包开始的地方（花括号后面）然后紧跟着是\"in\"关键词，示例代码如下：\n \n  ```\n  lazy var someClosure:Void -> String = {\n        [unowned self, weak delegate = self.delegate!]  in\n        \n    }\n ```\n \n \n * 解决Block(闭包)中的循环引用，ClassA中的Block(闭包)代码可做以下修改：\n\n```\nlazy var wash:Void ->Void = { [weak self] in\n//这个地方使用self!.name而不是self.name。是因为weak修饰，self有可能为nil，如果是unowned修饰，这个地方应该是self.name。因为unowned修饰的self永远不可能为空。\n        var name = self!.name + \" nurse\"\n        print(\"wash room is \\(name)\")\n    }\n\n 输出结果：\njack 创建了\nwash room is jack nurse\njack 释放了\n```\n\n#### 参考资料及文章\n* <a herf=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/\">《The Swift Programming Language》</a>\n*  <a href=\"http://swifter.tips/retain-cycle/\">内存管理，WEAK 和 UNOWNED </a>\n* <a href=\"http://skyfly.xyz/2015/12/18/Swift/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/\">Swift学习笔记-内存管理</a>\n\n\n","source":"_posts/2016-01-15-swiftnei-cun-guan-li-(arc)zhi-xun-huan-yin-yong.markdown","raw":"---\nlayout: post\ntitle: \"Swift内存管理（ARC）之循环引用\"\ndate: 2016-01-15 01:37:31 +0800\ncomments: true\ntags: [iOS, Xcode, Swift, ARC, 内存管理, 循环引用, Block, Delegate]\nkeywords: Swift, ARC, 循环引用, 内存管理\ncategories: Swift\n---\nSwift中是采用自动引用计数(ARC，AutomaticReferenceCounting)机制来对内存进行管理的。\n\n#### 一、简述ARC如何工作：\n每当你每创建一个新的对象，它便会分配一块内存来存储该对象的相关信息。当你不再需要这个对象的时候，它就会自动释放这个对象，避免它再占用内存空间。当然，如果该对象只要至少存在一个引用就不会被释放。另外，你如果访问了一个已经被释放的对象，则很有可能会出现崩溃（野指针）。\n拿《The Swift Programming Language》里面的例子来套一下：\n\n```\n//创建一个Cat类，自带常量name属性\nclass Cat {\n    let name: String\n    init(name: String) {\n    //初始化name属性\n        self.name = name;\n        print(\"\\(name) 对象已经被初始化\")\n    }\n    \n    deinit {\n        print(\"\\(name) 对象释放成功！\")\n    }\n}\n\n```\n<!--more-->\n接下来定义三个变量类型为:Cat?用来对一个新的Cat对象建立多个引用。因为变量是一个可选类型（是Cat?而不是Cat）， 他们会自动给变量初始化为nil，所有当前它不需要引用一个Cat对象。\n\n```\nvar cat1: Cat?\nvar cat2: Cat?\nvar cat3: Cat?\n```\n\n创建一个新的Cat对象，并对之前定义的三个变量进行赋值操作：\n\n```\ncat1 = Cat(name: \"jack\")\n//输出：jack 对象已经被初始化\n\n```\n当你调用Cat类构造器，它会输出：\"jack 对象已经被初始化\"。这就代表已经完成了对象初始化操作。接下来，一个新的Cat对象被赋值给了 cat1变量，从而建立了cat1对新Cat实例对象的强引用。因此，它存在了至少一个强引用。这个新的Cat对象就不会被释放。\n如果你把同一个Cat实例对象赋值给另外两个变量，它则又多建立了两个强引用。\n\n```\n//通过赋值对Cat实例对象建立强引用\ncat2 = cat1\ncat3 = cat1\n```\n\n此时这个Cat实例对象已经有三个强引用了。\n如果你用把其中两个变量赋值为nil的方式来打破这些强引用，对象是不会被释放的。因为它还存在一个强引用。\n\n```\n//通过把置nil来打破cat1,cat2对Cat实例对象的强引用\ncat1 = nil\ncat2 = nil\n```\n只有直到对象所有的引用被打破，ARC才会释放该对象\n\n```\n//打破最后一个强引用\ncat3 = nil\n//输出：jack 对象释放成功！\n```\n当最后一个强引用被打破后，这个Cat对象被成功释放，输出：jack 对象释放成功！\n\n#### 二、循环引用\n\n1、什么是循环引用？\n简单的来说就是两个对象互相持有对方，使对方处于活跃状态不被释放，从而导致了循环引用。套个例子：\n\n```\n//创建一个Cat类，拥有一个String类型的name属性与一个可选类型的dog属性。\nclass Cat {\n    let name: String\n    init(name: String) {\n        self.name = name;\n        print(\"\\(name) 对象已经被初始化\")\n    }\n    var dog: Dog?\n    \n    deinit {\n        print(\"\\(name) 对象释放成功！\")\n    }\n}\n\n//创建一个Dog类，拥有一个String类型的type属性与一个可选类型的jack属性。\nclass Dog {\n    let type: String\n    init(type: String) {\n        self.type = type\n        print(\"\\(type) 对象已经被初始化\")\n    }\n    \n    var cat: Cat?\n    deinit {\n        print(\"\\(type) 对象释放成功\")\n    }\n}\n```\n定义两个变量并初始化\n\n```\nvar jack: Cat?\nvar tom: Dog?\n\njack = Cat(name: \"jack\")\n//print:jack 对象已经被初始化\ntom = Dog(type: \"red\")\n//print:red 对象已经被初始化\n```\n建立强引用\n\n```\njack!.dog = tom\ntom!.cat = jack\n```\n通过把对象置nil打破强引用\n\n```\njack = nil\ntom = nil\n```\n这个地方Cat对象和Dog对象都不会被释放，因为他们两个之间还存在强引用。\n\n* 解决循环引用办法\n\tSwift提供了两种方法来解决循环引用问题：\n\t\n\t（1）弱引用（weak）\n\t\n\t（2）无主引用（unowned）\n\t\n声明变量或属性时，在前面加上\"weak\"关键词表示它是一个弱引用。如果确定访问属性或函数的时候该对象不会被释放，也可以用无主引用（unowned）来取代。unowned跟Objective-C中的unsafe_unretained类似。它与weak的区别在于weak在引用的对象被释放后，会自动置nil。所以它必须声明成可选类型（？）。而unowned在引用对象被释放后不会自动置nil(因为非可选类型的变量不能被设置成nil)，而是保留对原有对象的无效引用，一旦对象被释放，再访问该对象的属性或函数就会造成崩溃。官方建议是当你在可以确定访问属性或函数所属对象不会被释放时，使用unowned。否则，还是使用weak吧！\n\n解决上面代码的循环引用问题，可做如下修改：\n\n```\nclass Dog {\n    let type: String\n    init(type: String) {\n        self.type = type\n        print(\"\\(type) 对象已经被初始化\")\n    }\n    \n    weak var jack: Cat\n    deinit {\n        print(\"\\(type) 对象释放成功\")\n    }\n}\n\n```\n\n```\njack = nil\ntom = nil\n```\n\n2、常见的循环引用问题：\n\n（1）delegate\n在项目中我们经常会用到代理模式，在Objective-C中我们一般在delegate前面加上weak关键词，表示它是一个弱引用。从而达到打破循环引用的效果。\n\n```\n//在前面加上@objc是指定这里的代码属于Objective-C的代码，因为Swift中协议可以用于class、struct、enum。对于基本数据类型，它不是对象，没有引用计数这个概念，因此无法使用weak关键词。  Objective-C中的协议只适用于类，所以这里需要加上@objc。\n@objc protocol AClassDelegate {\n    func wash()\n}\n\nclass A {\n    weak var delegate: AClassDelegate!\n    func cry() {\n        \n    }\n    func play() {\n        delegate.wash()\n    }\n}\n\nclass B: AClassDelegate {\n    \n    func feed() {\n        let nurse = A()\n        nurse.delegate = self\n        nurse.cry()\n    }\n    \n    @objc func wash() {\n        print(\"begin wash and sleep\")\n    }\n}\n```\n\n（2）Block(闭包)中的循环引用\nBlock(闭包)的循环引用在于它会持有所有引用的元素。比如我们在Block(闭包)中访问了self，那么它就持有了self。这样一来就形成了一个环：self持有Block(闭包)，Block(闭包)持有self。下面我们举个栗子加以说明：类A中有个闭包，我们在闭包中访问了self的name属性。\n\n```\nclass A {\n    let name: String\n    lazy var wash: Void ->Void = {\n        var name = self.name + \" nurse\"\n        print(\"wash room is \\(name)\")\n    }\n    \n    init(name: String) {\n        self.name = name\n        print(\"\\(self.name) 创建了\")\n    }\n    \n    deinit {\n        print(\"\\(self.name) 释放了\")\n    }\n}\n\nclass B {\n    func play() {\n        var nurse: A?\n        nurse = A(name: \"jack\")\n        nurse?.wash()\n    }\n}\n\nvar baby: B?\nbaby = B()\nbaby?.play()\n\n输出结果：\njack 创建了\nwash room is jack nurse\n```\n\n 因为wash是self的一个属性，所以wash被self持有。这个时候我们又在闭包中访问了self的name属性，所以它又在闭包中持有了self。这样便导致了循环引用。为了解决闭包中的循环引用问题，Swift中提供了一个叫”闭包捕获列表”的解决方案。\n \n * 定义一个捕获列表\n \n 捕获列表中的每一项都是一个用weak或 unowned关键字与一个实例对象的引用（如self）或者是一个用初始化值的变量（如delegate = self.delegate!）搭配成对，配对之间用逗号隔开，最后用方括号括起来。如下所示：\n \n ```\n \n  lazy var someClosure:(Int, String) -> String = {\n        [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -> String in\n        \n    }\n    \n ```\n \n 如果闭包中没有指定参数列表或者返回类型，可直接把捕获列表放置在闭包开始的地方（花括号后面）然后紧跟着是\"in\"关键词，示例代码如下：\n \n  ```\n  lazy var someClosure:Void -> String = {\n        [unowned self, weak delegate = self.delegate!]  in\n        \n    }\n ```\n \n \n * 解决Block(闭包)中的循环引用，ClassA中的Block(闭包)代码可做以下修改：\n\n```\nlazy var wash:Void ->Void = { [weak self] in\n//这个地方使用self!.name而不是self.name。是因为weak修饰，self有可能为nil，如果是unowned修饰，这个地方应该是self.name。因为unowned修饰的self永远不可能为空。\n        var name = self!.name + \" nurse\"\n        print(\"wash room is \\(name)\")\n    }\n\n 输出结果：\njack 创建了\nwash room is jack nurse\njack 释放了\n```\n\n#### 参考资料及文章\n* <a herf=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/\">《The Swift Programming Language》</a>\n*  <a href=\"http://swifter.tips/retain-cycle/\">内存管理，WEAK 和 UNOWNED </a>\n* <a href=\"http://skyfly.xyz/2015/12/18/Swift/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/\">Swift学习笔记-内存管理</a>\n\n\n","slug":"swiftnei-cun-guan-li-(arc)zhi-xun-huan-yin-yong","published":1,"updated":"2016-09-10T05:17:51.000Z","_id":"ciswie9d1000fe3u21bcenr6e","photos":[],"link":"","content":"<p>Swift中是采用自动引用计数(ARC，AutomaticReferenceCounting)机制来对内存进行管理的。</p>\n<h4 id=\"一、简述ARC如何工作：\"><a href=\"#一、简述ARC如何工作：\" class=\"headerlink\" title=\"一、简述ARC如何工作：\"></a>一、简述ARC如何工作：</h4><p>每当你每创建一个新的对象，它便会分配一块内存来存储该对象的相关信息。当你不再需要这个对象的时候，它就会自动释放这个对象，避免它再占用内存空间。当然，如果该对象只要至少存在一个引用就不会被释放。另外，你如果访问了一个已经被释放的对象，则很有可能会出现崩溃（野指针）。<br>拿《The Swift Programming Language》里面的例子来套一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建一个Cat类，自带常量name属性</div><div class=\"line\">class Cat &#123;</div><div class=\"line\">    let name: String</div><div class=\"line\">    init(name: String) &#123;</div><div class=\"line\">    //初始化name属性</div><div class=\"line\">        self.name = name;</div><div class=\"line\">        print(&quot;\\(name) 对象已经被初始化&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    deinit &#123;</div><div class=\"line\">        print(&quot;\\(name) 对象释放成功！&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>接下来定义三个变量类型为:Cat?用来对一个新的Cat对象建立多个引用。因为变量是一个可选类型（是Cat?而不是Cat）， 他们会自动给变量初始化为nil，所有当前它不需要引用一个Cat对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cat1: Cat?</div><div class=\"line\">var cat2: Cat?</div><div class=\"line\">var cat3: Cat?</div></pre></td></tr></table></figure>\n<p>创建一个新的Cat对象，并对之前定义的三个变量进行赋值操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cat1 = Cat(name: &quot;jack&quot;)</div><div class=\"line\">//输出：jack 对象已经被初始化</div></pre></td></tr></table></figure>\n<p>当你调用Cat类构造器，它会输出：”jack 对象已经被初始化”。这就代表已经完成了对象初始化操作。接下来，一个新的Cat对象被赋值给了 cat1变量，从而建立了cat1对新Cat实例对象的强引用。因此，它存在了至少一个强引用。这个新的Cat对象就不会被释放。<br>如果你把同一个Cat实例对象赋值给另外两个变量，它则又多建立了两个强引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//通过赋值对Cat实例对象建立强引用</div><div class=\"line\">cat2 = cat1</div><div class=\"line\">cat3 = cat1</div></pre></td></tr></table></figure>\n<p>此时这个Cat实例对象已经有三个强引用了。<br>如果你用把其中两个变量赋值为nil的方式来打破这些强引用，对象是不会被释放的。因为它还存在一个强引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//通过把置nil来打破cat1,cat2对Cat实例对象的强引用</div><div class=\"line\">cat1 = nil</div><div class=\"line\">cat2 = nil</div></pre></td></tr></table></figure>\n<p>只有直到对象所有的引用被打破，ARC才会释放该对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//打破最后一个强引用</div><div class=\"line\">cat3 = nil</div><div class=\"line\">//输出：jack 对象释放成功！</div></pre></td></tr></table></figure>\n<p>当最后一个强引用被打破后，这个Cat对象被成功释放，输出：jack 对象释放成功！</p>\n<h4 id=\"二、循环引用\"><a href=\"#二、循环引用\" class=\"headerlink\" title=\"二、循环引用\"></a>二、循环引用</h4><p>1、什么是循环引用？<br>简单的来说就是两个对象互相持有对方，使对方处于活跃状态不被释放，从而导致了循环引用。套个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建一个Cat类，拥有一个String类型的name属性与一个可选类型的dog属性。</div><div class=\"line\">class Cat &#123;</div><div class=\"line\">    let name: String</div><div class=\"line\">    init(name: String) &#123;</div><div class=\"line\">        self.name = name;</div><div class=\"line\">        print(&quot;\\(name) 对象已经被初始化&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    var dog: Dog?</div><div class=\"line\">    </div><div class=\"line\">    deinit &#123;</div><div class=\"line\">        print(&quot;\\(name) 对象释放成功！&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//创建一个Dog类，拥有一个String类型的type属性与一个可选类型的jack属性。</div><div class=\"line\">class Dog &#123;</div><div class=\"line\">    let type: String</div><div class=\"line\">    init(type: String) &#123;</div><div class=\"line\">        self.type = type</div><div class=\"line\">        print(&quot;\\(type) 对象已经被初始化&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    var cat: Cat?</div><div class=\"line\">    deinit &#123;</div><div class=\"line\">        print(&quot;\\(type) 对象释放成功&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>定义两个变量并初始化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var jack: Cat?</div><div class=\"line\">var tom: Dog?</div><div class=\"line\"></div><div class=\"line\">jack = Cat(name: &quot;jack&quot;)</div><div class=\"line\">//print:jack 对象已经被初始化</div><div class=\"line\">tom = Dog(type: &quot;red&quot;)</div><div class=\"line\">//print:red 对象已经被初始化</div></pre></td></tr></table></figure>\n<p>建立强引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">jack!.dog = tom</div><div class=\"line\">tom!.cat = jack</div></pre></td></tr></table></figure>\n<p>通过把对象置nil打破强引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">jack = nil</div><div class=\"line\">tom = nil</div></pre></td></tr></table></figure>\n<p>这个地方Cat对象和Dog对象都不会被释放，因为他们两个之间还存在强引用。</p>\n<ul>\n<li><p>解决循环引用办法<br>  Swift提供了两种方法来解决循环引用问题：</p>\n<p>  （1）弱引用（weak）</p>\n<p>  （2）无主引用（unowned）</p>\n</li>\n</ul>\n<p>声明变量或属性时，在前面加上”weak”关键词表示它是一个弱引用。如果确定访问属性或函数的时候该对象不会被释放，也可以用无主引用（unowned）来取代。unowned跟Objective-C中的unsafe_unretained类似。它与weak的区别在于weak在引用的对象被释放后，会自动置nil。所以它必须声明成可选类型（？）。而unowned在引用对象被释放后不会自动置nil(因为非可选类型的变量不能被设置成nil)，而是保留对原有对象的无效引用，一旦对象被释放，再访问该对象的属性或函数就会造成崩溃。官方建议是当你在可以确定访问属性或函数所属对象不会被释放时，使用unowned。否则，还是使用weak吧！</p>\n<p>解决上面代码的循环引用问题，可做如下修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Dog &#123;</div><div class=\"line\">    let type: String</div><div class=\"line\">    init(type: String) &#123;</div><div class=\"line\">        self.type = type</div><div class=\"line\">        print(&quot;\\(type) 对象已经被初始化&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    weak var jack: Cat</div><div class=\"line\">    deinit &#123;</div><div class=\"line\">        print(&quot;\\(type) 对象释放成功&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">jack = nil</div><div class=\"line\">tom = nil</div></pre></td></tr></table></figure>\n<p>2、常见的循环引用问题：</p>\n<p>（1）delegate<br>在项目中我们经常会用到代理模式，在Objective-C中我们一般在delegate前面加上weak关键词，表示它是一个弱引用。从而达到打破循环引用的效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">//在前面加上@objc是指定这里的代码属于Objective-C的代码，因为Swift中协议可以用于class、struct、enum。对于基本数据类型，它不是对象，没有引用计数这个概念，因此无法使用weak关键词。  Objective-C中的协议只适用于类，所以这里需要加上@objc。</div><div class=\"line\">@objc protocol AClassDelegate &#123;</div><div class=\"line\">    func wash()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class A &#123;</div><div class=\"line\">    weak var delegate: AClassDelegate!</div><div class=\"line\">    func cry() &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    func play() &#123;</div><div class=\"line\">        delegate.wash()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class B: AClassDelegate &#123;</div><div class=\"line\">    </div><div class=\"line\">    func feed() &#123;</div><div class=\"line\">        let nurse = A()</div><div class=\"line\">        nurse.delegate = self</div><div class=\"line\">        nurse.cry()</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    @objc func wash() &#123;</div><div class=\"line\">        print(&quot;begin wash and sleep&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（2）Block(闭包)中的循环引用<br>Block(闭包)的循环引用在于它会持有所有引用的元素。比如我们在Block(闭包)中访问了self，那么它就持有了self。这样一来就形成了一个环：self持有Block(闭包)，Block(闭包)持有self。下面我们举个栗子加以说明：类A中有个闭包，我们在闭包中访问了self的name属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">class A &#123;</div><div class=\"line\">    let name: String</div><div class=\"line\">    lazy var wash: Void -&gt;Void = &#123;</div><div class=\"line\">        var name = self.name + &quot; nurse&quot;</div><div class=\"line\">        print(&quot;wash room is \\(name)&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    init(name: String) &#123;</div><div class=\"line\">        self.name = name</div><div class=\"line\">        print(&quot;\\(self.name) 创建了&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    deinit &#123;</div><div class=\"line\">        print(&quot;\\(self.name) 释放了&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class B &#123;</div><div class=\"line\">    func play() &#123;</div><div class=\"line\">        var nurse: A?</div><div class=\"line\">        nurse = A(name: &quot;jack&quot;)</div><div class=\"line\">        nurse?.wash()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var baby: B?</div><div class=\"line\">baby = B()</div><div class=\"line\">baby?.play()</div><div class=\"line\"></div><div class=\"line\">输出结果：</div><div class=\"line\">jack 创建了</div><div class=\"line\">wash room is jack nurse</div></pre></td></tr></table></figure>\n<p> 因为wash是self的一个属性，所以wash被self持有。这个时候我们又在闭包中访问了self的name属性，所以它又在闭包中持有了self。这样便导致了循环引用。为了解决闭包中的循环引用问题，Swift中提供了一个叫”闭包捕获列表”的解决方案。</p>\n<ul>\n<li><p>定义一个捕获列表</p>\n<p>捕获列表中的每一项都是一个用weak或 unowned关键字与一个实例对象的引用（如self）或者是一个用初始化值的变量（如delegate = self.delegate!）搭配成对，配对之间用逗号隔开，最后用方括号括起来。如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> </div><div class=\"line\">lazy var someClosure:(Int, String) -&gt; String = &#123;</div><div class=\"line\">      [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in</div><div class=\"line\">      </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p> 如果闭包中没有指定参数列表或者返回类型，可直接把捕获列表放置在闭包开始的地方（花括号后面）然后紧跟着是”in”关键词，示例代码如下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">lazy var someClosure:Void -&gt; String = &#123;</div><div class=\"line\">      [unowned self, weak delegate = self.delegate!]  in</div><div class=\"line\">      </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>解决Block(闭包)中的循环引用，ClassA中的Block(闭包)代码可做以下修改：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">lazy var wash:Void -&gt;Void = &#123; [weak self] in</div><div class=\"line\">//这个地方使用self!.name而不是self.name。是因为weak修饰，self有可能为nil，如果是unowned修饰，这个地方应该是self.name。因为unowned修饰的self永远不可能为空。</div><div class=\"line\">        var name = self!.name + &quot; nurse&quot;</div><div class=\"line\">        print(&quot;wash room is \\(name)&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"> 输出结果：</div><div class=\"line\">jack 创建了</div><div class=\"line\">wash room is jack nurse</div><div class=\"line\">jack 释放了</div></pre></td></tr></table></figure>\n<h4 id=\"参考资料及文章\"><a href=\"#参考资料及文章\" class=\"headerlink\" title=\"参考资料及文章\"></a>参考资料及文章</h4><ul>\n<li><a herf=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/\">《The Swift Programming Language》</a></li>\n<li><a href=\"http://swifter.tips/retain-cycle/\" target=\"_blank\" rel=\"external\">内存管理，WEAK 和 UNOWNED </a></li>\n<li><a href=\"http://skyfly.xyz/2015/12/18/Swift/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"external\">Swift学习笔记-内存管理</a></li>\n</ul>\n","excerpt":"<p>Swift中是采用自动引用计数(ARC，AutomaticReferenceCounting)机制来对内存进行管理的。</p>\n<h4 id=\"一、简述ARC如何工作：\"><a href=\"#一、简述ARC如何工作：\" class=\"headerlink\" title=\"一、简述ARC如何工作：\"></a>一、简述ARC如何工作：</h4><p>每当你每创建一个新的对象，它便会分配一块内存来存储该对象的相关信息。当你不再需要这个对象的时候，它就会自动释放这个对象，避免它再占用内存空间。当然，如果该对象只要至少存在一个引用就不会被释放。另外，你如果访问了一个已经被释放的对象，则很有可能会出现崩溃（野指针）。<br>拿《The Swift Programming Language》里面的例子来套一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建一个Cat类，自带常量name属性</div><div class=\"line\">class Cat &#123;</div><div class=\"line\">    let name: String</div><div class=\"line\">    init(name: String) &#123;</div><div class=\"line\">    //初始化name属性</div><div class=\"line\">        self.name = name;</div><div class=\"line\">        print(&quot;\\(name) 对象已经被初始化&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    deinit &#123;</div><div class=\"line\">        print(&quot;\\(name) 对象释放成功！&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>接下来定义三个变量类型为:Cat?用来对一个新的Cat对象建立多个引用。因为变量是一个可选类型（是Cat?而不是Cat）， 他们会自动给变量初始化为nil，所有当前它不需要引用一个Cat对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cat1: Cat?</div><div class=\"line\">var cat2: Cat?</div><div class=\"line\">var cat3: Cat?</div></pre></td></tr></table></figure>\n<p>创建一个新的Cat对象，并对之前定义的三个变量进行赋值操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cat1 = Cat(name: &quot;jack&quot;)</div><div class=\"line\">//输出：jack 对象已经被初始化</div></pre></td></tr></table></figure>\n<p>当你调用Cat类构造器，它会输出：”jack 对象已经被初始化”。这就代表已经完成了对象初始化操作。接下来，一个新的Cat对象被赋值给了 cat1变量，从而建立了cat1对新Cat实例对象的强引用。因此，它存在了至少一个强引用。这个新的Cat对象就不会被释放。<br>如果你把同一个Cat实例对象赋值给另外两个变量，它则又多建立了两个强引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//通过赋值对Cat实例对象建立强引用</div><div class=\"line\">cat2 = cat1</div><div class=\"line\">cat3 = cat1</div></pre></td></tr></table></figure>\n<p>此时这个Cat实例对象已经有三个强引用了。<br>如果你用把其中两个变量赋值为nil的方式来打破这些强引用，对象是不会被释放的。因为它还存在一个强引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//通过把置nil来打破cat1,cat2对Cat实例对象的强引用</div><div class=\"line\">cat1 = nil</div><div class=\"line\">cat2 = nil</div></pre></td></tr></table></figure>\n<p>只有直到对象所有的引用被打破，ARC才会释放该对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//打破最后一个强引用</div><div class=\"line\">cat3 = nil</div><div class=\"line\">//输出：jack 对象释放成功！</div></pre></td></tr></table></figure>\n<p>当最后一个强引用被打破后，这个Cat对象被成功释放，输出：jack 对象释放成功！</p>\n<h4 id=\"二、循环引用\"><a href=\"#二、循环引用\" class=\"headerlink\" title=\"二、循环引用\"></a>二、循环引用</h4><p>1、什么是循环引用？<br>简单的来说就是两个对象互相持有对方，使对方处于活跃状态不被释放，从而导致了循环引用。套个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建一个Cat类，拥有一个String类型的name属性与一个可选类型的dog属性。</div><div class=\"line\">class Cat &#123;</div><div class=\"line\">    let name: String</div><div class=\"line\">    init(name: String) &#123;</div><div class=\"line\">        self.name = name;</div><div class=\"line\">        print(&quot;\\(name) 对象已经被初始化&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    var dog: Dog?</div><div class=\"line\">    </div><div class=\"line\">    deinit &#123;</div><div class=\"line\">        print(&quot;\\(name) 对象释放成功！&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//创建一个Dog类，拥有一个String类型的type属性与一个可选类型的jack属性。</div><div class=\"line\">class Dog &#123;</div><div class=\"line\">    let type: String</div><div class=\"line\">    init(type: String) &#123;</div><div class=\"line\">        self.type = type</div><div class=\"line\">        print(&quot;\\(type) 对象已经被初始化&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    var cat: Cat?</div><div class=\"line\">    deinit &#123;</div><div class=\"line\">        print(&quot;\\(type) 对象释放成功&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>定义两个变量并初始化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var jack: Cat?</div><div class=\"line\">var tom: Dog?</div><div class=\"line\"></div><div class=\"line\">jack = Cat(name: &quot;jack&quot;)</div><div class=\"line\">//print:jack 对象已经被初始化</div><div class=\"line\">tom = Dog(type: &quot;red&quot;)</div><div class=\"line\">//print:red 对象已经被初始化</div></pre></td></tr></table></figure>\n<p>建立强引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">jack!.dog = tom</div><div class=\"line\">tom!.cat = jack</div></pre></td></tr></table></figure>\n<p>通过把对象置nil打破强引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">jack = nil</div><div class=\"line\">tom = nil</div></pre></td></tr></table></figure>\n<p>这个地方Cat对象和Dog对象都不会被释放，因为他们两个之间还存在强引用。</p>\n<ul>\n<li><p>解决循环引用办法<br>  Swift提供了两种方法来解决循环引用问题：</p>\n<p>  （1）弱引用（weak）</p>\n<p>  （2）无主引用（unowned）</p>\n</li>\n</ul>\n<p>声明变量或属性时，在前面加上”weak”关键词表示它是一个弱引用。如果确定访问属性或函数的时候该对象不会被释放，也可以用无主引用（unowned）来取代。unowned跟Objective-C中的unsafe_unretained类似。它与weak的区别在于weak在引用的对象被释放后，会自动置nil。所以它必须声明成可选类型（？）。而unowned在引用对象被释放后不会自动置nil(因为非可选类型的变量不能被设置成nil)，而是保留对原有对象的无效引用，一旦对象被释放，再访问该对象的属性或函数就会造成崩溃。官方建议是当你在可以确定访问属性或函数所属对象不会被释放时，使用unowned。否则，还是使用weak吧！</p>\n<p>解决上面代码的循环引用问题，可做如下修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Dog &#123;</div><div class=\"line\">    let type: String</div><div class=\"line\">    init(type: String) &#123;</div><div class=\"line\">        self.type = type</div><div class=\"line\">        print(&quot;\\(type) 对象已经被初始化&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    weak var jack: Cat</div><div class=\"line\">    deinit &#123;</div><div class=\"line\">        print(&quot;\\(type) 对象释放成功&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">jack = nil</div><div class=\"line\">tom = nil</div></pre></td></tr></table></figure>\n<p>2、常见的循环引用问题：</p>\n<p>（1）delegate<br>在项目中我们经常会用到代理模式，在Objective-C中我们一般在delegate前面加上weak关键词，表示它是一个弱引用。从而达到打破循环引用的效果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">//在前面加上@objc是指定这里的代码属于Objective-C的代码，因为Swift中协议可以用于class、struct、enum。对于基本数据类型，它不是对象，没有引用计数这个概念，因此无法使用weak关键词。  Objective-C中的协议只适用于类，所以这里需要加上@objc。</div><div class=\"line\">@objc protocol AClassDelegate &#123;</div><div class=\"line\">    func wash()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class A &#123;</div><div class=\"line\">    weak var delegate: AClassDelegate!</div><div class=\"line\">    func cry() &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    func play() &#123;</div><div class=\"line\">        delegate.wash()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class B: AClassDelegate &#123;</div><div class=\"line\">    </div><div class=\"line\">    func feed() &#123;</div><div class=\"line\">        let nurse = A()</div><div class=\"line\">        nurse.delegate = self</div><div class=\"line\">        nurse.cry()</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    @objc func wash() &#123;</div><div class=\"line\">        print(&quot;begin wash and sleep&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（2）Block(闭包)中的循环引用<br>Block(闭包)的循环引用在于它会持有所有引用的元素。比如我们在Block(闭包)中访问了self，那么它就持有了self。这样一来就形成了一个环：self持有Block(闭包)，Block(闭包)持有self。下面我们举个栗子加以说明：类A中有个闭包，我们在闭包中访问了self的name属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">class A &#123;</div><div class=\"line\">    let name: String</div><div class=\"line\">    lazy var wash: Void -&gt;Void = &#123;</div><div class=\"line\">        var name = self.name + &quot; nurse&quot;</div><div class=\"line\">        print(&quot;wash room is \\(name)&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    init(name: String) &#123;</div><div class=\"line\">        self.name = name</div><div class=\"line\">        print(&quot;\\(self.name) 创建了&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    deinit &#123;</div><div class=\"line\">        print(&quot;\\(self.name) 释放了&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class B &#123;</div><div class=\"line\">    func play() &#123;</div><div class=\"line\">        var nurse: A?</div><div class=\"line\">        nurse = A(name: &quot;jack&quot;)</div><div class=\"line\">        nurse?.wash()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var baby: B?</div><div class=\"line\">baby = B()</div><div class=\"line\">baby?.play()</div><div class=\"line\"></div><div class=\"line\">输出结果：</div><div class=\"line\">jack 创建了</div><div class=\"line\">wash room is jack nurse</div></pre></td></tr></table></figure>\n<p> 因为wash是self的一个属性，所以wash被self持有。这个时候我们又在闭包中访问了self的name属性，所以它又在闭包中持有了self。这样便导致了循环引用。为了解决闭包中的循环引用问题，Swift中提供了一个叫”闭包捕获列表”的解决方案。</p>\n<ul>\n<li><p>定义一个捕获列表</p>\n<p>捕获列表中的每一项都是一个用weak或 unowned关键字与一个实例对象的引用（如self）或者是一个用初始化值的变量（如delegate = self.delegate!）搭配成对，配对之间用逗号隔开，最后用方括号括起来。如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> </div><div class=\"line\">lazy var someClosure:(Int, String) -&gt; String = &#123;</div><div class=\"line\">      [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in</div><div class=\"line\">      </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p> 如果闭包中没有指定参数列表或者返回类型，可直接把捕获列表放置在闭包开始的地方（花括号后面）然后紧跟着是”in”关键词，示例代码如下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">lazy var someClosure:Void -&gt; String = &#123;</div><div class=\"line\">      [unowned self, weak delegate = self.delegate!]  in</div><div class=\"line\">      </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>解决Block(闭包)中的循环引用，ClassA中的Block(闭包)代码可做以下修改：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">lazy var wash:Void -&gt;Void = &#123; [weak self] in</div><div class=\"line\">//这个地方使用self!.name而不是self.name。是因为weak修饰，self有可能为nil，如果是unowned修饰，这个地方应该是self.name。因为unowned修饰的self永远不可能为空。</div><div class=\"line\">        var name = self!.name + &quot; nurse&quot;</div><div class=\"line\">        print(&quot;wash room is \\(name)&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"> 输出结果：</div><div class=\"line\">jack 创建了</div><div class=\"line\">wash room is jack nurse</div><div class=\"line\">jack 释放了</div></pre></td></tr></table></figure>\n<h4 id=\"参考资料及文章\"><a href=\"#参考资料及文章\" class=\"headerlink\" title=\"参考资料及文章\"></a>参考资料及文章</h4><ul>\n<li><a herf=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/\">《The Swift Programming Language》</a></li>\n<li><a href=\"http://swifter.tips/retain-cycle/\">内存管理，WEAK 和 UNOWNED </a></li>\n<li><a href=\"http://skyfly.xyz/2015/12/18/Swift/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/\">Swift学习笔记-内存管理</a></li>\n</ul>"},{"layout":"post","title":"2015年终总结","date":"2016-01-01T05:26:26.000Z","comments":1,"keywords":"Plan, Summary","_content":"#### 总结：\n回首过去一年，好像没有什么能说出口的成绩，专业没啥进步。在公司做了两款App，上半年主要开发的是一款叫“在线等”的手机应用，这是一款解决人们选择困难症的应用，经过重重困难，最终上线。没啥成绩可言。下半年主要研发的是一款叫“斗图神器”的应用，由于Android版早就开发好了，所以iOS版开发起来就快很多了。总的来说成绩还不错，其中也有点小波折。<!--more-->现在已经提交过3，4版了。目前“斗图神器”项目已经引入了全新的Swift语言与Objective-C语言混编。目的是拥抱Swift，它才是未来。这对我们来说是好事，有项目环境学习新语言就更快了。现在我还是处于Swift 初级入门阶段，明年希望能进一步提高吧！在学习方面，搭建了自己的<a href=\"http://yangshebing.github.io\">**个人技术博客**</a>，另外还写了几篇质量不高的博文，在github上放了几个质量不高的demo。买了手机和电脑，这也算专业学习上的投入吧。生活上，除了每天写写代码，并没有什么其他变化。4月份去了一趟泰山，7月份去了一次十渡，10月份游了半个北京（虽然来北京久了，却很少出去）顺带去了一趟天津。今年最大的事情就是拔了一颗智齿和一颗蛀牙，花了不少钱，现在都没弄好！折腾了半条命（太背），一直不太顺。其次就是大病没犯，小病不断，北京这边雾霾比较严重。咽炎也挺折腾人的。本来年底是计划上线一款自己的app,由于各种借口各种拖最终没能实现，也没啥可遗憾的，主要是自己没有努力。其实还计划学习一门除专业外的语言，这个计划也耽搁了！计划内的写一个插件，现在也还没开动！专业书今年没有仔细读过，其实应该多读几本。扩展书籍就读过《高效能人士的7个习惯》与《从0到1》。总而言之就是读的书还是太少，平常大部分时间是在网上看别人的博客学习，看官方文档，不会的就自己用google搜索。人丑就要多读书。越来越不会说话了，已经想不起还有什么要说的了，那就先写到这吧！共勉！\n2016的计划与展望：\n#### 计划：\n* 1、\t读10本以上的专业相关的书籍，扩展阅读书籍不少于5本。\n* 2、\t学一门专业外的语言\n* 3、\t在github上开源5个项目（高质量）\n* 4、\t博客不少于50篇博文（高质量）\n* 5、\t找个女盆友\n* 6、\t福利计划：去国外旅游一次（条件如下）\n\n```\nif plan five implement {\n\t\timplement plan six\n} else {\n\t\tnothing happened\n}\n```\n#### 展望：\n马上迎来全新的2016年，又是一个全新的开始。时间匆匆，趁着年轻就要好好努力，物尽其用。希望在新的一年里，事业蒸蒸日上，身体健健康康（身体是革命的本钱，是实现计划的基石），愿家人幸福安康。\n","source":"_posts/2016-01-01-2015nian-zhong-zong-jie.markdown","raw":"---\nlayout: post\ntitle: \"2015年终总结\"\ndate: 2016-01-01 13:26:26 +0800\ncomments: true\ntags: [年终总结, Plan, Summary, 计划]\nkeywords: Plan, Summary\ncategories: Others\n---\n#### 总结：\n回首过去一年，好像没有什么能说出口的成绩，专业没啥进步。在公司做了两款App，上半年主要开发的是一款叫“在线等”的手机应用，这是一款解决人们选择困难症的应用，经过重重困难，最终上线。没啥成绩可言。下半年主要研发的是一款叫“斗图神器”的应用，由于Android版早就开发好了，所以iOS版开发起来就快很多了。总的来说成绩还不错，其中也有点小波折。<!--more-->现在已经提交过3，4版了。目前“斗图神器”项目已经引入了全新的Swift语言与Objective-C语言混编。目的是拥抱Swift，它才是未来。这对我们来说是好事，有项目环境学习新语言就更快了。现在我还是处于Swift 初级入门阶段，明年希望能进一步提高吧！在学习方面，搭建了自己的<a href=\"http://yangshebing.github.io\">**个人技术博客**</a>，另外还写了几篇质量不高的博文，在github上放了几个质量不高的demo。买了手机和电脑，这也算专业学习上的投入吧。生活上，除了每天写写代码，并没有什么其他变化。4月份去了一趟泰山，7月份去了一次十渡，10月份游了半个北京（虽然来北京久了，却很少出去）顺带去了一趟天津。今年最大的事情就是拔了一颗智齿和一颗蛀牙，花了不少钱，现在都没弄好！折腾了半条命（太背），一直不太顺。其次就是大病没犯，小病不断，北京这边雾霾比较严重。咽炎也挺折腾人的。本来年底是计划上线一款自己的app,由于各种借口各种拖最终没能实现，也没啥可遗憾的，主要是自己没有努力。其实还计划学习一门除专业外的语言，这个计划也耽搁了！计划内的写一个插件，现在也还没开动！专业书今年没有仔细读过，其实应该多读几本。扩展书籍就读过《高效能人士的7个习惯》与《从0到1》。总而言之就是读的书还是太少，平常大部分时间是在网上看别人的博客学习，看官方文档，不会的就自己用google搜索。人丑就要多读书。越来越不会说话了，已经想不起还有什么要说的了，那就先写到这吧！共勉！\n2016的计划与展望：\n#### 计划：\n* 1、\t读10本以上的专业相关的书籍，扩展阅读书籍不少于5本。\n* 2、\t学一门专业外的语言\n* 3、\t在github上开源5个项目（高质量）\n* 4、\t博客不少于50篇博文（高质量）\n* 5、\t找个女盆友\n* 6、\t福利计划：去国外旅游一次（条件如下）\n\n```\nif plan five implement {\n\t\timplement plan six\n} else {\n\t\tnothing happened\n}\n```\n#### 展望：\n马上迎来全新的2016年，又是一个全新的开始。时间匆匆，趁着年轻就要好好努力，物尽其用。希望在新的一年里，事业蒸蒸日上，身体健健康康（身体是革命的本钱，是实现计划的基石），愿家人幸福安康。\n","slug":"2015nian-zhong-zong-jie","published":1,"updated":"2016-09-10T05:17:26.000Z","_id":"ciswie9d4000je3u2y1hz70im","photos":[],"link":"","content":"<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>回首过去一年，好像没有什么能说出口的成绩，专业没啥进步。在公司做了两款App，上半年主要开发的是一款叫“在线等”的手机应用，这是一款解决人们选择困难症的应用，经过重重困难，最终上线。没啥成绩可言。下半年主要研发的是一款叫“斗图神器”的应用，由于Android版早就开发好了，所以iOS版开发起来就快很多了。总的来说成绩还不错，其中也有点小波折。<a id=\"more\"></a>现在已经提交过3，4版了。目前“斗图神器”项目已经引入了全新的Swift语言与Objective-C语言混编。目的是拥抱Swift，它才是未来。这对我们来说是好事，有项目环境学习新语言就更快了。现在我还是处于Swift 初级入门阶段，明年希望能进一步提高吧！在学习方面，搭建了自己的<a href=\"http://yangshebing.github.io\" target=\"_blank\" rel=\"external\"><strong>个人技术博客</strong></a>，另外还写了几篇质量不高的博文，在github上放了几个质量不高的demo。买了手机和电脑，这也算专业学习上的投入吧。生活上，除了每天写写代码，并没有什么其他变化。4月份去了一趟泰山，7月份去了一次十渡，10月份游了半个北京（虽然来北京久了，却很少出去）顺带去了一趟天津。今年最大的事情就是拔了一颗智齿和一颗蛀牙，花了不少钱，现在都没弄好！折腾了半条命（太背），一直不太顺。其次就是大病没犯，小病不断，北京这边雾霾比较严重。咽炎也挺折腾人的。本来年底是计划上线一款自己的app,由于各种借口各种拖最终没能实现，也没啥可遗憾的，主要是自己没有努力。其实还计划学习一门除专业外的语言，这个计划也耽搁了！计划内的写一个插件，现在也还没开动！专业书今年没有仔细读过，其实应该多读几本。扩展书籍就读过《高效能人士的7个习惯》与《从0到1》。总而言之就是读的书还是太少，平常大部分时间是在网上看别人的博客学习，看官方文档，不会的就自己用google搜索。人丑就要多读书。越来越不会说话了，已经想不起还有什么要说的了，那就先写到这吧！共勉！<br>2016的计划与展望：</p>\n<h4 id=\"计划：\"><a href=\"#计划：\" class=\"headerlink\" title=\"计划：\"></a>计划：</h4><ul>\n<li>1、    读10本以上的专业相关的书籍，扩展阅读书籍不少于5本。</li>\n<li>2、    学一门专业外的语言</li>\n<li>3、    在github上开源5个项目（高质量）</li>\n<li>4、    博客不少于50篇博文（高质量）</li>\n<li>5、    找个女盆友</li>\n<li>6、    福利计划：去国外旅游一次（条件如下）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if plan five implement &#123;</div><div class=\"line\">\t\timplement plan six</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">\t\tnothing happened</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"展望：\"><a href=\"#展望：\" class=\"headerlink\" title=\"展望：\"></a>展望：</h4><p>马上迎来全新的2016年，又是一个全新的开始。时间匆匆，趁着年轻就要好好努力，物尽其用。希望在新的一年里，事业蒸蒸日上，身体健健康康（身体是革命的本钱，是实现计划的基石），愿家人幸福安康。</p>\n","excerpt":"<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>回首过去一年，好像没有什么能说出口的成绩，专业没啥进步。在公司做了两款App，上半年主要开发的是一款叫“在线等”的手机应用，这是一款解决人们选择困难症的应用，经过重重困难，最终上线。没啥成绩可言。下半年主要研发的是一款叫“斗图神器”的应用，由于Android版早就开发好了，所以iOS版开发起来就快很多了。总的来说成绩还不错，其中也有点小波折。","more":"现在已经提交过3，4版了。目前“斗图神器”项目已经引入了全新的Swift语言与Objective-C语言混编。目的是拥抱Swift，它才是未来。这对我们来说是好事，有项目环境学习新语言就更快了。现在我还是处于Swift 初级入门阶段，明年希望能进一步提高吧！在学习方面，搭建了自己的<a href=\"http://yangshebing.github.io\"><strong>个人技术博客</strong></a>，另外还写了几篇质量不高的博文，在github上放了几个质量不高的demo。买了手机和电脑，这也算专业学习上的投入吧。生活上，除了每天写写代码，并没有什么其他变化。4月份去了一趟泰山，7月份去了一次十渡，10月份游了半个北京（虽然来北京久了，却很少出去）顺带去了一趟天津。今年最大的事情就是拔了一颗智齿和一颗蛀牙，花了不少钱，现在都没弄好！折腾了半条命（太背），一直不太顺。其次就是大病没犯，小病不断，北京这边雾霾比较严重。咽炎也挺折腾人的。本来年底是计划上线一款自己的app,由于各种借口各种拖最终没能实现，也没啥可遗憾的，主要是自己没有努力。其实还计划学习一门除专业外的语言，这个计划也耽搁了！计划内的写一个插件，现在也还没开动！专业书今年没有仔细读过，其实应该多读几本。扩展书籍就读过《高效能人士的7个习惯》与《从0到1》。总而言之就是读的书还是太少，平常大部分时间是在网上看别人的博客学习，看官方文档，不会的就自己用google搜索。人丑就要多读书。越来越不会说话了，已经想不起还有什么要说的了，那就先写到这吧！共勉！<br>2016的计划与展望：</p>\n<h4 id=\"计划：\"><a href=\"#计划：\" class=\"headerlink\" title=\"计划：\"></a>计划：</h4><ul>\n<li>1、    读10本以上的专业相关的书籍，扩展阅读书籍不少于5本。</li>\n<li>2、    学一门专业外的语言</li>\n<li>3、    在github上开源5个项目（高质量）</li>\n<li>4、    博客不少于50篇博文（高质量）</li>\n<li>5、    找个女盆友</li>\n<li>6、    福利计划：去国外旅游一次（条件如下）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if plan five implement &#123;</div><div class=\"line\">\t\timplement plan six</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">\t\tnothing happened</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"展望：\"><a href=\"#展望：\" class=\"headerlink\" title=\"展望：\"></a>展望：</h4><p>马上迎来全新的2016年，又是一个全新的开始。时间匆匆，趁着年轻就要好好努力，物尽其用。希望在新的一年里，事业蒸蒸日上，身体健健康康（身体是革命的本钱，是实现计划的基石），愿家人幸福安康。</p>"},{"layout":"post","title":"iOS开发之基础控件（Swift版）","date":"2016-01-02T03:08:19.000Z","comments":1,"keywords":"iOS开发, 基础控件, Swift","_content":"  1、文本（UILabel）：\n  \n```\n  let titleLabel = UILabel(frame: CGRectMake(0, 0, view.frame.size.width, view.frame.size.height))\n        //设置titleLabel的文本对齐方式：左：.Left, 中:.Center, 右:.Right\n        titleLabel.textAlignment = .Center\n        //设置titleLabel的文本颜色\n        titleLabel.textColor = UIColor.lightGrayColor()\n        //设置titleLabel文字的字体为系统字体，大小为15\n        titleLabel.font = UIFont.systemFontOfSize(15)\n        //设置titleLabel文字的字体为\"Helvetica\", 大小为15\n        titleLabel.font = UIFont(name: \"Helvetica\", size: 15)\n        titleLabel.text = \"心灵鸡汤，每天一起干\"\n        //titleLabel字体大小自适应宽度，根据指定宽度titleLabel自动调整字体显示大小\n        titleLabel.adjustsFontSizeToFitWidth = true\n        //指定titleLabel的显示行数，0代表自动折行\n        titleLabel.numberOfLines = 1\n        //获取系统所有字体名称\n        let fontFamily = UIFont.familyNames()\n        print(fontFamily)\n        view.addSubview(titleLabel)\n```\n<!--more-->\n2、按钮（UIButton）：\n\n```\n//按钮类型：常见的两种如下\n         /**\n         *.Custom:自定义类型\n         *.System:系统类型（iOS7.0）\n         **/\n        let followButton = UIButton(type: .Custom)\n        followButton.frame = CGRectMake(100, 100, 100, 50)\n        //设置按钮在特定状态下的文本显示，常见的有：\n        /**\n         *.Normal:按钮常规显示状态\n         *.Selected:按钮选中显示状态\n         *.Highlighted:按钮高亮显示状态\n         *.Disabled:按钮关闭状态显示\n        **/\n        followButton.setTitle(\"关注\", forState: .Normal)\n        //设置按钮在特定状态下的文本色值显示\n        followButton.setTitleColor(UIColor.whiteColor(), forState: .Normal)\n        //设置按钮在特定状态下的图片显示\n        followButton.setImage(UIImage(named: \"back\"), forState: .Normal)\n        followButton.setImage(UIImage(named: \"select\"), forState: .Disabled)\n        //设置按钮显示文本的字体大小\n        followButton.titleLabel?.font = UIFont.systemFontOfSize(15)\n        //设置按钮选中状态\n        followButton.selected = true\n        //设置按钮是否打开状态\n        followButton.enabled = true\n        //设置是否响应用户touch事件\n        followButton.userInteractionEnabled = true\n        //设置按钮的背景颜色\n        followButton.backgroundColor = UIColor.grayColor()\n        //关闭按钮处于高亮状态图片变暗显示状态\n        followButton.adjustsImageWhenHighlighted = false\n        //设置按钮图片的内部填充\n        followButton.imageEdgeInsets = UIEdgeInsetsMake(10, 10, 10, 10)\n        //设置按钮文本的内部填充\n        followButton.titleEdgeInsets = UIEdgeInsetsMake(10, 10, 10, 10)\n        //为按钮添加点击事件\n        followButton.addTarget(self, action: \"followAction\", forControlEvents: .TouchUpInside)\n        view.addSubview(followButton)\n```\n\n* 按钮点击事件响应方法：\n\n```\n    func followAction(sender: UIButton) {\n        print(\"关注\")\n    }\n\n```\n3、图片展示视图（UIImageView）：\n\n```\nlet imgView = UIImageView(frame: CGRectMake(0, 0, view.frame.size.width, view.frame.size.height))\n        //设置图片视图显示图片\n        imgView.image = UIImage(named: \"exam.png\")\n        //设置图片视图高亮状态显示图片\n        imgView.highlightedImage = UIImage(named: \"exam1.png\")\n        //设置图片视图内容展示模式：常见的几种内容展示模式\n        /**\n        *.ScaleToFill:缩放图片填满整个图片视图\n        *.ScaleAspectFit:缩放内容以适应原图尺寸，没有铺满的地方保持透明\n        *.ScaleAspectFill:按钮高亮显示状态\n        **/\n        imgView.contentMode = .ScaleAspectFit\n        //设置图片视图是否高亮显示\n        imgView.highlighted = true\n        //设置是否响应用户touch事件,默认为false\n        imgView.userInteractionEnabled = true\n        //播放一组图片\n        let img1 = UIImage(named: \"play1.png\")!\n        let img2 = UIImage(named: \"play2.png\")!\n        let img3 = UIImage(named: \"play3.png\")!\n        let images = [img1, img2, img3]\n        //设置需要播放的一组图片\n        imgView.animationImages = images\n        //设置播放持续时间\n        imgView.animationDuration = 1\n        //设置播放重复次数\n        imgView.animationRepeatCount = 20\n        //开始播放\n        imgView.startAnimating()\n        //停止播放\n        imgView.stopAnimating()\n        \n        view.addSubview(imgView);\n```\n\n4、文字输入框（UITextField）：\n\n```\nlet textField = UITextField(frame: CGRectMake(20, 100, 100,30))\n        //设置文本编辑框显示文字\n        textField.text = \"将编程进行到底\"\n        //设置文本编辑框占位文字\n        textField.placeholder = \"客官，你想不想要？\"\n        //设置文本编辑框的边框显示类型\n        textField.borderStyle = .RoundedRect\n        //设置文本编辑框的文字字体\n        textField.font = UIFont.systemFontOfSize(15)\n        //设置文本编辑框的文本颜色\n        textField.textColor = UIColor.blackColor()\n        //设置文本编辑框输入文本时首字母是否自动大写\n        textField.autocapitalizationType = .None\n        //设置文本编辑框清除按钮显示模式\n        textField.clearButtonMode = .WhileEditing\n        //设置文本编辑框的文本对齐方式\n        textField.textAlignment = .Center\n        //设置文本编辑框返回键显示类型\n        textField.returnKeyType = .Search\n        //设置是否为安全文本输入状态\n        textField.secureTextEntry = true\n        //设置输入键盘类型\n        textField.keyboardType = .NumberPad\n        //设置文本编辑框的代理\n        textField.delegate = self\n        //唤起键盘，让文本编辑框成为第一响应者\n        textField.becomeFirstResponder()\n        view.addSubview(textField)\n```\n* UITextFiled代理方法（UITextFiledDelegate）:\n\n```\n//将要开始编辑代理方法,此方法会在键盘弹出之前调用\n    func textFieldShouldBeginEditing(textField: UITextField) -> Bool {\n        return true\n    }\n    \n    //已经开始编辑代理方法，此方法会在键盘弹出之后调用\n    func textFieldDidBeginEditing(textField: UITextField) {\n        print(textField.text)\n    }\n    \n    //当return按钮被点击时调用\n    func textFieldShouldReturn(textField: UITextField) -> Bool {\n        //收起键盘，注销文本编辑框为第一响应者\n        textField.resignFirstResponder()\n        return true\n    }\n    \n    //将要结束编辑代理方法，此方法会在收起键盘的时候调用\n    func textFieldShouldEndEditing(textField: UITextField) -> Bool {\n        return true\n    }\n    \n```\n5、开关控件（UISwitch）：\n\n```\n        let sliderControl = UISlider(frame: CGRectMake(30, 200, 100, 30))\n        //设置滑动条控件最大值\n        sliderControl.maximumValue = 10\n        //设置滑动条控件最小值\n        sliderControl.minimumValue = 1\n        //设置滑动条控件初始值\n        sliderControl.value = 5\n        //设置滑动条控件最大值方向颜色显示\n        sliderControl.maximumTrackTintColor = UIColor.redColor()\n        //设置滑动条控件最小值方向颜色显示\n        sliderControl.minimumTrackTintColor = UIColor.brownColor()\n        //设置滑动条控件拖动按钮颜色\n        sliderControl.thumbTintColor = UIColor.blueColor()\n        //设置滑动条控件最大值方向图片显示：正常状态\n        sliderControl.setMaximumTrackImage(UIImage(named: \"slidermax.png\"), forState: .Normal)\n        //设置滑动条控件最小值方向图片显示：正常状态\n        sliderControl.setMinimumTrackImage(UIImage(named: \"slidermin.png\"), forState: .Normal)\n        //设置滑动条控件拖动按钮显示图片：正常状态\n        sliderControl.setThumbImage(UIImage(named: \"thumb.png\"), forState: .Normal)\n        //为滑动条控件添加：值改变触发事件\n        sliderControl.addTarget(self, action: \"sliderAction:\", forControlEvents: .ValueChanged)\n        view.addSubview(sliderControl)\n```\n\n* 开关值改变事件响应方法：\n\n```\nfunc sliderAction(sliderControl: UISlider) {\n        print(\"the slider value is \\(sliderControl.value)\")\n    }\n```\n\n6、加载指示器视图（UIActivityIndicatorView）：\n\n```\nlet activityControl = UIActivityIndicatorView(frame: CGRectMake(100, 200, 30, 30))\n        //设置加载指示器视图的风格\n        activityControl.activityIndicatorViewStyle = .Gray\n        //设置加载指示器视图的背景颜色\n        activityControl.backgroundColor = UIColor.redColor()\n        //开始动画\n        activityControl.startAnimating()\n        //停止动画\n        activityControl.stopAnimating()\n        view.addSubview(activityControl)\n```\n\n7、分段控件视图（UISegmentedControl）:\n\n```\nlet items = [\"全部\", \"电影\", \"新闻\", \"科技\"]\n        let segmentedControl = UISegmentedControl(items: items)\n        segmentedControl.frame = CGRectMake(30, 200, 180, 30)\n        //设置分段控件颜色\n        segmentedControl.tintColor = UIColor.redColor()\n        //设置分段控件默认选中索引\n        segmentedControl.selectedSegmentIndex = 1\n        //为分段控件添加值改变响应事件\n        segmentedControl.addTarget(self, action: \"segmentControlAction:\", forControlEvents: .ValueChanged)\n        view.addSubview(segmentedControl)\n```\n\n* 分段控件值改变事件响应方法：\n\n```\nfunc segmentControlAction(segmentedControl: UISegmentedControl) {\n        if segmentedControl.selectedSegmentIndex == 0 {\n\n        } else if segmentedControl.selectedSegmentIndex == 1 {\n\n        } else if segmentedControl.selectedSegmentIndex == 2{\n\n        } else {\n\n        }\n       print(\"the segmented Control selected Index is \\(segmentedControl.selectedSegmentIndex)\")\n    }\n```\n\n8、页面控件（UIPageControl）：\n\n```\nlet pageControl = UIPageControl(frame: CGRectMake(30, 200, 180, 30))\n        //设置页面控件的背景颜色\n        pageControl.backgroundColor = UIColor.brownColor()\n        //设置总页数\n        pageControl.numberOfPages = 4\n        //设置当前页数\n        pageControl.currentPage = 1\n        //设置页面控件指示器颜色\n        pageControl.pageIndicatorTintColor = UIColor.redColor()\n        //设置页面控件当前页面指示器颜色\n        pageControl.currentPageIndicatorTintColor = UIColor.blueColor()\n        //添加页面控件点击响应事件\n        pageControl.addTarget(self, action: \"changeAction:\", forControlEvents: .TouchUpInside)\n        view.addSubview(pageControl)\n```\n\n* 页面控件点击响应事件：\n\n```\nfunc changeAction(pageControl: UIPageControl) {   \n  print(\"the current select page is :\\(pageControl.currentPage)\")\n}\n```  \n\n9、警告视图控制器（UIAlertController）：(UIAlertView 与 UIActionSheet在iOS8.0之后就弃用了，推荐使用UIAlertController)\n\n```\n        /**\n         * .Alert\n         * .ActionSheet\n         */\n        let alertCtrl = UIAlertController(title: \"提示信息\", message: \"确定返回吗？\", preferredStyle: .Alert)\n        //初始化警告动作\n        let cancelAction = UIAlertAction(title: \"取消\", style: .Cancel) { (action) -> Void in\n            //...\n            //添加相应处理代码\n            //...\n            //把UIAlertController从父视图控制器中移除，防止内存泄漏\n            alertCtrl.removeFromParentViewController()\n        }\n        let okAction = UIAlertAction(title: \"立即返回\", style: .Default) { (action) -> Void in\n            //...\n            //添加相应处理代码\n            //...\n            //把UIAlertController从父视图控制器中移除，防止内存泄漏\n            alertCtrl.removeFromParentViewController()\n        }\n        //添加动作\n        alertCtrl.addAction(cancelAction)\n        alertCtrl.addAction(okAction)\n        //弹出警告视图控制器\n        self.presentViewController(alertCtrl, animated: true, completion: nil)\n```\n\n10、 进度条视图（UIProgressView）：\n\n```\n     let progressView = UIProgressView(progressViewStyle: .Bar)\n        progressView.frame = CGRectMake(30, 200, 180, 30)\n        //设置默认进度\n        progressView.progress = 0.3\n        //设置进度条加载过的颜色\n        progressView.progressTintColor = UIColor.redColor()\n        //设置进度条未加载过的颜色\n        progressView.trackTintColor = UIColor.blueColor()\n        //设置进度条加载过的图片展示\n        progressView.progressImage = UIImage(named: \"progress.png\")\n        //设置进度条未加载过的图片展示\n        progressView.trackImage = UIImage(named: \"track.png\")\n        view.addSubview(progressView)\n```\n\n11、 工具条控件（UIToolBar）：\n\n```\n        let toolBar = UIToolbar(frame: CGRectMake(30, 200, 180, 49))\n        //设置工具条展示风格\n        toolBar.barStyle = .Default\n        //添加工具条按钮\n        let item = UIBarButtonItem(barButtonSystemItem: .Done, target: self, action: \"itemButtonAction\")\n        let item1 = UIBarButtonItem(barButtonSystemItem: .Edit, target: self, action: \"itemButtonAction\")\n        //固定间距工具条按钮\n        let item2 = UIBarButtonItem(barButtonSystemItem: .FixedSpace, target: self, action: \"itemButtonAction\")\n        item2.width = 30\n        let customButton = UIButton(type: .DetailDisclosure)\n        customButton.addTarget(self, action: \"itemButtonAction\", forControlEvents: .TouchUpInside)\n        //自定义按钮为工具条按钮\n        let item3 = UIBarButtonItem(customView: customButton)\n        let items = [item, item1, item2, item3]\n        //设置工具条要显示的所有按钮\n        toolBar.items = items\n        view.addSubview(toolBar)\n```\n\n* 工具条按钮点击响应事件：\n\n```\nfunc itemButtonAction() {\n        print(\"tool bar button\")\n    }\n```\n\n","source":"_posts/2016-01-02-ioskai-fa-zhi-ji-chu-kong-jian-(swiftban-).markdown","raw":"---\nlayout: post\ntitle: \"iOS开发之基础控件（Swift版）\"\ndate: 2016-01-02 11:08:19 +0800\ncomments: true\ntags: [iOS, Xcode, Swift]\nkeywords: iOS开发, 基础控件, Swift\ncategories: Swift\n---\n  1、文本（UILabel）：\n  \n```\n  let titleLabel = UILabel(frame: CGRectMake(0, 0, view.frame.size.width, view.frame.size.height))\n        //设置titleLabel的文本对齐方式：左：.Left, 中:.Center, 右:.Right\n        titleLabel.textAlignment = .Center\n        //设置titleLabel的文本颜色\n        titleLabel.textColor = UIColor.lightGrayColor()\n        //设置titleLabel文字的字体为系统字体，大小为15\n        titleLabel.font = UIFont.systemFontOfSize(15)\n        //设置titleLabel文字的字体为\"Helvetica\", 大小为15\n        titleLabel.font = UIFont(name: \"Helvetica\", size: 15)\n        titleLabel.text = \"心灵鸡汤，每天一起干\"\n        //titleLabel字体大小自适应宽度，根据指定宽度titleLabel自动调整字体显示大小\n        titleLabel.adjustsFontSizeToFitWidth = true\n        //指定titleLabel的显示行数，0代表自动折行\n        titleLabel.numberOfLines = 1\n        //获取系统所有字体名称\n        let fontFamily = UIFont.familyNames()\n        print(fontFamily)\n        view.addSubview(titleLabel)\n```\n<!--more-->\n2、按钮（UIButton）：\n\n```\n//按钮类型：常见的两种如下\n         /**\n         *.Custom:自定义类型\n         *.System:系统类型（iOS7.0）\n         **/\n        let followButton = UIButton(type: .Custom)\n        followButton.frame = CGRectMake(100, 100, 100, 50)\n        //设置按钮在特定状态下的文本显示，常见的有：\n        /**\n         *.Normal:按钮常规显示状态\n         *.Selected:按钮选中显示状态\n         *.Highlighted:按钮高亮显示状态\n         *.Disabled:按钮关闭状态显示\n        **/\n        followButton.setTitle(\"关注\", forState: .Normal)\n        //设置按钮在特定状态下的文本色值显示\n        followButton.setTitleColor(UIColor.whiteColor(), forState: .Normal)\n        //设置按钮在特定状态下的图片显示\n        followButton.setImage(UIImage(named: \"back\"), forState: .Normal)\n        followButton.setImage(UIImage(named: \"select\"), forState: .Disabled)\n        //设置按钮显示文本的字体大小\n        followButton.titleLabel?.font = UIFont.systemFontOfSize(15)\n        //设置按钮选中状态\n        followButton.selected = true\n        //设置按钮是否打开状态\n        followButton.enabled = true\n        //设置是否响应用户touch事件\n        followButton.userInteractionEnabled = true\n        //设置按钮的背景颜色\n        followButton.backgroundColor = UIColor.grayColor()\n        //关闭按钮处于高亮状态图片变暗显示状态\n        followButton.adjustsImageWhenHighlighted = false\n        //设置按钮图片的内部填充\n        followButton.imageEdgeInsets = UIEdgeInsetsMake(10, 10, 10, 10)\n        //设置按钮文本的内部填充\n        followButton.titleEdgeInsets = UIEdgeInsetsMake(10, 10, 10, 10)\n        //为按钮添加点击事件\n        followButton.addTarget(self, action: \"followAction\", forControlEvents: .TouchUpInside)\n        view.addSubview(followButton)\n```\n\n* 按钮点击事件响应方法：\n\n```\n    func followAction(sender: UIButton) {\n        print(\"关注\")\n    }\n\n```\n3、图片展示视图（UIImageView）：\n\n```\nlet imgView = UIImageView(frame: CGRectMake(0, 0, view.frame.size.width, view.frame.size.height))\n        //设置图片视图显示图片\n        imgView.image = UIImage(named: \"exam.png\")\n        //设置图片视图高亮状态显示图片\n        imgView.highlightedImage = UIImage(named: \"exam1.png\")\n        //设置图片视图内容展示模式：常见的几种内容展示模式\n        /**\n        *.ScaleToFill:缩放图片填满整个图片视图\n        *.ScaleAspectFit:缩放内容以适应原图尺寸，没有铺满的地方保持透明\n        *.ScaleAspectFill:按钮高亮显示状态\n        **/\n        imgView.contentMode = .ScaleAspectFit\n        //设置图片视图是否高亮显示\n        imgView.highlighted = true\n        //设置是否响应用户touch事件,默认为false\n        imgView.userInteractionEnabled = true\n        //播放一组图片\n        let img1 = UIImage(named: \"play1.png\")!\n        let img2 = UIImage(named: \"play2.png\")!\n        let img3 = UIImage(named: \"play3.png\")!\n        let images = [img1, img2, img3]\n        //设置需要播放的一组图片\n        imgView.animationImages = images\n        //设置播放持续时间\n        imgView.animationDuration = 1\n        //设置播放重复次数\n        imgView.animationRepeatCount = 20\n        //开始播放\n        imgView.startAnimating()\n        //停止播放\n        imgView.stopAnimating()\n        \n        view.addSubview(imgView);\n```\n\n4、文字输入框（UITextField）：\n\n```\nlet textField = UITextField(frame: CGRectMake(20, 100, 100,30))\n        //设置文本编辑框显示文字\n        textField.text = \"将编程进行到底\"\n        //设置文本编辑框占位文字\n        textField.placeholder = \"客官，你想不想要？\"\n        //设置文本编辑框的边框显示类型\n        textField.borderStyle = .RoundedRect\n        //设置文本编辑框的文字字体\n        textField.font = UIFont.systemFontOfSize(15)\n        //设置文本编辑框的文本颜色\n        textField.textColor = UIColor.blackColor()\n        //设置文本编辑框输入文本时首字母是否自动大写\n        textField.autocapitalizationType = .None\n        //设置文本编辑框清除按钮显示模式\n        textField.clearButtonMode = .WhileEditing\n        //设置文本编辑框的文本对齐方式\n        textField.textAlignment = .Center\n        //设置文本编辑框返回键显示类型\n        textField.returnKeyType = .Search\n        //设置是否为安全文本输入状态\n        textField.secureTextEntry = true\n        //设置输入键盘类型\n        textField.keyboardType = .NumberPad\n        //设置文本编辑框的代理\n        textField.delegate = self\n        //唤起键盘，让文本编辑框成为第一响应者\n        textField.becomeFirstResponder()\n        view.addSubview(textField)\n```\n* UITextFiled代理方法（UITextFiledDelegate）:\n\n```\n//将要开始编辑代理方法,此方法会在键盘弹出之前调用\n    func textFieldShouldBeginEditing(textField: UITextField) -> Bool {\n        return true\n    }\n    \n    //已经开始编辑代理方法，此方法会在键盘弹出之后调用\n    func textFieldDidBeginEditing(textField: UITextField) {\n        print(textField.text)\n    }\n    \n    //当return按钮被点击时调用\n    func textFieldShouldReturn(textField: UITextField) -> Bool {\n        //收起键盘，注销文本编辑框为第一响应者\n        textField.resignFirstResponder()\n        return true\n    }\n    \n    //将要结束编辑代理方法，此方法会在收起键盘的时候调用\n    func textFieldShouldEndEditing(textField: UITextField) -> Bool {\n        return true\n    }\n    \n```\n5、开关控件（UISwitch）：\n\n```\n        let sliderControl = UISlider(frame: CGRectMake(30, 200, 100, 30))\n        //设置滑动条控件最大值\n        sliderControl.maximumValue = 10\n        //设置滑动条控件最小值\n        sliderControl.minimumValue = 1\n        //设置滑动条控件初始值\n        sliderControl.value = 5\n        //设置滑动条控件最大值方向颜色显示\n        sliderControl.maximumTrackTintColor = UIColor.redColor()\n        //设置滑动条控件最小值方向颜色显示\n        sliderControl.minimumTrackTintColor = UIColor.brownColor()\n        //设置滑动条控件拖动按钮颜色\n        sliderControl.thumbTintColor = UIColor.blueColor()\n        //设置滑动条控件最大值方向图片显示：正常状态\n        sliderControl.setMaximumTrackImage(UIImage(named: \"slidermax.png\"), forState: .Normal)\n        //设置滑动条控件最小值方向图片显示：正常状态\n        sliderControl.setMinimumTrackImage(UIImage(named: \"slidermin.png\"), forState: .Normal)\n        //设置滑动条控件拖动按钮显示图片：正常状态\n        sliderControl.setThumbImage(UIImage(named: \"thumb.png\"), forState: .Normal)\n        //为滑动条控件添加：值改变触发事件\n        sliderControl.addTarget(self, action: \"sliderAction:\", forControlEvents: .ValueChanged)\n        view.addSubview(sliderControl)\n```\n\n* 开关值改变事件响应方法：\n\n```\nfunc sliderAction(sliderControl: UISlider) {\n        print(\"the slider value is \\(sliderControl.value)\")\n    }\n```\n\n6、加载指示器视图（UIActivityIndicatorView）：\n\n```\nlet activityControl = UIActivityIndicatorView(frame: CGRectMake(100, 200, 30, 30))\n        //设置加载指示器视图的风格\n        activityControl.activityIndicatorViewStyle = .Gray\n        //设置加载指示器视图的背景颜色\n        activityControl.backgroundColor = UIColor.redColor()\n        //开始动画\n        activityControl.startAnimating()\n        //停止动画\n        activityControl.stopAnimating()\n        view.addSubview(activityControl)\n```\n\n7、分段控件视图（UISegmentedControl）:\n\n```\nlet items = [\"全部\", \"电影\", \"新闻\", \"科技\"]\n        let segmentedControl = UISegmentedControl(items: items)\n        segmentedControl.frame = CGRectMake(30, 200, 180, 30)\n        //设置分段控件颜色\n        segmentedControl.tintColor = UIColor.redColor()\n        //设置分段控件默认选中索引\n        segmentedControl.selectedSegmentIndex = 1\n        //为分段控件添加值改变响应事件\n        segmentedControl.addTarget(self, action: \"segmentControlAction:\", forControlEvents: .ValueChanged)\n        view.addSubview(segmentedControl)\n```\n\n* 分段控件值改变事件响应方法：\n\n```\nfunc segmentControlAction(segmentedControl: UISegmentedControl) {\n        if segmentedControl.selectedSegmentIndex == 0 {\n\n        } else if segmentedControl.selectedSegmentIndex == 1 {\n\n        } else if segmentedControl.selectedSegmentIndex == 2{\n\n        } else {\n\n        }\n       print(\"the segmented Control selected Index is \\(segmentedControl.selectedSegmentIndex)\")\n    }\n```\n\n8、页面控件（UIPageControl）：\n\n```\nlet pageControl = UIPageControl(frame: CGRectMake(30, 200, 180, 30))\n        //设置页面控件的背景颜色\n        pageControl.backgroundColor = UIColor.brownColor()\n        //设置总页数\n        pageControl.numberOfPages = 4\n        //设置当前页数\n        pageControl.currentPage = 1\n        //设置页面控件指示器颜色\n        pageControl.pageIndicatorTintColor = UIColor.redColor()\n        //设置页面控件当前页面指示器颜色\n        pageControl.currentPageIndicatorTintColor = UIColor.blueColor()\n        //添加页面控件点击响应事件\n        pageControl.addTarget(self, action: \"changeAction:\", forControlEvents: .TouchUpInside)\n        view.addSubview(pageControl)\n```\n\n* 页面控件点击响应事件：\n\n```\nfunc changeAction(pageControl: UIPageControl) {   \n  print(\"the current select page is :\\(pageControl.currentPage)\")\n}\n```  \n\n9、警告视图控制器（UIAlertController）：(UIAlertView 与 UIActionSheet在iOS8.0之后就弃用了，推荐使用UIAlertController)\n\n```\n        /**\n         * .Alert\n         * .ActionSheet\n         */\n        let alertCtrl = UIAlertController(title: \"提示信息\", message: \"确定返回吗？\", preferredStyle: .Alert)\n        //初始化警告动作\n        let cancelAction = UIAlertAction(title: \"取消\", style: .Cancel) { (action) -> Void in\n            //...\n            //添加相应处理代码\n            //...\n            //把UIAlertController从父视图控制器中移除，防止内存泄漏\n            alertCtrl.removeFromParentViewController()\n        }\n        let okAction = UIAlertAction(title: \"立即返回\", style: .Default) { (action) -> Void in\n            //...\n            //添加相应处理代码\n            //...\n            //把UIAlertController从父视图控制器中移除，防止内存泄漏\n            alertCtrl.removeFromParentViewController()\n        }\n        //添加动作\n        alertCtrl.addAction(cancelAction)\n        alertCtrl.addAction(okAction)\n        //弹出警告视图控制器\n        self.presentViewController(alertCtrl, animated: true, completion: nil)\n```\n\n10、 进度条视图（UIProgressView）：\n\n```\n     let progressView = UIProgressView(progressViewStyle: .Bar)\n        progressView.frame = CGRectMake(30, 200, 180, 30)\n        //设置默认进度\n        progressView.progress = 0.3\n        //设置进度条加载过的颜色\n        progressView.progressTintColor = UIColor.redColor()\n        //设置进度条未加载过的颜色\n        progressView.trackTintColor = UIColor.blueColor()\n        //设置进度条加载过的图片展示\n        progressView.progressImage = UIImage(named: \"progress.png\")\n        //设置进度条未加载过的图片展示\n        progressView.trackImage = UIImage(named: \"track.png\")\n        view.addSubview(progressView)\n```\n\n11、 工具条控件（UIToolBar）：\n\n```\n        let toolBar = UIToolbar(frame: CGRectMake(30, 200, 180, 49))\n        //设置工具条展示风格\n        toolBar.barStyle = .Default\n        //添加工具条按钮\n        let item = UIBarButtonItem(barButtonSystemItem: .Done, target: self, action: \"itemButtonAction\")\n        let item1 = UIBarButtonItem(barButtonSystemItem: .Edit, target: self, action: \"itemButtonAction\")\n        //固定间距工具条按钮\n        let item2 = UIBarButtonItem(barButtonSystemItem: .FixedSpace, target: self, action: \"itemButtonAction\")\n        item2.width = 30\n        let customButton = UIButton(type: .DetailDisclosure)\n        customButton.addTarget(self, action: \"itemButtonAction\", forControlEvents: .TouchUpInside)\n        //自定义按钮为工具条按钮\n        let item3 = UIBarButtonItem(customView: customButton)\n        let items = [item, item1, item2, item3]\n        //设置工具条要显示的所有按钮\n        toolBar.items = items\n        view.addSubview(toolBar)\n```\n\n* 工具条按钮点击响应事件：\n\n```\nfunc itemButtonAction() {\n        print(\"tool bar button\")\n    }\n```\n\n","slug":"ioskai-fa-zhi-ji-chu-kong-jian-(swiftban-)","published":1,"updated":"2016-09-10T05:17:33.000Z","_id":"ciswie9d7000me3u27inh99nn","photos":[],"link":"","content":"<p>  1、文本（UILabel）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">let titleLabel = UILabel(frame: CGRectMake(0, 0, view.frame.size.width, view.frame.size.height))</div><div class=\"line\">      //设置titleLabel的文本对齐方式：左：.Left, 中:.Center, 右:.Right</div><div class=\"line\">      titleLabel.textAlignment = .Center</div><div class=\"line\">      //设置titleLabel的文本颜色</div><div class=\"line\">      titleLabel.textColor = UIColor.lightGrayColor()</div><div class=\"line\">      //设置titleLabel文字的字体为系统字体，大小为15</div><div class=\"line\">      titleLabel.font = UIFont.systemFontOfSize(15)</div><div class=\"line\">      //设置titleLabel文字的字体为&quot;Helvetica&quot;, 大小为15</div><div class=\"line\">      titleLabel.font = UIFont(name: &quot;Helvetica&quot;, size: 15)</div><div class=\"line\">      titleLabel.text = &quot;心灵鸡汤，每天一起干&quot;</div><div class=\"line\">      //titleLabel字体大小自适应宽度，根据指定宽度titleLabel自动调整字体显示大小</div><div class=\"line\">      titleLabel.adjustsFontSizeToFitWidth = true</div><div class=\"line\">      //指定titleLabel的显示行数，0代表自动折行</div><div class=\"line\">      titleLabel.numberOfLines = 1</div><div class=\"line\">      //获取系统所有字体名称</div><div class=\"line\">      let fontFamily = UIFont.familyNames()</div><div class=\"line\">      print(fontFamily)</div><div class=\"line\">      view.addSubview(titleLabel)</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>2、按钮（UIButton）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">//按钮类型：常见的两种如下</div><div class=\"line\">         /**</div><div class=\"line\">         *.Custom:自定义类型</div><div class=\"line\">         *.System:系统类型（iOS7.0）</div><div class=\"line\">         **/</div><div class=\"line\">        let followButton = UIButton(type: .Custom)</div><div class=\"line\">        followButton.frame = CGRectMake(100, 100, 100, 50)</div><div class=\"line\">        //设置按钮在特定状态下的文本显示，常见的有：</div><div class=\"line\">        /**</div><div class=\"line\">         *.Normal:按钮常规显示状态</div><div class=\"line\">         *.Selected:按钮选中显示状态</div><div class=\"line\">         *.Highlighted:按钮高亮显示状态</div><div class=\"line\">         *.Disabled:按钮关闭状态显示</div><div class=\"line\">        **/</div><div class=\"line\">        followButton.setTitle(&quot;关注&quot;, forState: .Normal)</div><div class=\"line\">        //设置按钮在特定状态下的文本色值显示</div><div class=\"line\">        followButton.setTitleColor(UIColor.whiteColor(), forState: .Normal)</div><div class=\"line\">        //设置按钮在特定状态下的图片显示</div><div class=\"line\">        followButton.setImage(UIImage(named: &quot;back&quot;), forState: .Normal)</div><div class=\"line\">        followButton.setImage(UIImage(named: &quot;select&quot;), forState: .Disabled)</div><div class=\"line\">        //设置按钮显示文本的字体大小</div><div class=\"line\">        followButton.titleLabel?.font = UIFont.systemFontOfSize(15)</div><div class=\"line\">        //设置按钮选中状态</div><div class=\"line\">        followButton.selected = true</div><div class=\"line\">        //设置按钮是否打开状态</div><div class=\"line\">        followButton.enabled = true</div><div class=\"line\">        //设置是否响应用户touch事件</div><div class=\"line\">        followButton.userInteractionEnabled = true</div><div class=\"line\">        //设置按钮的背景颜色</div><div class=\"line\">        followButton.backgroundColor = UIColor.grayColor()</div><div class=\"line\">        //关闭按钮处于高亮状态图片变暗显示状态</div><div class=\"line\">        followButton.adjustsImageWhenHighlighted = false</div><div class=\"line\">        //设置按钮图片的内部填充</div><div class=\"line\">        followButton.imageEdgeInsets = UIEdgeInsetsMake(10, 10, 10, 10)</div><div class=\"line\">        //设置按钮文本的内部填充</div><div class=\"line\">        followButton.titleEdgeInsets = UIEdgeInsetsMake(10, 10, 10, 10)</div><div class=\"line\">        //为按钮添加点击事件</div><div class=\"line\">        followButton.addTarget(self, action: &quot;followAction&quot;, forControlEvents: .TouchUpInside)</div><div class=\"line\">        view.addSubview(followButton)</div></pre></td></tr></table></figure>\n<ul>\n<li>按钮点击事件响应方法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">func followAction(sender: UIButton) &#123;</div><div class=\"line\">    print(&quot;关注&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>3、图片展示视图（UIImageView）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">let imgView = UIImageView(frame: CGRectMake(0, 0, view.frame.size.width, view.frame.size.height))</div><div class=\"line\">        //设置图片视图显示图片</div><div class=\"line\">        imgView.image = UIImage(named: &quot;exam.png&quot;)</div><div class=\"line\">        //设置图片视图高亮状态显示图片</div><div class=\"line\">        imgView.highlightedImage = UIImage(named: &quot;exam1.png&quot;)</div><div class=\"line\">        //设置图片视图内容展示模式：常见的几种内容展示模式</div><div class=\"line\">        /**</div><div class=\"line\">        *.ScaleToFill:缩放图片填满整个图片视图</div><div class=\"line\">        *.ScaleAspectFit:缩放内容以适应原图尺寸，没有铺满的地方保持透明</div><div class=\"line\">        *.ScaleAspectFill:按钮高亮显示状态</div><div class=\"line\">        **/</div><div class=\"line\">        imgView.contentMode = .ScaleAspectFit</div><div class=\"line\">        //设置图片视图是否高亮显示</div><div class=\"line\">        imgView.highlighted = true</div><div class=\"line\">        //设置是否响应用户touch事件,默认为false</div><div class=\"line\">        imgView.userInteractionEnabled = true</div><div class=\"line\">        //播放一组图片</div><div class=\"line\">        let img1 = UIImage(named: &quot;play1.png&quot;)!</div><div class=\"line\">        let img2 = UIImage(named: &quot;play2.png&quot;)!</div><div class=\"line\">        let img3 = UIImage(named: &quot;play3.png&quot;)!</div><div class=\"line\">        let images = [img1, img2, img3]</div><div class=\"line\">        //设置需要播放的一组图片</div><div class=\"line\">        imgView.animationImages = images</div><div class=\"line\">        //设置播放持续时间</div><div class=\"line\">        imgView.animationDuration = 1</div><div class=\"line\">        //设置播放重复次数</div><div class=\"line\">        imgView.animationRepeatCount = 20</div><div class=\"line\">        //开始播放</div><div class=\"line\">        imgView.startAnimating()</div><div class=\"line\">        //停止播放</div><div class=\"line\">        imgView.stopAnimating()</div><div class=\"line\">        </div><div class=\"line\">        view.addSubview(imgView);</div></pre></td></tr></table></figure>\n<p>4、文字输入框（UITextField）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">let textField = UITextField(frame: CGRectMake(20, 100, 100,30))</div><div class=\"line\">        //设置文本编辑框显示文字</div><div class=\"line\">        textField.text = &quot;将编程进行到底&quot;</div><div class=\"line\">        //设置文本编辑框占位文字</div><div class=\"line\">        textField.placeholder = &quot;客官，你想不想要？&quot;</div><div class=\"line\">        //设置文本编辑框的边框显示类型</div><div class=\"line\">        textField.borderStyle = .RoundedRect</div><div class=\"line\">        //设置文本编辑框的文字字体</div><div class=\"line\">        textField.font = UIFont.systemFontOfSize(15)</div><div class=\"line\">        //设置文本编辑框的文本颜色</div><div class=\"line\">        textField.textColor = UIColor.blackColor()</div><div class=\"line\">        //设置文本编辑框输入文本时首字母是否自动大写</div><div class=\"line\">        textField.autocapitalizationType = .None</div><div class=\"line\">        //设置文本编辑框清除按钮显示模式</div><div class=\"line\">        textField.clearButtonMode = .WhileEditing</div><div class=\"line\">        //设置文本编辑框的文本对齐方式</div><div class=\"line\">        textField.textAlignment = .Center</div><div class=\"line\">        //设置文本编辑框返回键显示类型</div><div class=\"line\">        textField.returnKeyType = .Search</div><div class=\"line\">        //设置是否为安全文本输入状态</div><div class=\"line\">        textField.secureTextEntry = true</div><div class=\"line\">        //设置输入键盘类型</div><div class=\"line\">        textField.keyboardType = .NumberPad</div><div class=\"line\">        //设置文本编辑框的代理</div><div class=\"line\">        textField.delegate = self</div><div class=\"line\">        //唤起键盘，让文本编辑框成为第一响应者</div><div class=\"line\">        textField.becomeFirstResponder()</div><div class=\"line\">        view.addSubview(textField)</div></pre></td></tr></table></figure>\n<ul>\n<li>UITextFiled代理方法（UITextFiledDelegate）:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//将要开始编辑代理方法,此方法会在键盘弹出之前调用</div><div class=\"line\">    func textFieldShouldBeginEditing(textField: UITextField) -&gt; Bool &#123;</div><div class=\"line\">        return true</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //已经开始编辑代理方法，此方法会在键盘弹出之后调用</div><div class=\"line\">    func textFieldDidBeginEditing(textField: UITextField) &#123;</div><div class=\"line\">        print(textField.text)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //当return按钮被点击时调用</div><div class=\"line\">    func textFieldShouldReturn(textField: UITextField) -&gt; Bool &#123;</div><div class=\"line\">        //收起键盘，注销文本编辑框为第一响应者</div><div class=\"line\">        textField.resignFirstResponder()</div><div class=\"line\">        return true</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //将要结束编辑代理方法，此方法会在收起键盘的时候调用</div><div class=\"line\">    func textFieldShouldEndEditing(textField: UITextField) -&gt; Bool &#123;</div><div class=\"line\">        return true</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>5、开关控件（UISwitch）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">let sliderControl = UISlider(frame: CGRectMake(30, 200, 100, 30))</div><div class=\"line\">//设置滑动条控件最大值</div><div class=\"line\">sliderControl.maximumValue = 10</div><div class=\"line\">//设置滑动条控件最小值</div><div class=\"line\">sliderControl.minimumValue = 1</div><div class=\"line\">//设置滑动条控件初始值</div><div class=\"line\">sliderControl.value = 5</div><div class=\"line\">//设置滑动条控件最大值方向颜色显示</div><div class=\"line\">sliderControl.maximumTrackTintColor = UIColor.redColor()</div><div class=\"line\">//设置滑动条控件最小值方向颜色显示</div><div class=\"line\">sliderControl.minimumTrackTintColor = UIColor.brownColor()</div><div class=\"line\">//设置滑动条控件拖动按钮颜色</div><div class=\"line\">sliderControl.thumbTintColor = UIColor.blueColor()</div><div class=\"line\">//设置滑动条控件最大值方向图片显示：正常状态</div><div class=\"line\">sliderControl.setMaximumTrackImage(UIImage(named: &quot;slidermax.png&quot;), forState: .Normal)</div><div class=\"line\">//设置滑动条控件最小值方向图片显示：正常状态</div><div class=\"line\">sliderControl.setMinimumTrackImage(UIImage(named: &quot;slidermin.png&quot;), forState: .Normal)</div><div class=\"line\">//设置滑动条控件拖动按钮显示图片：正常状态</div><div class=\"line\">sliderControl.setThumbImage(UIImage(named: &quot;thumb.png&quot;), forState: .Normal)</div><div class=\"line\">//为滑动条控件添加：值改变触发事件</div><div class=\"line\">sliderControl.addTarget(self, action: &quot;sliderAction:&quot;, forControlEvents: .ValueChanged)</div><div class=\"line\">view.addSubview(sliderControl)</div></pre></td></tr></table></figure>\n<ul>\n<li>开关值改变事件响应方法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">func sliderAction(sliderControl: UISlider) &#123;</div><div class=\"line\">        print(&quot;the slider value is \\(sliderControl.value)&quot;)</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>6、加载指示器视图（UIActivityIndicatorView）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">let activityControl = UIActivityIndicatorView(frame: CGRectMake(100, 200, 30, 30))</div><div class=\"line\">        //设置加载指示器视图的风格</div><div class=\"line\">        activityControl.activityIndicatorViewStyle = .Gray</div><div class=\"line\">        //设置加载指示器视图的背景颜色</div><div class=\"line\">        activityControl.backgroundColor = UIColor.redColor()</div><div class=\"line\">        //开始动画</div><div class=\"line\">        activityControl.startAnimating()</div><div class=\"line\">        //停止动画</div><div class=\"line\">        activityControl.stopAnimating()</div><div class=\"line\">        view.addSubview(activityControl)</div></pre></td></tr></table></figure>\n<p>7、分段控件视图（UISegmentedControl）:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">let items = [&quot;全部&quot;, &quot;电影&quot;, &quot;新闻&quot;, &quot;科技&quot;]</div><div class=\"line\">        let segmentedControl = UISegmentedControl(items: items)</div><div class=\"line\">        segmentedControl.frame = CGRectMake(30, 200, 180, 30)</div><div class=\"line\">        //设置分段控件颜色</div><div class=\"line\">        segmentedControl.tintColor = UIColor.redColor()</div><div class=\"line\">        //设置分段控件默认选中索引</div><div class=\"line\">        segmentedControl.selectedSegmentIndex = 1</div><div class=\"line\">        //为分段控件添加值改变响应事件</div><div class=\"line\">        segmentedControl.addTarget(self, action: &quot;segmentControlAction:&quot;, forControlEvents: .ValueChanged)</div><div class=\"line\">        view.addSubview(segmentedControl)</div></pre></td></tr></table></figure>\n<ul>\n<li>分段控件值改变事件响应方法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">func segmentControlAction(segmentedControl: UISegmentedControl) &#123;</div><div class=\"line\">        if segmentedControl.selectedSegmentIndex == 0 &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125; else if segmentedControl.selectedSegmentIndex == 1 &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125; else if segmentedControl.selectedSegmentIndex == 2&#123;</div><div class=\"line\"></div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">       print(&quot;the segmented Control selected Index is \\(segmentedControl.selectedSegmentIndex)&quot;)</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>8、页面控件（UIPageControl）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">let pageControl = UIPageControl(frame: CGRectMake(30, 200, 180, 30))</div><div class=\"line\">        //设置页面控件的背景颜色</div><div class=\"line\">        pageControl.backgroundColor = UIColor.brownColor()</div><div class=\"line\">        //设置总页数</div><div class=\"line\">        pageControl.numberOfPages = 4</div><div class=\"line\">        //设置当前页数</div><div class=\"line\">        pageControl.currentPage = 1</div><div class=\"line\">        //设置页面控件指示器颜色</div><div class=\"line\">        pageControl.pageIndicatorTintColor = UIColor.redColor()</div><div class=\"line\">        //设置页面控件当前页面指示器颜色</div><div class=\"line\">        pageControl.currentPageIndicatorTintColor = UIColor.blueColor()</div><div class=\"line\">        //添加页面控件点击响应事件</div><div class=\"line\">        pageControl.addTarget(self, action: &quot;changeAction:&quot;, forControlEvents: .TouchUpInside)</div><div class=\"line\">        view.addSubview(pageControl)</div></pre></td></tr></table></figure>\n<ul>\n<li>页面控件点击响应事件：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func changeAction(pageControl: UIPageControl) &#123;   </div><div class=\"line\">  print(&quot;the current select page is :\\(pageControl.currentPage)&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\">```  </div><div class=\"line\"></div><div class=\"line\">9、警告视图控制器（UIAlertController）：(UIAlertView 与 UIActionSheet在iOS8.0之后就弃用了，推荐使用UIAlertController)</div></pre></td></tr></table></figure>\n<pre><code>/**\n * .Alert\n * .ActionSheet\n */\nlet alertCtrl = UIAlertController(title: &quot;提示信息&quot;, message: &quot;确定返回吗？&quot;, preferredStyle: .Alert)\n//初始化警告动作\nlet cancelAction = UIAlertAction(title: &quot;取消&quot;, style: .Cancel) { (action) -&gt; Void in\n    //...\n    //添加相应处理代码\n    //...\n    //把UIAlertController从父视图控制器中移除，防止内存泄漏\n    alertCtrl.removeFromParentViewController()\n}\nlet okAction = UIAlertAction(title: &quot;立即返回&quot;, style: .Default) { (action) -&gt; Void in\n    //...\n    //添加相应处理代码\n    //...\n    //把UIAlertController从父视图控制器中移除，防止内存泄漏\n    alertCtrl.removeFromParentViewController()\n}\n//添加动作\nalertCtrl.addAction(cancelAction)\nalertCtrl.addAction(okAction)\n//弹出警告视图控制器\nself.presentViewController(alertCtrl, animated: true, completion: nil)\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">10、 进度条视图（UIProgressView）：</div></pre></td></tr></table></figure>\n<pre><code>let progressView = UIProgressView(progressViewStyle: .Bar)\n   progressView.frame = CGRectMake(30, 200, 180, 30)\n   //设置默认进度\n   progressView.progress = 0.3\n   //设置进度条加载过的颜色\n   progressView.progressTintColor = UIColor.redColor()\n   //设置进度条未加载过的颜色\n   progressView.trackTintColor = UIColor.blueColor()\n   //设置进度条加载过的图片展示\n   progressView.progressImage = UIImage(named: &quot;progress.png&quot;)\n   //设置进度条未加载过的图片展示\n   progressView.trackImage = UIImage(named: &quot;track.png&quot;)\n   view.addSubview(progressView)\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">11、 工具条控件（UIToolBar）：</div></pre></td></tr></table></figure>\n<pre><code>let toolBar = UIToolbar(frame: CGRectMake(30, 200, 180, 49))\n//设置工具条展示风格\ntoolBar.barStyle = .Default\n//添加工具条按钮\nlet item = UIBarButtonItem(barButtonSystemItem: .Done, target: self, action: &quot;itemButtonAction&quot;)\nlet item1 = UIBarButtonItem(barButtonSystemItem: .Edit, target: self, action: &quot;itemButtonAction&quot;)\n//固定间距工具条按钮\nlet item2 = UIBarButtonItem(barButtonSystemItem: .FixedSpace, target: self, action: &quot;itemButtonAction&quot;)\nitem2.width = 30\nlet customButton = UIButton(type: .DetailDisclosure)\ncustomButton.addTarget(self, action: &quot;itemButtonAction&quot;, forControlEvents: .TouchUpInside)\n//自定义按钮为工具条按钮\nlet item3 = UIBarButtonItem(customView: customButton)\nlet items = [item, item1, item2, item3]\n//设置工具条要显示的所有按钮\ntoolBar.items = items\nview.addSubview(toolBar)\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">* 工具条按钮点击响应事件：</div></pre></td></tr></table></figure>\n<p>func itemButtonAction() {<br>        print(“tool bar button”)<br>    }<br>```</p>\n","excerpt":"<p>  1、文本（UILabel）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">let titleLabel = UILabel(frame: CGRectMake(0, 0, view.frame.size.width, view.frame.size.height))</div><div class=\"line\">      //设置titleLabel的文本对齐方式：左：.Left, 中:.Center, 右:.Right</div><div class=\"line\">      titleLabel.textAlignment = .Center</div><div class=\"line\">      //设置titleLabel的文本颜色</div><div class=\"line\">      titleLabel.textColor = UIColor.lightGrayColor()</div><div class=\"line\">      //设置titleLabel文字的字体为系统字体，大小为15</div><div class=\"line\">      titleLabel.font = UIFont.systemFontOfSize(15)</div><div class=\"line\">      //设置titleLabel文字的字体为&quot;Helvetica&quot;, 大小为15</div><div class=\"line\">      titleLabel.font = UIFont(name: &quot;Helvetica&quot;, size: 15)</div><div class=\"line\">      titleLabel.text = &quot;心灵鸡汤，每天一起干&quot;</div><div class=\"line\">      //titleLabel字体大小自适应宽度，根据指定宽度titleLabel自动调整字体显示大小</div><div class=\"line\">      titleLabel.adjustsFontSizeToFitWidth = true</div><div class=\"line\">      //指定titleLabel的显示行数，0代表自动折行</div><div class=\"line\">      titleLabel.numberOfLines = 1</div><div class=\"line\">      //获取系统所有字体名称</div><div class=\"line\">      let fontFamily = UIFont.familyNames()</div><div class=\"line\">      print(fontFamily)</div><div class=\"line\">      view.addSubview(titleLabel)</div></pre></td></tr></table></figure>","more":"<p>2、按钮（UIButton）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">//按钮类型：常见的两种如下</div><div class=\"line\">         /**</div><div class=\"line\">         *.Custom:自定义类型</div><div class=\"line\">         *.System:系统类型（iOS7.0）</div><div class=\"line\">         **/</div><div class=\"line\">        let followButton = UIButton(type: .Custom)</div><div class=\"line\">        followButton.frame = CGRectMake(100, 100, 100, 50)</div><div class=\"line\">        //设置按钮在特定状态下的文本显示，常见的有：</div><div class=\"line\">        /**</div><div class=\"line\">         *.Normal:按钮常规显示状态</div><div class=\"line\">         *.Selected:按钮选中显示状态</div><div class=\"line\">         *.Highlighted:按钮高亮显示状态</div><div class=\"line\">         *.Disabled:按钮关闭状态显示</div><div class=\"line\">        **/</div><div class=\"line\">        followButton.setTitle(&quot;关注&quot;, forState: .Normal)</div><div class=\"line\">        //设置按钮在特定状态下的文本色值显示</div><div class=\"line\">        followButton.setTitleColor(UIColor.whiteColor(), forState: .Normal)</div><div class=\"line\">        //设置按钮在特定状态下的图片显示</div><div class=\"line\">        followButton.setImage(UIImage(named: &quot;back&quot;), forState: .Normal)</div><div class=\"line\">        followButton.setImage(UIImage(named: &quot;select&quot;), forState: .Disabled)</div><div class=\"line\">        //设置按钮显示文本的字体大小</div><div class=\"line\">        followButton.titleLabel?.font = UIFont.systemFontOfSize(15)</div><div class=\"line\">        //设置按钮选中状态</div><div class=\"line\">        followButton.selected = true</div><div class=\"line\">        //设置按钮是否打开状态</div><div class=\"line\">        followButton.enabled = true</div><div class=\"line\">        //设置是否响应用户touch事件</div><div class=\"line\">        followButton.userInteractionEnabled = true</div><div class=\"line\">        //设置按钮的背景颜色</div><div class=\"line\">        followButton.backgroundColor = UIColor.grayColor()</div><div class=\"line\">        //关闭按钮处于高亮状态图片变暗显示状态</div><div class=\"line\">        followButton.adjustsImageWhenHighlighted = false</div><div class=\"line\">        //设置按钮图片的内部填充</div><div class=\"line\">        followButton.imageEdgeInsets = UIEdgeInsetsMake(10, 10, 10, 10)</div><div class=\"line\">        //设置按钮文本的内部填充</div><div class=\"line\">        followButton.titleEdgeInsets = UIEdgeInsetsMake(10, 10, 10, 10)</div><div class=\"line\">        //为按钮添加点击事件</div><div class=\"line\">        followButton.addTarget(self, action: &quot;followAction&quot;, forControlEvents: .TouchUpInside)</div><div class=\"line\">        view.addSubview(followButton)</div></pre></td></tr></table></figure>\n<ul>\n<li>按钮点击事件响应方法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">func followAction(sender: UIButton) &#123;</div><div class=\"line\">    print(&quot;关注&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>3、图片展示视图（UIImageView）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">let imgView = UIImageView(frame: CGRectMake(0, 0, view.frame.size.width, view.frame.size.height))</div><div class=\"line\">        //设置图片视图显示图片</div><div class=\"line\">        imgView.image = UIImage(named: &quot;exam.png&quot;)</div><div class=\"line\">        //设置图片视图高亮状态显示图片</div><div class=\"line\">        imgView.highlightedImage = UIImage(named: &quot;exam1.png&quot;)</div><div class=\"line\">        //设置图片视图内容展示模式：常见的几种内容展示模式</div><div class=\"line\">        /**</div><div class=\"line\">        *.ScaleToFill:缩放图片填满整个图片视图</div><div class=\"line\">        *.ScaleAspectFit:缩放内容以适应原图尺寸，没有铺满的地方保持透明</div><div class=\"line\">        *.ScaleAspectFill:按钮高亮显示状态</div><div class=\"line\">        **/</div><div class=\"line\">        imgView.contentMode = .ScaleAspectFit</div><div class=\"line\">        //设置图片视图是否高亮显示</div><div class=\"line\">        imgView.highlighted = true</div><div class=\"line\">        //设置是否响应用户touch事件,默认为false</div><div class=\"line\">        imgView.userInteractionEnabled = true</div><div class=\"line\">        //播放一组图片</div><div class=\"line\">        let img1 = UIImage(named: &quot;play1.png&quot;)!</div><div class=\"line\">        let img2 = UIImage(named: &quot;play2.png&quot;)!</div><div class=\"line\">        let img3 = UIImage(named: &quot;play3.png&quot;)!</div><div class=\"line\">        let images = [img1, img2, img3]</div><div class=\"line\">        //设置需要播放的一组图片</div><div class=\"line\">        imgView.animationImages = images</div><div class=\"line\">        //设置播放持续时间</div><div class=\"line\">        imgView.animationDuration = 1</div><div class=\"line\">        //设置播放重复次数</div><div class=\"line\">        imgView.animationRepeatCount = 20</div><div class=\"line\">        //开始播放</div><div class=\"line\">        imgView.startAnimating()</div><div class=\"line\">        //停止播放</div><div class=\"line\">        imgView.stopAnimating()</div><div class=\"line\">        </div><div class=\"line\">        view.addSubview(imgView);</div></pre></td></tr></table></figure>\n<p>4、文字输入框（UITextField）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">let textField = UITextField(frame: CGRectMake(20, 100, 100,30))</div><div class=\"line\">        //设置文本编辑框显示文字</div><div class=\"line\">        textField.text = &quot;将编程进行到底&quot;</div><div class=\"line\">        //设置文本编辑框占位文字</div><div class=\"line\">        textField.placeholder = &quot;客官，你想不想要？&quot;</div><div class=\"line\">        //设置文本编辑框的边框显示类型</div><div class=\"line\">        textField.borderStyle = .RoundedRect</div><div class=\"line\">        //设置文本编辑框的文字字体</div><div class=\"line\">        textField.font = UIFont.systemFontOfSize(15)</div><div class=\"line\">        //设置文本编辑框的文本颜色</div><div class=\"line\">        textField.textColor = UIColor.blackColor()</div><div class=\"line\">        //设置文本编辑框输入文本时首字母是否自动大写</div><div class=\"line\">        textField.autocapitalizationType = .None</div><div class=\"line\">        //设置文本编辑框清除按钮显示模式</div><div class=\"line\">        textField.clearButtonMode = .WhileEditing</div><div class=\"line\">        //设置文本编辑框的文本对齐方式</div><div class=\"line\">        textField.textAlignment = .Center</div><div class=\"line\">        //设置文本编辑框返回键显示类型</div><div class=\"line\">        textField.returnKeyType = .Search</div><div class=\"line\">        //设置是否为安全文本输入状态</div><div class=\"line\">        textField.secureTextEntry = true</div><div class=\"line\">        //设置输入键盘类型</div><div class=\"line\">        textField.keyboardType = .NumberPad</div><div class=\"line\">        //设置文本编辑框的代理</div><div class=\"line\">        textField.delegate = self</div><div class=\"line\">        //唤起键盘，让文本编辑框成为第一响应者</div><div class=\"line\">        textField.becomeFirstResponder()</div><div class=\"line\">        view.addSubview(textField)</div></pre></td></tr></table></figure>\n<ul>\n<li>UITextFiled代理方法（UITextFiledDelegate）:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//将要开始编辑代理方法,此方法会在键盘弹出之前调用</div><div class=\"line\">    func textFieldShouldBeginEditing(textField: UITextField) -&gt; Bool &#123;</div><div class=\"line\">        return true</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //已经开始编辑代理方法，此方法会在键盘弹出之后调用</div><div class=\"line\">    func textFieldDidBeginEditing(textField: UITextField) &#123;</div><div class=\"line\">        print(textField.text)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //当return按钮被点击时调用</div><div class=\"line\">    func textFieldShouldReturn(textField: UITextField) -&gt; Bool &#123;</div><div class=\"line\">        //收起键盘，注销文本编辑框为第一响应者</div><div class=\"line\">        textField.resignFirstResponder()</div><div class=\"line\">        return true</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //将要结束编辑代理方法，此方法会在收起键盘的时候调用</div><div class=\"line\">    func textFieldShouldEndEditing(textField: UITextField) -&gt; Bool &#123;</div><div class=\"line\">        return true</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>5、开关控件（UISwitch）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">let sliderControl = UISlider(frame: CGRectMake(30, 200, 100, 30))</div><div class=\"line\">//设置滑动条控件最大值</div><div class=\"line\">sliderControl.maximumValue = 10</div><div class=\"line\">//设置滑动条控件最小值</div><div class=\"line\">sliderControl.minimumValue = 1</div><div class=\"line\">//设置滑动条控件初始值</div><div class=\"line\">sliderControl.value = 5</div><div class=\"line\">//设置滑动条控件最大值方向颜色显示</div><div class=\"line\">sliderControl.maximumTrackTintColor = UIColor.redColor()</div><div class=\"line\">//设置滑动条控件最小值方向颜色显示</div><div class=\"line\">sliderControl.minimumTrackTintColor = UIColor.brownColor()</div><div class=\"line\">//设置滑动条控件拖动按钮颜色</div><div class=\"line\">sliderControl.thumbTintColor = UIColor.blueColor()</div><div class=\"line\">//设置滑动条控件最大值方向图片显示：正常状态</div><div class=\"line\">sliderControl.setMaximumTrackImage(UIImage(named: &quot;slidermax.png&quot;), forState: .Normal)</div><div class=\"line\">//设置滑动条控件最小值方向图片显示：正常状态</div><div class=\"line\">sliderControl.setMinimumTrackImage(UIImage(named: &quot;slidermin.png&quot;), forState: .Normal)</div><div class=\"line\">//设置滑动条控件拖动按钮显示图片：正常状态</div><div class=\"line\">sliderControl.setThumbImage(UIImage(named: &quot;thumb.png&quot;), forState: .Normal)</div><div class=\"line\">//为滑动条控件添加：值改变触发事件</div><div class=\"line\">sliderControl.addTarget(self, action: &quot;sliderAction:&quot;, forControlEvents: .ValueChanged)</div><div class=\"line\">view.addSubview(sliderControl)</div></pre></td></tr></table></figure>\n<ul>\n<li>开关值改变事件响应方法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">func sliderAction(sliderControl: UISlider) &#123;</div><div class=\"line\">        print(&quot;the slider value is \\(sliderControl.value)&quot;)</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>6、加载指示器视图（UIActivityIndicatorView）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">let activityControl = UIActivityIndicatorView(frame: CGRectMake(100, 200, 30, 30))</div><div class=\"line\">        //设置加载指示器视图的风格</div><div class=\"line\">        activityControl.activityIndicatorViewStyle = .Gray</div><div class=\"line\">        //设置加载指示器视图的背景颜色</div><div class=\"line\">        activityControl.backgroundColor = UIColor.redColor()</div><div class=\"line\">        //开始动画</div><div class=\"line\">        activityControl.startAnimating()</div><div class=\"line\">        //停止动画</div><div class=\"line\">        activityControl.stopAnimating()</div><div class=\"line\">        view.addSubview(activityControl)</div></pre></td></tr></table></figure>\n<p>7、分段控件视图（UISegmentedControl）:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">let items = [&quot;全部&quot;, &quot;电影&quot;, &quot;新闻&quot;, &quot;科技&quot;]</div><div class=\"line\">        let segmentedControl = UISegmentedControl(items: items)</div><div class=\"line\">        segmentedControl.frame = CGRectMake(30, 200, 180, 30)</div><div class=\"line\">        //设置分段控件颜色</div><div class=\"line\">        segmentedControl.tintColor = UIColor.redColor()</div><div class=\"line\">        //设置分段控件默认选中索引</div><div class=\"line\">        segmentedControl.selectedSegmentIndex = 1</div><div class=\"line\">        //为分段控件添加值改变响应事件</div><div class=\"line\">        segmentedControl.addTarget(self, action: &quot;segmentControlAction:&quot;, forControlEvents: .ValueChanged)</div><div class=\"line\">        view.addSubview(segmentedControl)</div></pre></td></tr></table></figure>\n<ul>\n<li>分段控件值改变事件响应方法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">func segmentControlAction(segmentedControl: UISegmentedControl) &#123;</div><div class=\"line\">        if segmentedControl.selectedSegmentIndex == 0 &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125; else if segmentedControl.selectedSegmentIndex == 1 &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125; else if segmentedControl.selectedSegmentIndex == 2&#123;</div><div class=\"line\"></div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">       print(&quot;the segmented Control selected Index is \\(segmentedControl.selectedSegmentIndex)&quot;)</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>8、页面控件（UIPageControl）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">let pageControl = UIPageControl(frame: CGRectMake(30, 200, 180, 30))</div><div class=\"line\">        //设置页面控件的背景颜色</div><div class=\"line\">        pageControl.backgroundColor = UIColor.brownColor()</div><div class=\"line\">        //设置总页数</div><div class=\"line\">        pageControl.numberOfPages = 4</div><div class=\"line\">        //设置当前页数</div><div class=\"line\">        pageControl.currentPage = 1</div><div class=\"line\">        //设置页面控件指示器颜色</div><div class=\"line\">        pageControl.pageIndicatorTintColor = UIColor.redColor()</div><div class=\"line\">        //设置页面控件当前页面指示器颜色</div><div class=\"line\">        pageControl.currentPageIndicatorTintColor = UIColor.blueColor()</div><div class=\"line\">        //添加页面控件点击响应事件</div><div class=\"line\">        pageControl.addTarget(self, action: &quot;changeAction:&quot;, forControlEvents: .TouchUpInside)</div><div class=\"line\">        view.addSubview(pageControl)</div></pre></td></tr></table></figure>\n<ul>\n<li>页面控件点击响应事件：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">func changeAction(pageControl: UIPageControl) &#123;   </div><div class=\"line\">  print(&quot;the current select page is :\\(pageControl.currentPage)&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\">```  </div><div class=\"line\"></div><div class=\"line\">9、警告视图控制器（UIAlertController）：(UIAlertView 与 UIActionSheet在iOS8.0之后就弃用了，推荐使用UIAlertController)</div></pre></td></tr></table></figure>\n<pre><code>/**\n * .Alert\n * .ActionSheet\n */\nlet alertCtrl = UIAlertController(title: &quot;提示信息&quot;, message: &quot;确定返回吗？&quot;, preferredStyle: .Alert)\n//初始化警告动作\nlet cancelAction = UIAlertAction(title: &quot;取消&quot;, style: .Cancel) { (action) -&gt; Void in\n    //...\n    //添加相应处理代码\n    //...\n    //把UIAlertController从父视图控制器中移除，防止内存泄漏\n    alertCtrl.removeFromParentViewController()\n}\nlet okAction = UIAlertAction(title: &quot;立即返回&quot;, style: .Default) { (action) -&gt; Void in\n    //...\n    //添加相应处理代码\n    //...\n    //把UIAlertController从父视图控制器中移除，防止内存泄漏\n    alertCtrl.removeFromParentViewController()\n}\n//添加动作\nalertCtrl.addAction(cancelAction)\nalertCtrl.addAction(okAction)\n//弹出警告视图控制器\nself.presentViewController(alertCtrl, animated: true, completion: nil)\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">10、 进度条视图（UIProgressView）：</div></pre></td></tr></table></figure>\n<pre><code>let progressView = UIProgressView(progressViewStyle: .Bar)\n   progressView.frame = CGRectMake(30, 200, 180, 30)\n   //设置默认进度\n   progressView.progress = 0.3\n   //设置进度条加载过的颜色\n   progressView.progressTintColor = UIColor.redColor()\n   //设置进度条未加载过的颜色\n   progressView.trackTintColor = UIColor.blueColor()\n   //设置进度条加载过的图片展示\n   progressView.progressImage = UIImage(named: &quot;progress.png&quot;)\n   //设置进度条未加载过的图片展示\n   progressView.trackImage = UIImage(named: &quot;track.png&quot;)\n   view.addSubview(progressView)\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">11、 工具条控件（UIToolBar）：</div></pre></td></tr></table></figure>\n<pre><code>let toolBar = UIToolbar(frame: CGRectMake(30, 200, 180, 49))\n//设置工具条展示风格\ntoolBar.barStyle = .Default\n//添加工具条按钮\nlet item = UIBarButtonItem(barButtonSystemItem: .Done, target: self, action: &quot;itemButtonAction&quot;)\nlet item1 = UIBarButtonItem(barButtonSystemItem: .Edit, target: self, action: &quot;itemButtonAction&quot;)\n//固定间距工具条按钮\nlet item2 = UIBarButtonItem(barButtonSystemItem: .FixedSpace, target: self, action: &quot;itemButtonAction&quot;)\nitem2.width = 30\nlet customButton = UIButton(type: .DetailDisclosure)\ncustomButton.addTarget(self, action: &quot;itemButtonAction&quot;, forControlEvents: .TouchUpInside)\n//自定义按钮为工具条按钮\nlet item3 = UIBarButtonItem(customView: customButton)\nlet items = [item, item1, item2, item3]\n//设置工具条要显示的所有按钮\ntoolBar.items = items\nview.addSubview(toolBar)\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">* 工具条按钮点击响应事件：</div></pre></td></tr></table></figure>\n<p>func itemButtonAction() {<br>        print(“tool bar button”)<br>    }<br>```</p>"},{"layout":"post","title":"iOS面试题系列之常见算法","date":"2016-04-24T15:59:06.000Z","comments":1,"keywords":"ios开发, ios面试","_content":"#### iOS面试中熟悉常见算法\n1、\t对以下一组数据进行降序排序（冒泡排序）。“24，17，85，13，9，54，76，45，5，63”\n\t\n<!--more-->\n\n``` \n\rint main(int argc, char *argv[]) {\n\r\tint array[10] = {24, 17, 85, 13, 9, 54, 76, 45, 5, 63};\n\t\r\tint num = sizeof(array)/sizeof(int);\n\t\r\tfor(int i = 0; i < num-1; i++) {\n\t\r\t\tfor(int j = 0; j < num - 1 - i; j++) {\n\t\t\r\t\t\tif(array[j] < array[j+1]) {\n\t\t\t\r\t\t\t\tint tmp = array[j];\n\t\t\t\t\r\t\t\t\tarray[j] = array[j+1];\n\t\t\t\t\r\t\t\t\tarray[j+1] = tmp;\n\t\t\t\t\r\t\t\t}\n\t\t\t\r\t\t}\n\t\t\r\t}\n\t\n\tfor(int i = 0; i < num; i++) {\n\t\r\t\tprintf(\"%d\", array[i]);\n\t\t\r\t\tif(i == num-1) {\n\t\t\r\t\t\tprintf(\"\\n\");\n\t\t\t\r\t\t}\n\t\t\r\t\telse {\n\t\t\r\t\t\tprintf(\" \");\n\t\t\t\r\t\t}\n\t\t\r\t}\n\t\r}\n\n```\n\n2、\t对以下一组数据进行升序排序（选择排序）。“86, 37, 56, 29, 92, 73, 15, 63, 30, 8”\n\n```\n\nvoid sort(int a[],int n)\n{\n\n    int i, j, index;\n    \n    for(i = 0; i < n - 1; i++) {\n        \n        index = i;\n        \n        for(j = i + 1; j < n; j++) {\n        \n            if(a[index] > a[j]) {\n            \n                index = j;\n                \n            }\n            \n        }\n        \n        if(index != i) {\n        \n            int temp = a[i];\n            \n            a[i] = a[index];\n            \n            a[index] = temp;\n            \n        }\n        \n    }\n    \n}\n\nint main(int argc, const char * argv[]) {\n\n    int numArr[10] = {86, 37, 56, 29, 92, 73, 15, 63, 30, 8};\n    \n    sort(numArr, 10);\n    \n    for (int i = 0; i < 10; i++) {\n    \n        printf(\"%d, \", numArr[i]);\n        \n    }\n    \n    printf(\"\\n\");\n    \n    return 0;\n    \n}\n\n```\n\n3、\t快速排序算法\n\n```\n\rvoid sort(int *a, int left, int right) {\n\rif(left >= right) {\n\rreturn ;\n\r}\n\rint i = left;\n\rint j = right;\n\rint key = a[left];\n\rwhile (i < j) {\n\rwhile (i < j && key >= a[j]) {\n\rj--;\n\r}\n\ra[i] = a[j];\n\rwhile (i < j && key <= a[i]) {\n\r\ti++;\n\t\r}\n\ra[j] = a[i];\n\r}\n\ra[i] = key;\n\rsort(a, left, i-1);\n\rsort(a, i+1, right);\n\r}\n\n```\n\n4、\t归并排序\n\n```\n\rvoid merge(int sourceArr[], int tempArr[], int startIndex, int midIndex, int endIndex) {\n\r    int i = startIndex;\n    \r    int j = midIndex + 1;\n    \r    int k = startIndex;\n    \r    while (i != midIndex + 1 && j != endIndex + 1) {\n    \r        if (sourceArr[i] >= sourceArr[j]) {\n        \r            tempArr[k++] = sourceArr[j++];\n            \r        } else {\n        \r            tempArr[k++] = sourceArr[i++];\n             \r        }\n        \r    }\r    \r    while (i != midIndex + 1) {\n    \r        tempArr[k++] = sourceArr[i++];\n        \r    }\r    \r    while (j != endIndex + 1) {\n    \r        tempArr[k++] = sourceArr[j++];\n        \r    }\r    \r    for (i = startIndex; i <= endIndex; i++) {\n    \r        sourceArr[i] = tempArr[i];\n        \r    }\n    \r}\n\n\rvoid sort(int souceArr[], int tempArr[], int startIndex, int endIndex) {\n\r    int midIndex;\n    \r    if (startIndex < endIndex) {\n    \r        midIndex = (startIndex + endIndex) / 2;\n        \r        sort(souceArr, tempArr, startIndex, midIndex);\n        \r        sort(souceArr, tempArr, midIndex + 1, endIndex);\n        \r        merge(souceArr, tempArr, startIndex, midIndex, endIndex);\n        \r    }\n    \r}\n\n\rint main(int argc, const char * argv[]) {\n\r    int numArr[10] = {86, 37, 56, 29, 92, 73, 15, 63, 30, 8};\n    \r    int tempArr[10];\n    \r    sort(numArr, tempArr, 0, 9);\n    \r    for (int i = 0; i < 10; i++) {\n    \r        printf(\"%d, \", numArr[i]);\n        \r    }\n    \r    printf(\"\\n\");\n    \r    return 0;\n    \r}\n\n```\n\n5、\t实现二分查找算法（编程语言不限）\n\n```\n\rint bsearchWithoutRecursion(int array[],int low,int high,int target) {\n\rwhile(low <= high) {\n\rint mid = (low + high) / 2;\n\rif(array[mid] > target)\n\rhigh = mid - 1;\n\relse if(array[mid] < target)\n\rlow = mid + 1;\n\relse\t//findthetarget\n\rreturn mid;\n\r}\n\r//the array does not contain the target\n\rreturn -1;\n\r}\n\r----------------------------------------\n\r递归实现\n\rint binary_search(const int arr[],int low,int high,int key)\r{\n\rint mid=low + (high - low) / 2;\n\rif(low > high)\n\rreturn -1;\n\relse{\n\rif(arr[mid] == key)\n\t\rreturn mid;\n\relse if(arr[mid] > key)\n\rreturn binary_search(arr, low, mid-1, key);\n\relse\n\rreturn binary_search(arr, mid+1, high, key);\n\r}\n\r}\n\n```\n\n6、\t如何实现链表翻转（链表逆序）？\r思路：每次把第二个元素提到最前面来。\n\n```\n\r#include <stdio.h>\n\r#include <stdlib.h>\n\r\rtypedef struct NODE {\n\r    struct NODE *next;\n    \r    int num;\n    \r}node;\n\n\rnode *createLinkList(int length) {\n\r    if (length <= 0) {\n    \r        return NULL;\n        \r    }\n    \r    node *head,*p,*q;\n    \r    int number = 1;\n    \r    head = (node *)malloc(sizeof(node));\n    \r    head->num = 1;\n    \r    head->next = head;\n    \r    p = q = head;\n    \r    while (++number <= length) {\n    \r        p = (node *)malloc(sizeof(node));\n        \r        p->num = number;\n        \r        p->next = NULL;\n        \r        q->next = p;\n        \r        q = p;\n        \r    }\n    \r    return head;\r}\n\n\rvoid printLinkList(node *head) {\n\r    if (head == NULL) {\n    \r        return;\n        \r    }\n    \r    node *p = head;\n    \r    while (p) {\n    \r        printf(\"%d \", p->num);\n        \r        p = p -> next;\n        \r    }\n    \r    printf(\"\\n\");\n    \r}\n\n\rnode *reverseFunc1(node *head) {\n\r    if (head == NULL) {\n    \r        return head;\n        \n        \r    }\n    \n    \r    node *p,*q;\n    \r    p = head;\n    \r    q = NULL;\n    \r    while (p) {\n    \r        node *pNext = p -> next;\n        \r        p -> next = q;\n        \r        q = p;\n        \r        p = pNext;\n        \r    }\n    \r    return q;\n    \r}\n\n\rint main(int argc, const char * argv[]) {\n\r    node *head = createLinkList(7);\n    \r    if (head) {\n    \r        printLinkList(head);\n        \r        node *reHead = reverseFunc1(head);\n        \r        printLinkList(reHead);\n        \r        free(reHead);\r    \n    }\n    \r    free(head);\n    \r    return 0;\n    \r}\n\n```\n\n7、\t实现一个字符串“how are you”的逆序输出（编程语言不限）。如给定字符串为“hello world”,输出结果应当为“world hello”。\n\n```\n\rint spliterFunc(char *p) {\n\r    char c[100][100];\n    \r    int i = 0;\n    \r    int j = 0;\n    \n    \r    while (*p != '\\0') {\n    \r        if (*p == ' ') {\n        \r            i++;\n            \r            j = 0;\n            \r        } else {\n        \r            c[i][j] = *p;\n            \r            j++;\n            \r        }\n        \r        p++;\r    \n    \n    }\n    \n    \r    for (int k = i; k >= 0; k--) {\n    \r        printf(\"%s\", c[k]);\n        \r        if (k > 0) {\n        \r            printf(\" \");\n            \r        } else {\n        \r            printf(\"\\n\");\n            \t\r        }\n        \r    }\r\r    return 0;\n    \n    \r}\n\n```\n\r8、\t给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？如“abaccddeeef”,字符是b,输出应该是2。\n\n```\n\nchar *strOutPut(char *);\n\n\rint compareDifferentChar(char, char *);\n\n\rint main(int argc, const char * argv[]) {\r    \n    \r    char *inputStr = \"abaccddeeef\";\n    \r    char *outputStr = strOutPut(inputStr);\n    \r    printf(\"%c \\n\", *outputStr);\n    \r    return 0;\n    \r}\n\n\rchar *strOutPut(char *s) {\n\r    char str[100];\n    \r    char *p = s;\n    \r    int index = 0;\n    \r    while (*s != '\\0') {\n    \r        if (compareDifferentChar(*s, p) == 1) {\n        \r            str[index] = *s;\n            \r            index++;\n            \r        }\n        \r        s++;\n        \r    }\n    \r    return &str;\r}\n\n\rint compareDifferentChar(char c, char *s) {\n\r    int i = 0;\n    \r    while (*s != '\\0' && i<= 1) {\n    \r        if (*s == c) {\n        \r            i++;\n            \r        }\n        \r        s++;\r    }\n    \r    if (i == 1) {\n    \r        return 1;\n        \r    } else {\n    \r        return 0;\n        \r    }\n    \r}\n\n```\n\n\r9、\t二叉树的先序遍历为FBACDEGH,中序遍历为：ABDCEFGH,请写出这个二叉树的后序遍历结果。\n\r**ADECBHGF**\n\n* 先序+中序遍历还原二叉树：先序遍历是：ABDEGCFH 中序遍历是：DBGEACHF\n\n首先从先序得到第一个为A，就是二叉树的根，回到中序，可以将其分为三部分：\n\n左子树的中序序列DBGE，根A，右子树的中序序列CHF\n\r接着将左子树的序列回到先序可以得到B为根，这样回到左子树的中序再次将左子树分割为三部分：\n\r左子树的左子树D，左子树的根B，左子树的右子树GE\n\r同样地，可以得到右子树的根为C\n\r类似地将右子树分割为根C，右子树的右子树HF，注意其左子树为空 \n\r如果只有一个就是叶子不用再进行了，刚才的GE和HF再次这样运作，就可以将二叉树还原了。\n\n10、\t打印2-100之间的素数。\n\n```\n\rint main(int argc, const char * argv[]) {\n\r    for (int i = 2; i < 100; i++) {\n    \r        int r = isPrime(i);\n        \r        if (r == 1) {\n        \r            printf(\"%ld \", i);\n            \r        }\n        \r    }\n    \r    return 0;\n    \r}\n\n\rint isPrime(int n)\r{\n\r    int i, s;\n    \r    for(i = 2; i <= sqrt(n); i++)\n    \r        if(n % i == 0)  return 0;\n        \r    return 1;\n    \r}\n\n```\n\r11、\t求两个整数的最大公约数。\n\n```\n\rint gcd(int a, int b) {\n\r    int temp = 0;\n    \r    if (a < b) {\n    \r        temp = a;\n        \r        a = b;\n        \r        b = temp;\n        \r    }\r    \r    while (b != 0) {\n    \r        temp = a % b;\n        \r        a = b;\n        \r        b = temp;\n        \r    }\n    \r    return a;\n    \r}\n\r```\n\n**本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！**\n\n**如需转载，请注明出处**\n","source":"_posts/2016-04-24-iosmian-shi-ti-xi-lie-zhi-chang-jian-suan-fa.markdown","raw":"---\nlayout: post\ntitle: \"iOS面试题系列之常见算法\"\ndate: 2016-04-24 23:59:06 +0800\ncomments: true\ntags: [iOS, xcode, 面试]\nkeywords: ios开发, ios面试\ncategories: Others\n---\n#### iOS面试中熟悉常见算法\n1、\t对以下一组数据进行降序排序（冒泡排序）。“24，17，85，13，9，54，76，45，5，63”\n\t\n<!--more-->\n\n``` \n\rint main(int argc, char *argv[]) {\n\r\tint array[10] = {24, 17, 85, 13, 9, 54, 76, 45, 5, 63};\n\t\r\tint num = sizeof(array)/sizeof(int);\n\t\r\tfor(int i = 0; i < num-1; i++) {\n\t\r\t\tfor(int j = 0; j < num - 1 - i; j++) {\n\t\t\r\t\t\tif(array[j] < array[j+1]) {\n\t\t\t\r\t\t\t\tint tmp = array[j];\n\t\t\t\t\r\t\t\t\tarray[j] = array[j+1];\n\t\t\t\t\r\t\t\t\tarray[j+1] = tmp;\n\t\t\t\t\r\t\t\t}\n\t\t\t\r\t\t}\n\t\t\r\t}\n\t\n\tfor(int i = 0; i < num; i++) {\n\t\r\t\tprintf(\"%d\", array[i]);\n\t\t\r\t\tif(i == num-1) {\n\t\t\r\t\t\tprintf(\"\\n\");\n\t\t\t\r\t\t}\n\t\t\r\t\telse {\n\t\t\r\t\t\tprintf(\" \");\n\t\t\t\r\t\t}\n\t\t\r\t}\n\t\r}\n\n```\n\n2、\t对以下一组数据进行升序排序（选择排序）。“86, 37, 56, 29, 92, 73, 15, 63, 30, 8”\n\n```\n\nvoid sort(int a[],int n)\n{\n\n    int i, j, index;\n    \n    for(i = 0; i < n - 1; i++) {\n        \n        index = i;\n        \n        for(j = i + 1; j < n; j++) {\n        \n            if(a[index] > a[j]) {\n            \n                index = j;\n                \n            }\n            \n        }\n        \n        if(index != i) {\n        \n            int temp = a[i];\n            \n            a[i] = a[index];\n            \n            a[index] = temp;\n            \n        }\n        \n    }\n    \n}\n\nint main(int argc, const char * argv[]) {\n\n    int numArr[10] = {86, 37, 56, 29, 92, 73, 15, 63, 30, 8};\n    \n    sort(numArr, 10);\n    \n    for (int i = 0; i < 10; i++) {\n    \n        printf(\"%d, \", numArr[i]);\n        \n    }\n    \n    printf(\"\\n\");\n    \n    return 0;\n    \n}\n\n```\n\n3、\t快速排序算法\n\n```\n\rvoid sort(int *a, int left, int right) {\n\rif(left >= right) {\n\rreturn ;\n\r}\n\rint i = left;\n\rint j = right;\n\rint key = a[left];\n\rwhile (i < j) {\n\rwhile (i < j && key >= a[j]) {\n\rj--;\n\r}\n\ra[i] = a[j];\n\rwhile (i < j && key <= a[i]) {\n\r\ti++;\n\t\r}\n\ra[j] = a[i];\n\r}\n\ra[i] = key;\n\rsort(a, left, i-1);\n\rsort(a, i+1, right);\n\r}\n\n```\n\n4、\t归并排序\n\n```\n\rvoid merge(int sourceArr[], int tempArr[], int startIndex, int midIndex, int endIndex) {\n\r    int i = startIndex;\n    \r    int j = midIndex + 1;\n    \r    int k = startIndex;\n    \r    while (i != midIndex + 1 && j != endIndex + 1) {\n    \r        if (sourceArr[i] >= sourceArr[j]) {\n        \r            tempArr[k++] = sourceArr[j++];\n            \r        } else {\n        \r            tempArr[k++] = sourceArr[i++];\n             \r        }\n        \r    }\r    \r    while (i != midIndex + 1) {\n    \r        tempArr[k++] = sourceArr[i++];\n        \r    }\r    \r    while (j != endIndex + 1) {\n    \r        tempArr[k++] = sourceArr[j++];\n        \r    }\r    \r    for (i = startIndex; i <= endIndex; i++) {\n    \r        sourceArr[i] = tempArr[i];\n        \r    }\n    \r}\n\n\rvoid sort(int souceArr[], int tempArr[], int startIndex, int endIndex) {\n\r    int midIndex;\n    \r    if (startIndex < endIndex) {\n    \r        midIndex = (startIndex + endIndex) / 2;\n        \r        sort(souceArr, tempArr, startIndex, midIndex);\n        \r        sort(souceArr, tempArr, midIndex + 1, endIndex);\n        \r        merge(souceArr, tempArr, startIndex, midIndex, endIndex);\n        \r    }\n    \r}\n\n\rint main(int argc, const char * argv[]) {\n\r    int numArr[10] = {86, 37, 56, 29, 92, 73, 15, 63, 30, 8};\n    \r    int tempArr[10];\n    \r    sort(numArr, tempArr, 0, 9);\n    \r    for (int i = 0; i < 10; i++) {\n    \r        printf(\"%d, \", numArr[i]);\n        \r    }\n    \r    printf(\"\\n\");\n    \r    return 0;\n    \r}\n\n```\n\n5、\t实现二分查找算法（编程语言不限）\n\n```\n\rint bsearchWithoutRecursion(int array[],int low,int high,int target) {\n\rwhile(low <= high) {\n\rint mid = (low + high) / 2;\n\rif(array[mid] > target)\n\rhigh = mid - 1;\n\relse if(array[mid] < target)\n\rlow = mid + 1;\n\relse\t//findthetarget\n\rreturn mid;\n\r}\n\r//the array does not contain the target\n\rreturn -1;\n\r}\n\r----------------------------------------\n\r递归实现\n\rint binary_search(const int arr[],int low,int high,int key)\r{\n\rint mid=low + (high - low) / 2;\n\rif(low > high)\n\rreturn -1;\n\relse{\n\rif(arr[mid] == key)\n\t\rreturn mid;\n\relse if(arr[mid] > key)\n\rreturn binary_search(arr, low, mid-1, key);\n\relse\n\rreturn binary_search(arr, mid+1, high, key);\n\r}\n\r}\n\n```\n\n6、\t如何实现链表翻转（链表逆序）？\r思路：每次把第二个元素提到最前面来。\n\n```\n\r#include <stdio.h>\n\r#include <stdlib.h>\n\r\rtypedef struct NODE {\n\r    struct NODE *next;\n    \r    int num;\n    \r}node;\n\n\rnode *createLinkList(int length) {\n\r    if (length <= 0) {\n    \r        return NULL;\n        \r    }\n    \r    node *head,*p,*q;\n    \r    int number = 1;\n    \r    head = (node *)malloc(sizeof(node));\n    \r    head->num = 1;\n    \r    head->next = head;\n    \r    p = q = head;\n    \r    while (++number <= length) {\n    \r        p = (node *)malloc(sizeof(node));\n        \r        p->num = number;\n        \r        p->next = NULL;\n        \r        q->next = p;\n        \r        q = p;\n        \r    }\n    \r    return head;\r}\n\n\rvoid printLinkList(node *head) {\n\r    if (head == NULL) {\n    \r        return;\n        \r    }\n    \r    node *p = head;\n    \r    while (p) {\n    \r        printf(\"%d \", p->num);\n        \r        p = p -> next;\n        \r    }\n    \r    printf(\"\\n\");\n    \r}\n\n\rnode *reverseFunc1(node *head) {\n\r    if (head == NULL) {\n    \r        return head;\n        \n        \r    }\n    \n    \r    node *p,*q;\n    \r    p = head;\n    \r    q = NULL;\n    \r    while (p) {\n    \r        node *pNext = p -> next;\n        \r        p -> next = q;\n        \r        q = p;\n        \r        p = pNext;\n        \r    }\n    \r    return q;\n    \r}\n\n\rint main(int argc, const char * argv[]) {\n\r    node *head = createLinkList(7);\n    \r    if (head) {\n    \r        printLinkList(head);\n        \r        node *reHead = reverseFunc1(head);\n        \r        printLinkList(reHead);\n        \r        free(reHead);\r    \n    }\n    \r    free(head);\n    \r    return 0;\n    \r}\n\n```\n\n7、\t实现一个字符串“how are you”的逆序输出（编程语言不限）。如给定字符串为“hello world”,输出结果应当为“world hello”。\n\n```\n\rint spliterFunc(char *p) {\n\r    char c[100][100];\n    \r    int i = 0;\n    \r    int j = 0;\n    \n    \r    while (*p != '\\0') {\n    \r        if (*p == ' ') {\n        \r            i++;\n            \r            j = 0;\n            \r        } else {\n        \r            c[i][j] = *p;\n            \r            j++;\n            \r        }\n        \r        p++;\r    \n    \n    }\n    \n    \r    for (int k = i; k >= 0; k--) {\n    \r        printf(\"%s\", c[k]);\n        \r        if (k > 0) {\n        \r            printf(\" \");\n            \r        } else {\n        \r            printf(\"\\n\");\n            \t\r        }\n        \r    }\r\r    return 0;\n    \n    \r}\n\n```\n\r8、\t给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？如“abaccddeeef”,字符是b,输出应该是2。\n\n```\n\nchar *strOutPut(char *);\n\n\rint compareDifferentChar(char, char *);\n\n\rint main(int argc, const char * argv[]) {\r    \n    \r    char *inputStr = \"abaccddeeef\";\n    \r    char *outputStr = strOutPut(inputStr);\n    \r    printf(\"%c \\n\", *outputStr);\n    \r    return 0;\n    \r}\n\n\rchar *strOutPut(char *s) {\n\r    char str[100];\n    \r    char *p = s;\n    \r    int index = 0;\n    \r    while (*s != '\\0') {\n    \r        if (compareDifferentChar(*s, p) == 1) {\n        \r            str[index] = *s;\n            \r            index++;\n            \r        }\n        \r        s++;\n        \r    }\n    \r    return &str;\r}\n\n\rint compareDifferentChar(char c, char *s) {\n\r    int i = 0;\n    \r    while (*s != '\\0' && i<= 1) {\n    \r        if (*s == c) {\n        \r            i++;\n            \r        }\n        \r        s++;\r    }\n    \r    if (i == 1) {\n    \r        return 1;\n        \r    } else {\n    \r        return 0;\n        \r    }\n    \r}\n\n```\n\n\r9、\t二叉树的先序遍历为FBACDEGH,中序遍历为：ABDCEFGH,请写出这个二叉树的后序遍历结果。\n\r**ADECBHGF**\n\n* 先序+中序遍历还原二叉树：先序遍历是：ABDEGCFH 中序遍历是：DBGEACHF\n\n首先从先序得到第一个为A，就是二叉树的根，回到中序，可以将其分为三部分：\n\n左子树的中序序列DBGE，根A，右子树的中序序列CHF\n\r接着将左子树的序列回到先序可以得到B为根，这样回到左子树的中序再次将左子树分割为三部分：\n\r左子树的左子树D，左子树的根B，左子树的右子树GE\n\r同样地，可以得到右子树的根为C\n\r类似地将右子树分割为根C，右子树的右子树HF，注意其左子树为空 \n\r如果只有一个就是叶子不用再进行了，刚才的GE和HF再次这样运作，就可以将二叉树还原了。\n\n10、\t打印2-100之间的素数。\n\n```\n\rint main(int argc, const char * argv[]) {\n\r    for (int i = 2; i < 100; i++) {\n    \r        int r = isPrime(i);\n        \r        if (r == 1) {\n        \r            printf(\"%ld \", i);\n            \r        }\n        \r    }\n    \r    return 0;\n    \r}\n\n\rint isPrime(int n)\r{\n\r    int i, s;\n    \r    for(i = 2; i <= sqrt(n); i++)\n    \r        if(n % i == 0)  return 0;\n        \r    return 1;\n    \r}\n\n```\n\r11、\t求两个整数的最大公约数。\n\n```\n\rint gcd(int a, int b) {\n\r    int temp = 0;\n    \r    if (a < b) {\n    \r        temp = a;\n        \r        a = b;\n        \r        b = temp;\n        \r    }\r    \r    while (b != 0) {\n    \r        temp = a % b;\n        \r        a = b;\n        \r        b = temp;\n        \r    }\n    \r    return a;\n    \r}\n\r```\n\n**本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！**\n\n**如需转载，请注明出处**\n","slug":"iosmian-shi-ti-xi-lie-zhi-chang-jian-suan-fa","published":1,"updated":"2016-09-10T05:18:04.000Z","_id":"ciswie9db000re3u29wie234t","photos":[],"link":"","content":"<h4 id=\"iOS面试中熟悉常见算法\"><a href=\"#iOS面试中熟悉常见算法\" class=\"headerlink\" title=\"iOS面试中熟悉常见算法\"></a>iOS面试中熟悉常见算法</h4><p>1、    对以下一组数据进行降序排序（冒泡排序）。“24，17，85，13，9，54，76，45，5，63”</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rint main(int argc, char *argv[]) &#123;</div><div class=\"line\">\r\tint array[10] = &#123;24, 17, 85, 13, 9, 54, 76, 45, 5, 63&#125;;</div><div class=\"line\">\t\r\tint num = sizeof(array)/sizeof(int);</div><div class=\"line\">\t\r\tfor(int i = 0; i &lt; num-1; i++) &#123;</div><div class=\"line\">\t\r\t\tfor(int j = 0; j &lt; num - 1 - i; j++) &#123;</div><div class=\"line\">\t\t\r\t\t\tif(array[j] &lt; array[j+1]) &#123;</div><div class=\"line\">\t\t\t\r\t\t\t\tint tmp = array[j];</div><div class=\"line\">\t\t\t\t\r\t\t\t\tarray[j] = array[j+1];</div><div class=\"line\">\t\t\t\t\r\t\t\t\tarray[j+1] = tmp;</div><div class=\"line\">\t\t\t\t\r\t\t\t&#125;</div><div class=\"line\">\t\t\t\r\t\t&#125;</div><div class=\"line\">\t\t\r\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tfor(int i = 0; i &lt; num; i++) &#123;</div><div class=\"line\">\t\r\t\tprintf(&quot;%d&quot;, array[i]);</div><div class=\"line\">\t\t\r\t\tif(i == num-1) &#123;</div><div class=\"line\">\t\t\r\t\t\tprintf(&quot;\\n&quot;);</div><div class=\"line\">\t\t\t\r\t\t&#125;</div><div class=\"line\">\t\t\r\t\telse &#123;</div><div class=\"line\">\t\t\r\t\t\tprintf(&quot; &quot;);</div><div class=\"line\">\t\t\t\r\t\t&#125;</div><div class=\"line\">\t\t\r\t&#125;</div><div class=\"line\">\t\r&#125;</div></pre></td></tr></table></figure>\n<p>2、    对以下一组数据进行升序排序（选择排序）。“86, 37, 56, 29, 92, 73, 15, 63, 30, 8”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">void sort(int a[],int n)</div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">    int i, j, index;</div><div class=\"line\">    </div><div class=\"line\">    for(i = 0; i &lt; n - 1; i++) &#123;</div><div class=\"line\">        </div><div class=\"line\">        index = i;</div><div class=\"line\">        </div><div class=\"line\">        for(j = i + 1; j &lt; n; j++) &#123;</div><div class=\"line\">        </div><div class=\"line\">            if(a[index] &gt; a[j]) &#123;</div><div class=\"line\">            </div><div class=\"line\">                index = j;</div><div class=\"line\">                </div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if(index != i) &#123;</div><div class=\"line\">        </div><div class=\"line\">            int temp = a[i];</div><div class=\"line\">            </div><div class=\"line\">            a[i] = a[index];</div><div class=\"line\">            </div><div class=\"line\">            a[index] = temp;</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\"></div><div class=\"line\">    int numArr[10] = &#123;86, 37, 56, 29, 92, 73, 15, 63, 30, 8&#125;;</div><div class=\"line\">    </div><div class=\"line\">    sort(numArr, 10);</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i &lt; 10; i++) &#123;</div><div class=\"line\">    </div><div class=\"line\">        printf(&quot;%d, &quot;, numArr[i]);</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    printf(&quot;\\n&quot;);</div><div class=\"line\">    </div><div class=\"line\">    return 0;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>3、    快速排序算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rvoid sort(int *a, int left, int right) &#123;</div><div class=\"line\">\rif(left &gt;= right) &#123;</div><div class=\"line\">\rreturn ;</div><div class=\"line\">\r&#125;</div><div class=\"line\">\rint i = left;</div><div class=\"line\">\rint j = right;</div><div class=\"line\">\rint key = a[left];</div><div class=\"line\">\rwhile (i &lt; j) &#123;</div><div class=\"line\">\rwhile (i &lt; j &amp;&amp; key &gt;= a[j]) &#123;</div><div class=\"line\">\rj--;</div><div class=\"line\">\r&#125;</div><div class=\"line\">\ra[i] = a[j];</div><div class=\"line\">\rwhile (i &lt; j &amp;&amp; key &lt;= a[i]) &#123;</div><div class=\"line\">\r\ti++;</div><div class=\"line\">\t\r&#125;</div><div class=\"line\">\ra[j] = a[i];</div><div class=\"line\">\r&#125;</div><div class=\"line\">\ra[i] = key;</div><div class=\"line\">\rsort(a, left, i-1);</div><div class=\"line\">\rsort(a, i+1, right);</div><div class=\"line\">\r&#125;</div></pre></td></tr></table></figure>\n<p>4、    归并排序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rvoid merge(int sourceArr[], int tempArr[], int startIndex, int midIndex, int endIndex) &#123;</div><div class=\"line\">\r    int i = startIndex;</div><div class=\"line\">    \r    int j = midIndex + 1;</div><div class=\"line\">    \r    int k = startIndex;</div><div class=\"line\">    \r    while (i != midIndex + 1 &amp;&amp; j != endIndex + 1) &#123;</div><div class=\"line\">    \r        if (sourceArr[i] &gt;= sourceArr[j]) &#123;</div><div class=\"line\">        \r            tempArr[k++] = sourceArr[j++];</div><div class=\"line\">            \r        &#125; else &#123;</div><div class=\"line\">        \r            tempArr[k++] = sourceArr[i++];</div><div class=\"line\">             \r        &#125;</div><div class=\"line\">        \r    &#125;\r    \r    while (i != midIndex + 1) &#123;</div><div class=\"line\">    \r        tempArr[k++] = sourceArr[i++];</div><div class=\"line\">        \r    &#125;\r    \r    while (j != endIndex + 1) &#123;</div><div class=\"line\">    \r        tempArr[k++] = sourceArr[j++];</div><div class=\"line\">        \r    &#125;\r    \r    for (i = startIndex; i &lt;= endIndex; i++) &#123;</div><div class=\"line\">    \r        sourceArr[i] = tempArr[i];</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r&#125;</div><div class=\"line\"></div><div class=\"line\">\rvoid sort(int souceArr[], int tempArr[], int startIndex, int endIndex) &#123;</div><div class=\"line\">\r    int midIndex;</div><div class=\"line\">    \r    if (startIndex &lt; endIndex) &#123;</div><div class=\"line\">    \r        midIndex = (startIndex + endIndex) / 2;</div><div class=\"line\">        \r        sort(souceArr, tempArr, startIndex, midIndex);</div><div class=\"line\">        \r        sort(souceArr, tempArr, midIndex + 1, endIndex);</div><div class=\"line\">        \r        merge(souceArr, tempArr, startIndex, midIndex, endIndex);</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r&#125;</div><div class=\"line\"></div><div class=\"line\">\rint main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\r    int numArr[10] = &#123;86, 37, 56, 29, 92, 73, 15, 63, 30, 8&#125;;</div><div class=\"line\">    \r    int tempArr[10];</div><div class=\"line\">    \r    sort(numArr, tempArr, 0, 9);</div><div class=\"line\">    \r    for (int i = 0; i &lt; 10; i++) &#123;</div><div class=\"line\">    \r        printf(&quot;%d, &quot;, numArr[i]);</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    printf(&quot;\\n&quot;);</div><div class=\"line\">    \r    return 0;</div><div class=\"line\">    \r&#125;</div></pre></td></tr></table></figure>\n<p>5、    实现二分查找算法（编程语言不限）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rint bsearchWithoutRecursion(int array[],int low,int high,int target) &#123;</div><div class=\"line\">\rwhile(low &lt;= high) &#123;</div><div class=\"line\">\rint mid = (low + high) / 2;</div><div class=\"line\">\rif(array[mid] &gt; target)</div><div class=\"line\">\rhigh = mid - 1;</div><div class=\"line\">\relse if(array[mid] &lt; target)</div><div class=\"line\">\rlow = mid + 1;</div><div class=\"line\">\relse\t//findthetarget</div><div class=\"line\">\rreturn mid;</div><div class=\"line\">\r&#125;</div><div class=\"line\">\r//the array does not contain the target</div><div class=\"line\">\rreturn -1;</div><div class=\"line\">\r&#125;</div><div class=\"line\">\r----------------------------------------</div><div class=\"line\">\r递归实现</div><div class=\"line\">\rint binary_search(const int arr[],int low,int high,int key)\r&#123;</div><div class=\"line\">\rint mid=low + (high - low) / 2;</div><div class=\"line\">\rif(low &gt; high)</div><div class=\"line\">\rreturn -1;</div><div class=\"line\">\relse&#123;</div><div class=\"line\">\rif(arr[mid] == key)</div><div class=\"line\">\t\rreturn mid;</div><div class=\"line\">\relse if(arr[mid] &gt; key)</div><div class=\"line\">\rreturn binary_search(arr, low, mid-1, key);</div><div class=\"line\">\relse</div><div class=\"line\">\rreturn binary_search(arr, mid+1, high, key);</div><div class=\"line\">\r&#125;</div><div class=\"line\">\r&#125;</div></pre></td></tr></table></figure>\n<p>6、    如何实现链表翻转（链表逆序）？<br>思路：每次把第二个元素提到最前面来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">\r#include &lt;stdio.h&gt;</div><div class=\"line\">\r#include &lt;stdlib.h&gt;</div><div class=\"line\">\r\rtypedef struct NODE &#123;</div><div class=\"line\">\r    struct NODE *next;</div><div class=\"line\">    \r    int num;</div><div class=\"line\">    \r&#125;node;</div><div class=\"line\"></div><div class=\"line\">\rnode *createLinkList(int length) &#123;</div><div class=\"line\">\r    if (length &lt;= 0) &#123;</div><div class=\"line\">    \r        return NULL;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    node *head,*p,*q;</div><div class=\"line\">    \r    int number = 1;</div><div class=\"line\">    \r    head = (node *)malloc(sizeof(node));</div><div class=\"line\">    \r    head-&gt;num = 1;</div><div class=\"line\">    \r    head-&gt;next = head;</div><div class=\"line\">    \r    p = q = head;</div><div class=\"line\">    \r    while (++number &lt;= length) &#123;</div><div class=\"line\">    \r        p = (node *)malloc(sizeof(node));</div><div class=\"line\">        \r        p-&gt;num = number;</div><div class=\"line\">        \r        p-&gt;next = NULL;</div><div class=\"line\">        \r        q-&gt;next = p;</div><div class=\"line\">        \r        q = p;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    return head;\r&#125;</div><div class=\"line\"></div><div class=\"line\">\rvoid printLinkList(node *head) &#123;</div><div class=\"line\">\r    if (head == NULL) &#123;</div><div class=\"line\">    \r        return;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    node *p = head;</div><div class=\"line\">    \r    while (p) &#123;</div><div class=\"line\">    \r        printf(&quot;%d &quot;, p-&gt;num);</div><div class=\"line\">        \r        p = p -&gt; next;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    printf(&quot;\\n&quot;);</div><div class=\"line\">    \r&#125;</div><div class=\"line\"></div><div class=\"line\">\rnode *reverseFunc1(node *head) &#123;</div><div class=\"line\">\r    if (head == NULL) &#123;</div><div class=\"line\">    \r        return head;</div><div class=\"line\">        </div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    </div><div class=\"line\">    \r    node *p,*q;</div><div class=\"line\">    \r    p = head;</div><div class=\"line\">    \r    q = NULL;</div><div class=\"line\">    \r    while (p) &#123;</div><div class=\"line\">    \r        node *pNext = p -&gt; next;</div><div class=\"line\">        \r        p -&gt; next = q;</div><div class=\"line\">        \r        q = p;</div><div class=\"line\">        \r        p = pNext;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    return q;</div><div class=\"line\">    \r&#125;</div><div class=\"line\"></div><div class=\"line\">\rint main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\r    node *head = createLinkList(7);</div><div class=\"line\">    \r    if (head) &#123;</div><div class=\"line\">    \r        printLinkList(head);</div><div class=\"line\">        \r        node *reHead = reverseFunc1(head);</div><div class=\"line\">        \r        printLinkList(reHead);</div><div class=\"line\">        \r        free(reHead);\r    </div><div class=\"line\">    &#125;</div><div class=\"line\">    \r    free(head);</div><div class=\"line\">    \r    return 0;</div><div class=\"line\">    \r&#125;</div></pre></td></tr></table></figure>\n<p>7、    实现一个字符串“how are you”的逆序输出（编程语言不限）。如给定字符串为“hello world”,输出结果应当为“world hello”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rint spliterFunc(char *p) &#123;</div><div class=\"line\">\r    char c[100][100];</div><div class=\"line\">    \r    int i = 0;</div><div class=\"line\">    \r    int j = 0;</div><div class=\"line\">    </div><div class=\"line\">    \r    while (*p != &apos;\\0&apos;) &#123;</div><div class=\"line\">    \r        if (*p == &apos; &apos;) &#123;</div><div class=\"line\">        \r            i++;</div><div class=\"line\">            \r            j = 0;</div><div class=\"line\">            \r        &#125; else &#123;</div><div class=\"line\">        \r            c[i][j] = *p;</div><div class=\"line\">            \r            j++;</div><div class=\"line\">            \r        &#125;</div><div class=\"line\">        \r        p++;\r    </div><div class=\"line\">    </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    \r    for (int k = i; k &gt;= 0; k--) &#123;</div><div class=\"line\">    \r        printf(&quot;%s&quot;, c[k]);</div><div class=\"line\">        \r        if (k &gt; 0) &#123;</div><div class=\"line\">        \r            printf(&quot; &quot;);</div><div class=\"line\">            \r        &#125; else &#123;</div><div class=\"line\">        \r            printf(&quot;\\n&quot;);</div><div class=\"line\">            \t\r        &#125;</div><div class=\"line\">        \r    &#125;\r\r    return 0;</div><div class=\"line\">    </div><div class=\"line\">    \r&#125;</div></pre></td></tr></table></figure>\n<p>8、    给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？如“abaccddeeef”,字符是b,输出应该是2。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">char *strOutPut(char *);</div><div class=\"line\"></div><div class=\"line\">\rint compareDifferentChar(char, char *);</div><div class=\"line\"></div><div class=\"line\">\rint main(int argc, const char * argv[]) &#123;\r    </div><div class=\"line\">    \r    char *inputStr = &quot;abaccddeeef&quot;;</div><div class=\"line\">    \r    char *outputStr = strOutPut(inputStr);</div><div class=\"line\">    \r    printf(&quot;%c \\n&quot;, *outputStr);</div><div class=\"line\">    \r    return 0;</div><div class=\"line\">    \r&#125;</div><div class=\"line\"></div><div class=\"line\">\rchar *strOutPut(char *s) &#123;</div><div class=\"line\">\r    char str[100];</div><div class=\"line\">    \r    char *p = s;</div><div class=\"line\">    \r    int index = 0;</div><div class=\"line\">    \r    while (*s != &apos;\\0&apos;) &#123;</div><div class=\"line\">    \r        if (compareDifferentChar(*s, p) == 1) &#123;</div><div class=\"line\">        \r            str[index] = *s;</div><div class=\"line\">            \r            index++;</div><div class=\"line\">            \r        &#125;</div><div class=\"line\">        \r        s++;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    return &amp;str;\r&#125;</div><div class=\"line\"></div><div class=\"line\">\rint compareDifferentChar(char c, char *s) &#123;</div><div class=\"line\">\r    int i = 0;</div><div class=\"line\">    \r    while (*s != &apos;\\0&apos; &amp;&amp; i&lt;= 1) &#123;</div><div class=\"line\">    \r        if (*s == c) &#123;</div><div class=\"line\">        \r            i++;</div><div class=\"line\">            \r        &#125;</div><div class=\"line\">        \r        s++;\r    &#125;</div><div class=\"line\">    \r    if (i == 1) &#123;</div><div class=\"line\">    \r        return 1;</div><div class=\"line\">        \r    &#125; else &#123;</div><div class=\"line\">    \r        return 0;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r&#125;</div></pre></td></tr></table></figure>\n<p>9、    二叉树的先序遍历为FBACDEGH,中序遍历为：ABDCEFGH,请写出这个二叉树的后序遍历结果。</p>\n<p><strong>ADECBHGF</strong></p>\n<ul>\n<li>先序+中序遍历还原二叉树：先序遍历是：ABDEGCFH 中序遍历是：DBGEACHF</li>\n</ul>\n<p>首先从先序得到第一个为A，就是二叉树的根，回到中序，可以将其分为三部分：</p>\n<p>左子树的中序序列DBGE，根A，右子树的中序序列CHF</p>\n<p>接着将左子树的序列回到先序可以得到B为根，这样回到左子树的中序再次将左子树分割为三部分：</p>\n<p>左子树的左子树D，左子树的根B，左子树的右子树GE</p>\n<p>同样地，可以得到右子树的根为C</p>\n<p>类似地将右子树分割为根C，右子树的右子树HF，注意其左子树为空 </p>\n<p>如果只有一个就是叶子不用再进行了，刚才的GE和HF再次这样运作，就可以将二叉树还原了。</p>\n<p>10、    打印2-100之间的素数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rint main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\r    for (int i = 2; i &lt; 100; i++) &#123;</div><div class=\"line\">    \r        int r = isPrime(i);</div><div class=\"line\">        \r        if (r == 1) &#123;</div><div class=\"line\">        \r            printf(&quot;%ld &quot;, i);</div><div class=\"line\">            \r        &#125;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    return 0;</div><div class=\"line\">    \r&#125;</div><div class=\"line\"></div><div class=\"line\">\rint isPrime(int n)\r&#123;</div><div class=\"line\">\r    int i, s;</div><div class=\"line\">    \r    for(i = 2; i &lt;= sqrt(n); i++)</div><div class=\"line\">    \r        if(n % i == 0)  return 0;</div><div class=\"line\">        \r    return 1;</div><div class=\"line\">    \r&#125;</div></pre></td></tr></table></figure>\n<p>11、    求两个整数的最大公约数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rint gcd(int a, int b) &#123;</div><div class=\"line\">\r    int temp = 0;</div><div class=\"line\">    \r    if (a &lt; b) &#123;</div><div class=\"line\">    \r        temp = a;</div><div class=\"line\">        \r        a = b;</div><div class=\"line\">        \r        b = temp;</div><div class=\"line\">        \r    &#125;\r    \r    while (b != 0) &#123;</div><div class=\"line\">    \r        temp = a % b;</div><div class=\"line\">        \r        a = b;</div><div class=\"line\">        \r        b = temp;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    return a;</div><div class=\"line\">    \r&#125;</div></pre></td></tr></table></figure>\n<p><strong>本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！</strong></p>\n<p><strong>如需转载，请注明出处</strong></p>\n","excerpt":"<h4 id=\"iOS面试中熟悉常见算法\"><a href=\"#iOS面试中熟悉常见算法\" class=\"headerlink\" title=\"iOS面试中熟悉常见算法\"></a>iOS面试中熟悉常见算法</h4><p>1、    对以下一组数据进行降序排序（冒泡排序）。“24，17，85，13，9，54，76，45，5，63”</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rint main(int argc, char *argv[]) &#123;</div><div class=\"line\">\r\tint array[10] = &#123;24, 17, 85, 13, 9, 54, 76, 45, 5, 63&#125;;</div><div class=\"line\">\t\r\tint num = sizeof(array)/sizeof(int);</div><div class=\"line\">\t\r\tfor(int i = 0; i &lt; num-1; i++) &#123;</div><div class=\"line\">\t\r\t\tfor(int j = 0; j &lt; num - 1 - i; j++) &#123;</div><div class=\"line\">\t\t\r\t\t\tif(array[j] &lt; array[j+1]) &#123;</div><div class=\"line\">\t\t\t\r\t\t\t\tint tmp = array[j];</div><div class=\"line\">\t\t\t\t\r\t\t\t\tarray[j] = array[j+1];</div><div class=\"line\">\t\t\t\t\r\t\t\t\tarray[j+1] = tmp;</div><div class=\"line\">\t\t\t\t\r\t\t\t&#125;</div><div class=\"line\">\t\t\t\r\t\t&#125;</div><div class=\"line\">\t\t\r\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tfor(int i = 0; i &lt; num; i++) &#123;</div><div class=\"line\">\t\r\t\tprintf(&quot;%d&quot;, array[i]);</div><div class=\"line\">\t\t\r\t\tif(i == num-1) &#123;</div><div class=\"line\">\t\t\r\t\t\tprintf(&quot;\\n&quot;);</div><div class=\"line\">\t\t\t\r\t\t&#125;</div><div class=\"line\">\t\t\r\t\telse &#123;</div><div class=\"line\">\t\t\r\t\t\tprintf(&quot; &quot;);</div><div class=\"line\">\t\t\t\r\t\t&#125;</div><div class=\"line\">\t\t\r\t&#125;</div><div class=\"line\">\t\r&#125;</div></pre></td></tr></table></figure>\n<p>2、    对以下一组数据进行升序排序（选择排序）。“86, 37, 56, 29, 92, 73, 15, 63, 30, 8”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">void sort(int a[],int n)</div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">    int i, j, index;</div><div class=\"line\">    </div><div class=\"line\">    for(i = 0; i &lt; n - 1; i++) &#123;</div><div class=\"line\">        </div><div class=\"line\">        index = i;</div><div class=\"line\">        </div><div class=\"line\">        for(j = i + 1; j &lt; n; j++) &#123;</div><div class=\"line\">        </div><div class=\"line\">            if(a[index] &gt; a[j]) &#123;</div><div class=\"line\">            </div><div class=\"line\">                index = j;</div><div class=\"line\">                </div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if(index != i) &#123;</div><div class=\"line\">        </div><div class=\"line\">            int temp = a[i];</div><div class=\"line\">            </div><div class=\"line\">            a[i] = a[index];</div><div class=\"line\">            </div><div class=\"line\">            a[index] = temp;</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, const char * argv[]) &#123;</div><div class=\"line\"></div><div class=\"line\">    int numArr[10] = &#123;86, 37, 56, 29, 92, 73, 15, 63, 30, 8&#125;;</div><div class=\"line\">    </div><div class=\"line\">    sort(numArr, 10);</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i &lt; 10; i++) &#123;</div><div class=\"line\">    </div><div class=\"line\">        printf(&quot;%d, &quot;, numArr[i]);</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    printf(&quot;\\n&quot;);</div><div class=\"line\">    </div><div class=\"line\">    return 0;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>3、    快速排序算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rvoid sort(int *a, int left, int right) &#123;</div><div class=\"line\">\rif(left &gt;= right) &#123;</div><div class=\"line\">\rreturn ;</div><div class=\"line\">\r&#125;</div><div class=\"line\">\rint i = left;</div><div class=\"line\">\rint j = right;</div><div class=\"line\">\rint key = a[left];</div><div class=\"line\">\rwhile (i &lt; j) &#123;</div><div class=\"line\">\rwhile (i &lt; j &amp;&amp; key &gt;= a[j]) &#123;</div><div class=\"line\">\rj--;</div><div class=\"line\">\r&#125;</div><div class=\"line\">\ra[i] = a[j];</div><div class=\"line\">\rwhile (i &lt; j &amp;&amp; key &lt;= a[i]) &#123;</div><div class=\"line\">\r\ti++;</div><div class=\"line\">\t\r&#125;</div><div class=\"line\">\ra[j] = a[i];</div><div class=\"line\">\r&#125;</div><div class=\"line\">\ra[i] = key;</div><div class=\"line\">\rsort(a, left, i-1);</div><div class=\"line\">\rsort(a, i+1, right);</div><div class=\"line\">\r&#125;</div></pre></td></tr></table></figure>\n<p>4、    归并排序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rvoid merge(int sourceArr[], int tempArr[], int startIndex, int midIndex, int endIndex) &#123;</div><div class=\"line\">\r    int i = startIndex;</div><div class=\"line\">    \r    int j = midIndex + 1;</div><div class=\"line\">    \r    int k = startIndex;</div><div class=\"line\">    \r    while (i != midIndex + 1 &amp;&amp; j != endIndex + 1) &#123;</div><div class=\"line\">    \r        if (sourceArr[i] &gt;= sourceArr[j]) &#123;</div><div class=\"line\">        \r            tempArr[k++] = sourceArr[j++];</div><div class=\"line\">            \r        &#125; else &#123;</div><div class=\"line\">        \r            tempArr[k++] = sourceArr[i++];</div><div class=\"line\">             \r        &#125;</div><div class=\"line\">        \r    &#125;\r    \r    while (i != midIndex + 1) &#123;</div><div class=\"line\">    \r        tempArr[k++] = sourceArr[i++];</div><div class=\"line\">        \r    &#125;\r    \r    while (j != endIndex + 1) &#123;</div><div class=\"line\">    \r        tempArr[k++] = sourceArr[j++];</div><div class=\"line\">        \r    &#125;\r    \r    for (i = startIndex; i &lt;= endIndex; i++) &#123;</div><div class=\"line\">    \r        sourceArr[i] = tempArr[i];</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r&#125;</div><div class=\"line\"></div><div class=\"line\">\rvoid sort(int souceArr[], int tempArr[], int startIndex, int endIndex) &#123;</div><div class=\"line\">\r    int midIndex;</div><div class=\"line\">    \r    if (startIndex &lt; endIndex) &#123;</div><div class=\"line\">    \r        midIndex = (startIndex + endIndex) / 2;</div><div class=\"line\">        \r        sort(souceArr, tempArr, startIndex, midIndex);</div><div class=\"line\">        \r        sort(souceArr, tempArr, midIndex + 1, endIndex);</div><div class=\"line\">        \r        merge(souceArr, tempArr, startIndex, midIndex, endIndex);</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r&#125;</div><div class=\"line\"></div><div class=\"line\">\rint main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\r    int numArr[10] = &#123;86, 37, 56, 29, 92, 73, 15, 63, 30, 8&#125;;</div><div class=\"line\">    \r    int tempArr[10];</div><div class=\"line\">    \r    sort(numArr, tempArr, 0, 9);</div><div class=\"line\">    \r    for (int i = 0; i &lt; 10; i++) &#123;</div><div class=\"line\">    \r        printf(&quot;%d, &quot;, numArr[i]);</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    printf(&quot;\\n&quot;);</div><div class=\"line\">    \r    return 0;</div><div class=\"line\">    \r&#125;</div></pre></td></tr></table></figure>\n<p>5、    实现二分查找算法（编程语言不限）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rint bsearchWithoutRecursion(int array[],int low,int high,int target) &#123;</div><div class=\"line\">\rwhile(low &lt;= high) &#123;</div><div class=\"line\">\rint mid = (low + high) / 2;</div><div class=\"line\">\rif(array[mid] &gt; target)</div><div class=\"line\">\rhigh = mid - 1;</div><div class=\"line\">\relse if(array[mid] &lt; target)</div><div class=\"line\">\rlow = mid + 1;</div><div class=\"line\">\relse\t//findthetarget</div><div class=\"line\">\rreturn mid;</div><div class=\"line\">\r&#125;</div><div class=\"line\">\r//the array does not contain the target</div><div class=\"line\">\rreturn -1;</div><div class=\"line\">\r&#125;</div><div class=\"line\">\r----------------------------------------</div><div class=\"line\">\r递归实现</div><div class=\"line\">\rint binary_search(const int arr[],int low,int high,int key)\r&#123;</div><div class=\"line\">\rint mid=low + (high - low) / 2;</div><div class=\"line\">\rif(low &gt; high)</div><div class=\"line\">\rreturn -1;</div><div class=\"line\">\relse&#123;</div><div class=\"line\">\rif(arr[mid] == key)</div><div class=\"line\">\t\rreturn mid;</div><div class=\"line\">\relse if(arr[mid] &gt; key)</div><div class=\"line\">\rreturn binary_search(arr, low, mid-1, key);</div><div class=\"line\">\relse</div><div class=\"line\">\rreturn binary_search(arr, mid+1, high, key);</div><div class=\"line\">\r&#125;</div><div class=\"line\">\r&#125;</div></pre></td></tr></table></figure>\n<p>6、    如何实现链表翻转（链表逆序）？<br>思路：每次把第二个元素提到最前面来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">\r#include &lt;stdio.h&gt;</div><div class=\"line\">\r#include &lt;stdlib.h&gt;</div><div class=\"line\">\r\rtypedef struct NODE &#123;</div><div class=\"line\">\r    struct NODE *next;</div><div class=\"line\">    \r    int num;</div><div class=\"line\">    \r&#125;node;</div><div class=\"line\"></div><div class=\"line\">\rnode *createLinkList(int length) &#123;</div><div class=\"line\">\r    if (length &lt;= 0) &#123;</div><div class=\"line\">    \r        return NULL;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    node *head,*p,*q;</div><div class=\"line\">    \r    int number = 1;</div><div class=\"line\">    \r    head = (node *)malloc(sizeof(node));</div><div class=\"line\">    \r    head-&gt;num = 1;</div><div class=\"line\">    \r    head-&gt;next = head;</div><div class=\"line\">    \r    p = q = head;</div><div class=\"line\">    \r    while (++number &lt;= length) &#123;</div><div class=\"line\">    \r        p = (node *)malloc(sizeof(node));</div><div class=\"line\">        \r        p-&gt;num = number;</div><div class=\"line\">        \r        p-&gt;next = NULL;</div><div class=\"line\">        \r        q-&gt;next = p;</div><div class=\"line\">        \r        q = p;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    return head;\r&#125;</div><div class=\"line\"></div><div class=\"line\">\rvoid printLinkList(node *head) &#123;</div><div class=\"line\">\r    if (head == NULL) &#123;</div><div class=\"line\">    \r        return;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    node *p = head;</div><div class=\"line\">    \r    while (p) &#123;</div><div class=\"line\">    \r        printf(&quot;%d &quot;, p-&gt;num);</div><div class=\"line\">        \r        p = p -&gt; next;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    printf(&quot;\\n&quot;);</div><div class=\"line\">    \r&#125;</div><div class=\"line\"></div><div class=\"line\">\rnode *reverseFunc1(node *head) &#123;</div><div class=\"line\">\r    if (head == NULL) &#123;</div><div class=\"line\">    \r        return head;</div><div class=\"line\">        </div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    </div><div class=\"line\">    \r    node *p,*q;</div><div class=\"line\">    \r    p = head;</div><div class=\"line\">    \r    q = NULL;</div><div class=\"line\">    \r    while (p) &#123;</div><div class=\"line\">    \r        node *pNext = p -&gt; next;</div><div class=\"line\">        \r        p -&gt; next = q;</div><div class=\"line\">        \r        q = p;</div><div class=\"line\">        \r        p = pNext;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    return q;</div><div class=\"line\">    \r&#125;</div><div class=\"line\"></div><div class=\"line\">\rint main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\r    node *head = createLinkList(7);</div><div class=\"line\">    \r    if (head) &#123;</div><div class=\"line\">    \r        printLinkList(head);</div><div class=\"line\">        \r        node *reHead = reverseFunc1(head);</div><div class=\"line\">        \r        printLinkList(reHead);</div><div class=\"line\">        \r        free(reHead);\r    </div><div class=\"line\">    &#125;</div><div class=\"line\">    \r    free(head);</div><div class=\"line\">    \r    return 0;</div><div class=\"line\">    \r&#125;</div></pre></td></tr></table></figure>\n<p>7、    实现一个字符串“how are you”的逆序输出（编程语言不限）。如给定字符串为“hello world”,输出结果应当为“world hello”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rint spliterFunc(char *p) &#123;</div><div class=\"line\">\r    char c[100][100];</div><div class=\"line\">    \r    int i = 0;</div><div class=\"line\">    \r    int j = 0;</div><div class=\"line\">    </div><div class=\"line\">    \r    while (*p != &apos;\\0&apos;) &#123;</div><div class=\"line\">    \r        if (*p == &apos; &apos;) &#123;</div><div class=\"line\">        \r            i++;</div><div class=\"line\">            \r            j = 0;</div><div class=\"line\">            \r        &#125; else &#123;</div><div class=\"line\">        \r            c[i][j] = *p;</div><div class=\"line\">            \r            j++;</div><div class=\"line\">            \r        &#125;</div><div class=\"line\">        \r        p++;\r    </div><div class=\"line\">    </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    \r    for (int k = i; k &gt;= 0; k--) &#123;</div><div class=\"line\">    \r        printf(&quot;%s&quot;, c[k]);</div><div class=\"line\">        \r        if (k &gt; 0) &#123;</div><div class=\"line\">        \r            printf(&quot; &quot;);</div><div class=\"line\">            \r        &#125; else &#123;</div><div class=\"line\">        \r            printf(&quot;\\n&quot;);</div><div class=\"line\">            \t\r        &#125;</div><div class=\"line\">        \r    &#125;\r\r    return 0;</div><div class=\"line\">    </div><div class=\"line\">    \r&#125;</div></pre></td></tr></table></figure>\n<p>8、    给定一个字符串，输出本字符串中只出现一次并且最靠前的那个字符的位置？如“abaccddeeef”,字符是b,输出应该是2。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">char *strOutPut(char *);</div><div class=\"line\"></div><div class=\"line\">\rint compareDifferentChar(char, char *);</div><div class=\"line\"></div><div class=\"line\">\rint main(int argc, const char * argv[]) &#123;\r    </div><div class=\"line\">    \r    char *inputStr = &quot;abaccddeeef&quot;;</div><div class=\"line\">    \r    char *outputStr = strOutPut(inputStr);</div><div class=\"line\">    \r    printf(&quot;%c \\n&quot;, *outputStr);</div><div class=\"line\">    \r    return 0;</div><div class=\"line\">    \r&#125;</div><div class=\"line\"></div><div class=\"line\">\rchar *strOutPut(char *s) &#123;</div><div class=\"line\">\r    char str[100];</div><div class=\"line\">    \r    char *p = s;</div><div class=\"line\">    \r    int index = 0;</div><div class=\"line\">    \r    while (*s != &apos;\\0&apos;) &#123;</div><div class=\"line\">    \r        if (compareDifferentChar(*s, p) == 1) &#123;</div><div class=\"line\">        \r            str[index] = *s;</div><div class=\"line\">            \r            index++;</div><div class=\"line\">            \r        &#125;</div><div class=\"line\">        \r        s++;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    return &amp;str;\r&#125;</div><div class=\"line\"></div><div class=\"line\">\rint compareDifferentChar(char c, char *s) &#123;</div><div class=\"line\">\r    int i = 0;</div><div class=\"line\">    \r    while (*s != &apos;\\0&apos; &amp;&amp; i&lt;= 1) &#123;</div><div class=\"line\">    \r        if (*s == c) &#123;</div><div class=\"line\">        \r            i++;</div><div class=\"line\">            \r        &#125;</div><div class=\"line\">        \r        s++;\r    &#125;</div><div class=\"line\">    \r    if (i == 1) &#123;</div><div class=\"line\">    \r        return 1;</div><div class=\"line\">        \r    &#125; else &#123;</div><div class=\"line\">    \r        return 0;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r&#125;</div></pre></td></tr></table></figure>\n<p>9、    二叉树的先序遍历为FBACDEGH,中序遍历为：ABDCEFGH,请写出这个二叉树的后序遍历结果。</p>\n<p><strong>ADECBHGF</strong></p>\n<ul>\n<li>先序+中序遍历还原二叉树：先序遍历是：ABDEGCFH 中序遍历是：DBGEACHF</li>\n</ul>\n<p>首先从先序得到第一个为A，就是二叉树的根，回到中序，可以将其分为三部分：</p>\n<p>左子树的中序序列DBGE，根A，右子树的中序序列CHF</p>\n<p>接着将左子树的序列回到先序可以得到B为根，这样回到左子树的中序再次将左子树分割为三部分：</p>\n<p>左子树的左子树D，左子树的根B，左子树的右子树GE</p>\n<p>同样地，可以得到右子树的根为C</p>\n<p>类似地将右子树分割为根C，右子树的右子树HF，注意其左子树为空 </p>\n<p>如果只有一个就是叶子不用再进行了，刚才的GE和HF再次这样运作，就可以将二叉树还原了。</p>\n<p>10、    打印2-100之间的素数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rint main(int argc, const char * argv[]) &#123;</div><div class=\"line\">\r    for (int i = 2; i &lt; 100; i++) &#123;</div><div class=\"line\">    \r        int r = isPrime(i);</div><div class=\"line\">        \r        if (r == 1) &#123;</div><div class=\"line\">        \r            printf(&quot;%ld &quot;, i);</div><div class=\"line\">            \r        &#125;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    return 0;</div><div class=\"line\">    \r&#125;</div><div class=\"line\"></div><div class=\"line\">\rint isPrime(int n)\r&#123;</div><div class=\"line\">\r    int i, s;</div><div class=\"line\">    \r    for(i = 2; i &lt;= sqrt(n); i++)</div><div class=\"line\">    \r        if(n % i == 0)  return 0;</div><div class=\"line\">        \r    return 1;</div><div class=\"line\">    \r&#125;</div></pre></td></tr></table></figure>\n<p>11、    求两个整数的最大公约数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rint gcd(int a, int b) &#123;</div><div class=\"line\">\r    int temp = 0;</div><div class=\"line\">    \r    if (a &lt; b) &#123;</div><div class=\"line\">    \r        temp = a;</div><div class=\"line\">        \r        a = b;</div><div class=\"line\">        \r        b = temp;</div><div class=\"line\">        \r    &#125;\r    \r    while (b != 0) &#123;</div><div class=\"line\">    \r        temp = a % b;</div><div class=\"line\">        \r        a = b;</div><div class=\"line\">        \r        b = temp;</div><div class=\"line\">        \r    &#125;</div><div class=\"line\">    \r    return a;</div><div class=\"line\">    \r&#125;</div></pre></td></tr></table></figure>\n<p><strong>本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！</strong></p>\n<p><strong>如需转载，请注明出处</strong></p>"},{"layout":"post","title":"iOS面试题系列之UI相关","date":"2016-04-24T15:58:39.000Z","comments":1,"keywords":"ios开发, iOS面试","_content":"\n**1、\t简述app启动周期。**\n\n\r打开应用程序，它先会执行main函数，再执行UIApplicationMain函数。初始化\nUIApplication，设置代理对象，开启事件循环，调用代理方法进行事件处理。\n\n\n首先会调用application:didFinishLaunchingWithOptions:代理方法。\n\n<!--more-->\n接下来会调用applicationDidBecomeActive:代理方法。监听系统事件，结束程序。当程序正常退出UIApplicationMain函数才会返回。\n\n\n监听系统事件：\n\n\r锁屏后app会调用：applicationWillResignActive:代理方法。然后接着调用\napplicationDidEnterBackground:方法。\n\n\r解锁后app会调用：applicationWillEnterForeground:代理方法。接着调用\napplicationDidBecomeActive代理方法。\n\n\r杀死进程会调用：applicationWillTerminate:代理方法。\n\n\r接听电话：先调用applicationWillResignActive:代理方法。挂断电话后会直接进入\n应用调：applicationDidBecomeActive:代理方法。\n\n\r出现内存警告会调用：applicationDidReceiveMemoryWarning:代理方法\n\n\n**2、\t简单的说说UIApplication的作用及继承关系。**\n\n\r（1）UIApplication是继承UIResponder的。UIApplication是整个应用程序的核\n心。每一个程序在运行期必须有UIApplication(或子类)的一个实例（有且只有一\n个），通过[UIApplication shareApplication]可以得到这个单例实例。\n\n\r（2）UIApplication帮助管理应用程序的生命周期，通过delegate来履行任务。\n\n\r（3）UIApplication可以接收事件，把所有用户事件都放入队列，逐个处理。它会发送\n当前事件给一个合适的目标控件进行处理。他还将部分事件转给delegate对象来处理。\ndelegate可以处理的事件包括：应用程序的生命周期事件（如程序启动与关闭）、系统事\n件（如来电）。\n\n\n**3、\t简述推送消息原理。**\n\n\r（1）应用程序注册接收远程通知的时候，系统会发送请求到APNS服务器。APNS服务器收\n到请求后会根据请求所带的key值生成一个独一无二的deviceToken。然后APNS服务器会把deviceToken包装成NSData对象发送到对应请求的App上。接下来APP把deviceToken发送给我们自己的服务器（Provider）。服务器接收到deviceToken后进行存储等相关处理。服务器会把推送给用户的消息发送至APNS服务器，最后APNS服务器再发送通知给app。\n\n\r（2）有关于deviceToken变化问题：\r重新安装或卸载应用程序，deviceToken不会发生变化。\r系统升级deviceToken可能会发生变化。\r抹掉所有内容和设置，重置设备后，deviceToken会变化\n\n\r（3）注册远程通知方法\r注册远程通知：\r一般在app启动完成的时候注册远程通知，注册方法一般在didFinishLaunchingWithOptions：代理方法中\r处理注册远程通知回调方法：\r注册成功会回调didRegisterForRometoNotificationsWithDeviceToken:其中的deviceToken参数就是APNS服务器返回的token。\r注册失败会回调didFailToRegisterForRemoteNotificationsWithError:\n\n\r（4）处理接收到的远程通知消息\r程序启动时，app从Terminate状态进入Foreground状态时，会根据didFinishLaunchingWithOptions:代理方法中的luanchOptions参数来获取userInfo。判断是否有推送消息。方式如下：\r\r   // userInfo为收到远程通知的内容\rNSDictionary*userInfo=launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey];\rif (userInfo) {   // 有推送的消息，处理推送的消息  }\r如果app处于Background状态时，只有用户点击了通知消息才会调用didReceiveRemoteNotification:，如果当前app处于Foreground状态，会直接调用该方法。\n\n\n**4、\t简单说下UITableView、UIButton、UIWindow控件的继承关系。**\n\n\r（1）UITableView的继承关系：UITableView继承UIScrollView。UIScrollView继承UIView。UIView继承UIResponder。UIResponder继承NSObject。\n\n\r（2）UIButton的继承关系：UIButton继承UIControl，UIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。\n\n\r（3）UIWindow继承UIView。\n\n\n**5、\tUIView与UIButton有什么区别？UISwitch呢？**\n\n\rUIView继承自UIResponder，它能响应某个动作。UIButton继承UIControl。它不仅可以响应某个动作，还能为某个对象添加对应的动作加以响应。\rUIButton也能实现UISwitch的功能，它们的区别是分发的事件不一样。\n\n\n**6、\t简述UIControl的继承关系，它用来做什么？**\n\n\rUIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。它能为某个特定对象添加事件。能进行事件分发。\n\n\n**7、\t简述UIViewController中view的生命周期。**\n\n\n\r先调用loadView方法，再调用viewDidLoad方法，调用viewWillAppear方法，调用viewWillLayoutSubviews方法，调用viewDidLayoutSubviews方法，再调用viewDidApper方法。控制器消失的时候先调用viewWillDisappear方法，再调用viewDidDisapper方法。最后调用dealloc方法。当出现内存警告的时候会调用didReceiveMemoryWarning方法。\n\n\n**8、\t简述UITableView的代理方法调用顺序。**\n\n\r先调用numberOfSectionsInTableView:方法，\n\n\rnumberOfRowsInSection:\n\n\rheightForRowAtIndexPath:\n\n\rcellForRowAtIndexPath:\n\n\n\n**9、\t你在用CollectionView的时候有没有遇到什么问题？问题是怎么解决的？**\n\n\r刷新的时候会闪烁。在刷新的时候会默认附加一个隐式的fade动画。可以通过取消动画来达到取消闪烁的目的。\n\n\n\n**10、\t简述UIResponder类的作用。**\n\n\rUIResponder类主要是为那些需要响应并处理事件的对象定义了一组接口。这些事件包括：触摸事件、运动事件、远程控制事件（如耳机控制音视频播放）。当用户触发某一事件时，UIKit会创建一个UIEvent事件对象，事件对象会加入到一个FIFO先进先出的队列中。UIApplication对象处理事件时，会从队列头部取出一个事件对象进行分发。\n\n\n**11、\t如何监听View的触摸事件？事件如何传递？简述视图的响应者链。**\n\n\r可以通过View类的touchesBegan、touchesMoved、touchesEnded、touchesCancelled方法监听视图的触摸。\n\r当触摸一个视图对象时，系统会捕捉此事件，并给这个事件创建一个UIEvent对象，将此对象加入当前应用程序的事件队列中，然后由UIApplication对象从队列中取出来进行事件分发，首先会分发给UIWindow对象，然后由UIWindow对象分发给触摸的视图对象，即第一响应者对象。\n\n\r响应者链：当事件交给第一响应者处理，如果第一响应者不处理，事件就会沿着响应者链向上传递，交给下一个响应者。一般来说，第一响应者是一个视图对象或者是其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象，然后是它的父视图对象，以此类推，直到顶层视图。接下来会沿着顶层视图到UIWindow对象，再到UIApplication对象。如果整个过程都没有响应这个事件，该事件就会被丢弃，一般情况下，在响应者链中只要有对象处理事件，事件就会停止传递。有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。\n\n\r**12、\tCALayer与UIView有什么区别？**\n\n\r（1）UIView是iOS系统中界面元素的继承。所有的界面元素都继承自它，他本身完全是由CoreAnimation来实现的。它真正的绘图部分，是由一个叫CALayer的类来管理。UIView本身更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，如frame,bounds等，实际上内部都是在访问它所包含的CALayer的相关属性。\n\n\n\r（2）UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示。\n\n\r（3）UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer。\n\n\r（4）CALayer坐标系统与UIView有点不一样，它多了一个anchorPoint的属性。\n\n\r（5）UIView的layer树形在系统内部，被系统维护着三份copy。逻辑树，动画树，显示树。\n\n\r（6）CALayer默认修改属性支持隐式动画\n\n\r（7）View可以接受并处理事件，Layer不可以。\n\n\n**13、\t如何优化UITableView?**\n\n\r（1）复用单元格\n\n\r（2）使用不透明的视图，单元格中少使用动画。\n\n\r（3）图片使用异步加载，设置图片加载的并发数。\n\n\r（4）滑动时不加载图片，停止滑动时再加载。\n\n\r（5）图片和文字可以直接drawRect\n\n\r（6）如果cell是动态行高，计算缓存单元格高度\n\n\r（7）尽量少reloadData，只reloadRowsAtIndexPaths\n\n\r（8）cell高度固定直接用rowHeight属性设置高度。\n\n\r**14、\t简述加载到控制器上的根视图创建与加载时机。**\n\n\n视图控制器的根视图加载是在UIViewController的loadView方法中。当视图控制中的loadView方法被调用时，会先通过NSBundle加载，通过控制器的类名作为xib文件名加载xib文件，如果存在，加载View为根视图，如果不存在，则自动创建一个View作为根视图。\n\n\n\n**15、\t简述UITableView中cell的复用机制。**\n\n\rUITableView会创建屏幕显示单元格个数（N）+1个单元格，当滑动到第N+2个单元格时就会复用第1个单元格。UITableView中还有单元格复用池的概念。\r当tableView调用初始化单元格协议方法获取单元格时，它会根据你设定的reuse identifier先去复用池中查找可用的复用单元格，找到则复用该单元格，没找到这创建一个新的单元格对象。\n\n\n**本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！**\n\n**如需转载，请注明出处**\r","source":"_posts/2016-04-24-iosmian-shi-ti-xi-lie-zhi-uiji-chu.markdown","raw":"---\nlayout: post\ntitle: \"iOS面试题系列之UI相关\"\ndate: 2016-04-24 23:58:39 +0800\ncomments: true\ntags: [iOS, xcode, iOS面试]\nkeywords: ios开发, iOS面试\ncategories: Others \n---\n\n**1、\t简述app启动周期。**\n\n\r打开应用程序，它先会执行main函数，再执行UIApplicationMain函数。初始化\nUIApplication，设置代理对象，开启事件循环，调用代理方法进行事件处理。\n\n\n首先会调用application:didFinishLaunchingWithOptions:代理方法。\n\n<!--more-->\n接下来会调用applicationDidBecomeActive:代理方法。监听系统事件，结束程序。当程序正常退出UIApplicationMain函数才会返回。\n\n\n监听系统事件：\n\n\r锁屏后app会调用：applicationWillResignActive:代理方法。然后接着调用\napplicationDidEnterBackground:方法。\n\n\r解锁后app会调用：applicationWillEnterForeground:代理方法。接着调用\napplicationDidBecomeActive代理方法。\n\n\r杀死进程会调用：applicationWillTerminate:代理方法。\n\n\r接听电话：先调用applicationWillResignActive:代理方法。挂断电话后会直接进入\n应用调：applicationDidBecomeActive:代理方法。\n\n\r出现内存警告会调用：applicationDidReceiveMemoryWarning:代理方法\n\n\n**2、\t简单的说说UIApplication的作用及继承关系。**\n\n\r（1）UIApplication是继承UIResponder的。UIApplication是整个应用程序的核\n心。每一个程序在运行期必须有UIApplication(或子类)的一个实例（有且只有一\n个），通过[UIApplication shareApplication]可以得到这个单例实例。\n\n\r（2）UIApplication帮助管理应用程序的生命周期，通过delegate来履行任务。\n\n\r（3）UIApplication可以接收事件，把所有用户事件都放入队列，逐个处理。它会发送\n当前事件给一个合适的目标控件进行处理。他还将部分事件转给delegate对象来处理。\ndelegate可以处理的事件包括：应用程序的生命周期事件（如程序启动与关闭）、系统事\n件（如来电）。\n\n\n**3、\t简述推送消息原理。**\n\n\r（1）应用程序注册接收远程通知的时候，系统会发送请求到APNS服务器。APNS服务器收\n到请求后会根据请求所带的key值生成一个独一无二的deviceToken。然后APNS服务器会把deviceToken包装成NSData对象发送到对应请求的App上。接下来APP把deviceToken发送给我们自己的服务器（Provider）。服务器接收到deviceToken后进行存储等相关处理。服务器会把推送给用户的消息发送至APNS服务器，最后APNS服务器再发送通知给app。\n\n\r（2）有关于deviceToken变化问题：\r重新安装或卸载应用程序，deviceToken不会发生变化。\r系统升级deviceToken可能会发生变化。\r抹掉所有内容和设置，重置设备后，deviceToken会变化\n\n\r（3）注册远程通知方法\r注册远程通知：\r一般在app启动完成的时候注册远程通知，注册方法一般在didFinishLaunchingWithOptions：代理方法中\r处理注册远程通知回调方法：\r注册成功会回调didRegisterForRometoNotificationsWithDeviceToken:其中的deviceToken参数就是APNS服务器返回的token。\r注册失败会回调didFailToRegisterForRemoteNotificationsWithError:\n\n\r（4）处理接收到的远程通知消息\r程序启动时，app从Terminate状态进入Foreground状态时，会根据didFinishLaunchingWithOptions:代理方法中的luanchOptions参数来获取userInfo。判断是否有推送消息。方式如下：\r\r   // userInfo为收到远程通知的内容\rNSDictionary*userInfo=launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey];\rif (userInfo) {   // 有推送的消息，处理推送的消息  }\r如果app处于Background状态时，只有用户点击了通知消息才会调用didReceiveRemoteNotification:，如果当前app处于Foreground状态，会直接调用该方法。\n\n\n**4、\t简单说下UITableView、UIButton、UIWindow控件的继承关系。**\n\n\r（1）UITableView的继承关系：UITableView继承UIScrollView。UIScrollView继承UIView。UIView继承UIResponder。UIResponder继承NSObject。\n\n\r（2）UIButton的继承关系：UIButton继承UIControl，UIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。\n\n\r（3）UIWindow继承UIView。\n\n\n**5、\tUIView与UIButton有什么区别？UISwitch呢？**\n\n\rUIView继承自UIResponder，它能响应某个动作。UIButton继承UIControl。它不仅可以响应某个动作，还能为某个对象添加对应的动作加以响应。\rUIButton也能实现UISwitch的功能，它们的区别是分发的事件不一样。\n\n\n**6、\t简述UIControl的继承关系，它用来做什么？**\n\n\rUIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。它能为某个特定对象添加事件。能进行事件分发。\n\n\n**7、\t简述UIViewController中view的生命周期。**\n\n\n\r先调用loadView方法，再调用viewDidLoad方法，调用viewWillAppear方法，调用viewWillLayoutSubviews方法，调用viewDidLayoutSubviews方法，再调用viewDidApper方法。控制器消失的时候先调用viewWillDisappear方法，再调用viewDidDisapper方法。最后调用dealloc方法。当出现内存警告的时候会调用didReceiveMemoryWarning方法。\n\n\n**8、\t简述UITableView的代理方法调用顺序。**\n\n\r先调用numberOfSectionsInTableView:方法，\n\n\rnumberOfRowsInSection:\n\n\rheightForRowAtIndexPath:\n\n\rcellForRowAtIndexPath:\n\n\n\n**9、\t你在用CollectionView的时候有没有遇到什么问题？问题是怎么解决的？**\n\n\r刷新的时候会闪烁。在刷新的时候会默认附加一个隐式的fade动画。可以通过取消动画来达到取消闪烁的目的。\n\n\n\n**10、\t简述UIResponder类的作用。**\n\n\rUIResponder类主要是为那些需要响应并处理事件的对象定义了一组接口。这些事件包括：触摸事件、运动事件、远程控制事件（如耳机控制音视频播放）。当用户触发某一事件时，UIKit会创建一个UIEvent事件对象，事件对象会加入到一个FIFO先进先出的队列中。UIApplication对象处理事件时，会从队列头部取出一个事件对象进行分发。\n\n\n**11、\t如何监听View的触摸事件？事件如何传递？简述视图的响应者链。**\n\n\r可以通过View类的touchesBegan、touchesMoved、touchesEnded、touchesCancelled方法监听视图的触摸。\n\r当触摸一个视图对象时，系统会捕捉此事件，并给这个事件创建一个UIEvent对象，将此对象加入当前应用程序的事件队列中，然后由UIApplication对象从队列中取出来进行事件分发，首先会分发给UIWindow对象，然后由UIWindow对象分发给触摸的视图对象，即第一响应者对象。\n\n\r响应者链：当事件交给第一响应者处理，如果第一响应者不处理，事件就会沿着响应者链向上传递，交给下一个响应者。一般来说，第一响应者是一个视图对象或者是其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象，然后是它的父视图对象，以此类推，直到顶层视图。接下来会沿着顶层视图到UIWindow对象，再到UIApplication对象。如果整个过程都没有响应这个事件，该事件就会被丢弃，一般情况下，在响应者链中只要有对象处理事件，事件就会停止传递。有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。\n\n\r**12、\tCALayer与UIView有什么区别？**\n\n\r（1）UIView是iOS系统中界面元素的继承。所有的界面元素都继承自它，他本身完全是由CoreAnimation来实现的。它真正的绘图部分，是由一个叫CALayer的类来管理。UIView本身更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，如frame,bounds等，实际上内部都是在访问它所包含的CALayer的相关属性。\n\n\n\r（2）UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示。\n\n\r（3）UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer。\n\n\r（4）CALayer坐标系统与UIView有点不一样，它多了一个anchorPoint的属性。\n\n\r（5）UIView的layer树形在系统内部，被系统维护着三份copy。逻辑树，动画树，显示树。\n\n\r（6）CALayer默认修改属性支持隐式动画\n\n\r（7）View可以接受并处理事件，Layer不可以。\n\n\n**13、\t如何优化UITableView?**\n\n\r（1）复用单元格\n\n\r（2）使用不透明的视图，单元格中少使用动画。\n\n\r（3）图片使用异步加载，设置图片加载的并发数。\n\n\r（4）滑动时不加载图片，停止滑动时再加载。\n\n\r（5）图片和文字可以直接drawRect\n\n\r（6）如果cell是动态行高，计算缓存单元格高度\n\n\r（7）尽量少reloadData，只reloadRowsAtIndexPaths\n\n\r（8）cell高度固定直接用rowHeight属性设置高度。\n\n\r**14、\t简述加载到控制器上的根视图创建与加载时机。**\n\n\n视图控制器的根视图加载是在UIViewController的loadView方法中。当视图控制中的loadView方法被调用时，会先通过NSBundle加载，通过控制器的类名作为xib文件名加载xib文件，如果存在，加载View为根视图，如果不存在，则自动创建一个View作为根视图。\n\n\n\n**15、\t简述UITableView中cell的复用机制。**\n\n\rUITableView会创建屏幕显示单元格个数（N）+1个单元格，当滑动到第N+2个单元格时就会复用第1个单元格。UITableView中还有单元格复用池的概念。\r当tableView调用初始化单元格协议方法获取单元格时，它会根据你设定的reuse identifier先去复用池中查找可用的复用单元格，找到则复用该单元格，没找到这创建一个新的单元格对象。\n\n\n**本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！**\n\n**如需转载，请注明出处**\r","slug":"iosmian-shi-ti-xi-lie-zhi-uiji-chu","published":1,"updated":"2016-09-10T05:18:10.000Z","_id":"ciswie9dd000ue3u2cz4x0duq","photos":[],"link":"","content":"<p><strong>1、    简述app启动周期。</strong></p>\n<p>打开应用程序，它先会执行main函数，再执行UIApplicationMain函数。初始化<br>UIApplication，设置代理对象，开启事件循环，调用代理方法进行事件处理。</p>\n<p>首先会调用application:didFinishLaunchingWithOptions:代理方法。</p>\n<a id=\"more\"></a>\n<p>接下来会调用applicationDidBecomeActive:代理方法。监听系统事件，结束程序。当程序正常退出UIApplicationMain函数才会返回。</p>\n<p>监听系统事件：</p>\n<p>锁屏后app会调用：applicationWillResignActive:代理方法。然后接着调用<br>applicationDidEnterBackground:方法。</p>\n<p>解锁后app会调用：applicationWillEnterForeground:代理方法。接着调用<br>applicationDidBecomeActive代理方法。</p>\n<p>杀死进程会调用：applicationWillTerminate:代理方法。</p>\n<p>接听电话：先调用applicationWillResignActive:代理方法。挂断电话后会直接进入<br>应用调：applicationDidBecomeActive:代理方法。</p>\n<p>出现内存警告会调用：applicationDidReceiveMemoryWarning:代理方法</p>\n<p><strong>2、    简单的说说UIApplication的作用及继承关系。</strong></p>\n<p>（1）UIApplication是继承UIResponder的。UIApplication是整个应用程序的核<br>心。每一个程序在运行期必须有UIApplication(或子类)的一个实例（有且只有一<br>个），通过[UIApplication shareApplication]可以得到这个单例实例。</p>\n<p>（2）UIApplication帮助管理应用程序的生命周期，通过delegate来履行任务。</p>\n<p>（3）UIApplication可以接收事件，把所有用户事件都放入队列，逐个处理。它会发送<br>当前事件给一个合适的目标控件进行处理。他还将部分事件转给delegate对象来处理。<br>delegate可以处理的事件包括：应用程序的生命周期事件（如程序启动与关闭）、系统事<br>件（如来电）。</p>\n<p><strong>3、    简述推送消息原理。</strong></p>\n<p>（1）应用程序注册接收远程通知的时候，系统会发送请求到APNS服务器。APNS服务器收<br>到请求后会根据请求所带的key值生成一个独一无二的deviceToken。然后APNS服务器会把deviceToken包装成NSData对象发送到对应请求的App上。接下来APP把deviceToken发送给我们自己的服务器（Provider）。服务器接收到deviceToken后进行存储等相关处理。服务器会把推送给用户的消息发送至APNS服务器，最后APNS服务器再发送通知给app。</p>\n<p>（2）有关于deviceToken变化问题：<br>重新安装或卸载应用程序，deviceToken不会发生变化。<br>系统升级deviceToken可能会发生变化。<br>抹掉所有内容和设置，重置设备后，deviceToken会变化</p>\n<p>（3）注册远程通知方法<br>注册远程通知：<br>一般在app启动完成的时候注册远程通知，注册方法一般在didFinishLaunchingWithOptions：代理方法中<br>处理注册远程通知回调方法：<br>注册成功会回调didRegisterForRometoNotificationsWithDeviceToken:其中的deviceToken参数就是APNS服务器返回的token。<br>注册失败会回调didFailToRegisterForRemoteNotificationsWithError:</p>\n<p>（4）处理接收到的远程通知消息<br>程序启动时，app从Terminate状态进入Foreground状态时，会根据didFinishLaunchingWithOptions:代理方法中的luanchOptions参数来获取userInfo。判断是否有推送消息。方式如下：</p>\n<p>   // userInfo为收到远程通知的内容<br>NSDictionary*userInfo=launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey];<br>if (userInfo) {   // 有推送的消息，处理推送的消息  }<br>如果app处于Background状态时，只有用户点击了通知消息才会调用didReceiveRemoteNotification:，如果当前app处于Foreground状态，会直接调用该方法。</p>\n<p><strong>4、    简单说下UITableView、UIButton、UIWindow控件的继承关系。</strong></p>\n<p>（1）UITableView的继承关系：UITableView继承UIScrollView。UIScrollView继承UIView。UIView继承UIResponder。UIResponder继承NSObject。</p>\n<p>（2）UIButton的继承关系：UIButton继承UIControl，UIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。</p>\n<p>（3）UIWindow继承UIView。</p>\n<p><strong>5、    UIView与UIButton有什么区别？UISwitch呢？</strong></p>\n<p>UIView继承自UIResponder，它能响应某个动作。UIButton继承UIControl。它不仅可以响应某个动作，还能为某个对象添加对应的动作加以响应。<br>UIButton也能实现UISwitch的功能，它们的区别是分发的事件不一样。</p>\n<p><strong>6、    简述UIControl的继承关系，它用来做什么？</strong></p>\n<p>UIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。它能为某个特定对象添加事件。能进行事件分发。</p>\n<p><strong>7、    简述UIViewController中view的生命周期。</strong></p>\n<p>先调用loadView方法，再调用viewDidLoad方法，调用viewWillAppear方法，调用viewWillLayoutSubviews方法，调用viewDidLayoutSubviews方法，再调用viewDidApper方法。控制器消失的时候先调用viewWillDisappear方法，再调用viewDidDisapper方法。最后调用dealloc方法。当出现内存警告的时候会调用didReceiveMemoryWarning方法。</p>\n<p><strong>8、    简述UITableView的代理方法调用顺序。</strong></p>\n<p>先调用numberOfSectionsInTableView:方法，</p>\n<p>numberOfRowsInSection:</p>\n<p>heightForRowAtIndexPath:</p>\n<p>cellForRowAtIndexPath:</p>\n<p><strong>9、    你在用CollectionView的时候有没有遇到什么问题？问题是怎么解决的？</strong></p>\n<p>刷新的时候会闪烁。在刷新的时候会默认附加一个隐式的fade动画。可以通过取消动画来达到取消闪烁的目的。</p>\n<p><strong>10、    简述UIResponder类的作用。</strong></p>\n<p>UIResponder类主要是为那些需要响应并处理事件的对象定义了一组接口。这些事件包括：触摸事件、运动事件、远程控制事件（如耳机控制音视频播放）。当用户触发某一事件时，UIKit会创建一个UIEvent事件对象，事件对象会加入到一个FIFO先进先出的队列中。UIApplication对象处理事件时，会从队列头部取出一个事件对象进行分发。</p>\n<p><strong>11、    如何监听View的触摸事件？事件如何传递？简述视图的响应者链。</strong></p>\n<p>可以通过View类的touchesBegan、touchesMoved、touchesEnded、touchesCancelled方法监听视图的触摸。</p>\n<p>当触摸一个视图对象时，系统会捕捉此事件，并给这个事件创建一个UIEvent对象，将此对象加入当前应用程序的事件队列中，然后由UIApplication对象从队列中取出来进行事件分发，首先会分发给UIWindow对象，然后由UIWindow对象分发给触摸的视图对象，即第一响应者对象。</p>\n<p>响应者链：当事件交给第一响应者处理，如果第一响应者不处理，事件就会沿着响应者链向上传递，交给下一个响应者。一般来说，第一响应者是一个视图对象或者是其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象，然后是它的父视图对象，以此类推，直到顶层视图。接下来会沿着顶层视图到UIWindow对象，再到UIApplication对象。如果整个过程都没有响应这个事件，该事件就会被丢弃，一般情况下，在响应者链中只要有对象处理事件，事件就会停止传递。有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。</p>\n<p><strong>12、    CALayer与UIView有什么区别？</strong></p>\n<p>（1）UIView是iOS系统中界面元素的继承。所有的界面元素都继承自它，他本身完全是由CoreAnimation来实现的。它真正的绘图部分，是由一个叫CALayer的类来管理。UIView本身更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，如frame,bounds等，实际上内部都是在访问它所包含的CALayer的相关属性。</p>\n<p>（2）UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示。</p>\n<p>（3）UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer。</p>\n<p>（4）CALayer坐标系统与UIView有点不一样，它多了一个anchorPoint的属性。</p>\n<p>（5）UIView的layer树形在系统内部，被系统维护着三份copy。逻辑树，动画树，显示树。</p>\n<p>（6）CALayer默认修改属性支持隐式动画</p>\n<p>（7）View可以接受并处理事件，Layer不可以。</p>\n<p><strong>13、    如何优化UITableView?</strong></p>\n<p>（1）复用单元格</p>\n<p>（2）使用不透明的视图，单元格中少使用动画。</p>\n<p>（3）图片使用异步加载，设置图片加载的并发数。</p>\n<p>（4）滑动时不加载图片，停止滑动时再加载。</p>\n<p>（5）图片和文字可以直接drawRect</p>\n<p>（6）如果cell是动态行高，计算缓存单元格高度</p>\n<p>（7）尽量少reloadData，只reloadRowsAtIndexPaths</p>\n<p>（8）cell高度固定直接用rowHeight属性设置高度。</p>\n<p><strong>14、    简述加载到控制器上的根视图创建与加载时机。</strong></p>\n<p>视图控制器的根视图加载是在UIViewController的loadView方法中。当视图控制中的loadView方法被调用时，会先通过NSBundle加载，通过控制器的类名作为xib文件名加载xib文件，如果存在，加载View为根视图，如果不存在，则自动创建一个View作为根视图。</p>\n<p><strong>15、    简述UITableView中cell的复用机制。</strong></p>\n<p>UITableView会创建屏幕显示单元格个数（N）+1个单元格，当滑动到第N+2个单元格时就会复用第1个单元格。UITableView中还有单元格复用池的概念。<br>当tableView调用初始化单元格协议方法获取单元格时，它会根据你设定的reuse identifier先去复用池中查找可用的复用单元格，找到则复用该单元格，没找到这创建一个新的单元格对象。</p>\n<p><strong>本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！</strong></p>\n<p><strong>如需转载，请注明出处</strong></p>\n","excerpt":"<p><strong>1、    简述app启动周期。</strong></p>\n<p>打开应用程序，它先会执行main函数，再执行UIApplicationMain函数。初始化<br>UIApplication，设置代理对象，开启事件循环，调用代理方法进行事件处理。</p>\n<p>首先会调用application:didFinishLaunchingWithOptions:代理方法。</p>","more":"<p>接下来会调用applicationDidBecomeActive:代理方法。监听系统事件，结束程序。当程序正常退出UIApplicationMain函数才会返回。</p>\n<p>监听系统事件：</p>\n<p>锁屏后app会调用：applicationWillResignActive:代理方法。然后接着调用<br>applicationDidEnterBackground:方法。</p>\n<p>解锁后app会调用：applicationWillEnterForeground:代理方法。接着调用<br>applicationDidBecomeActive代理方法。</p>\n<p>杀死进程会调用：applicationWillTerminate:代理方法。</p>\n<p>接听电话：先调用applicationWillResignActive:代理方法。挂断电话后会直接进入<br>应用调：applicationDidBecomeActive:代理方法。</p>\n<p>出现内存警告会调用：applicationDidReceiveMemoryWarning:代理方法</p>\n<p><strong>2、    简单的说说UIApplication的作用及继承关系。</strong></p>\n<p>（1）UIApplication是继承UIResponder的。UIApplication是整个应用程序的核<br>心。每一个程序在运行期必须有UIApplication(或子类)的一个实例（有且只有一<br>个），通过[UIApplication shareApplication]可以得到这个单例实例。</p>\n<p>（2）UIApplication帮助管理应用程序的生命周期，通过delegate来履行任务。</p>\n<p>（3）UIApplication可以接收事件，把所有用户事件都放入队列，逐个处理。它会发送<br>当前事件给一个合适的目标控件进行处理。他还将部分事件转给delegate对象来处理。<br>delegate可以处理的事件包括：应用程序的生命周期事件（如程序启动与关闭）、系统事<br>件（如来电）。</p>\n<p><strong>3、    简述推送消息原理。</strong></p>\n<p>（1）应用程序注册接收远程通知的时候，系统会发送请求到APNS服务器。APNS服务器收<br>到请求后会根据请求所带的key值生成一个独一无二的deviceToken。然后APNS服务器会把deviceToken包装成NSData对象发送到对应请求的App上。接下来APP把deviceToken发送给我们自己的服务器（Provider）。服务器接收到deviceToken后进行存储等相关处理。服务器会把推送给用户的消息发送至APNS服务器，最后APNS服务器再发送通知给app。</p>\n<p>（2）有关于deviceToken变化问题：<br>重新安装或卸载应用程序，deviceToken不会发生变化。<br>系统升级deviceToken可能会发生变化。<br>抹掉所有内容和设置，重置设备后，deviceToken会变化</p>\n<p>（3）注册远程通知方法<br>注册远程通知：<br>一般在app启动完成的时候注册远程通知，注册方法一般在didFinishLaunchingWithOptions：代理方法中<br>处理注册远程通知回调方法：<br>注册成功会回调didRegisterForRometoNotificationsWithDeviceToken:其中的deviceToken参数就是APNS服务器返回的token。<br>注册失败会回调didFailToRegisterForRemoteNotificationsWithError:</p>\n<p>（4）处理接收到的远程通知消息<br>程序启动时，app从Terminate状态进入Foreground状态时，会根据didFinishLaunchingWithOptions:代理方法中的luanchOptions参数来获取userInfo。判断是否有推送消息。方式如下：</p>\n<p>   // userInfo为收到远程通知的内容<br>NSDictionary*userInfo=launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey];<br>if (userInfo) {   // 有推送的消息，处理推送的消息  }<br>如果app处于Background状态时，只有用户点击了通知消息才会调用didReceiveRemoteNotification:，如果当前app处于Foreground状态，会直接调用该方法。</p>\n<p><strong>4、    简单说下UITableView、UIButton、UIWindow控件的继承关系。</strong></p>\n<p>（1）UITableView的继承关系：UITableView继承UIScrollView。UIScrollView继承UIView。UIView继承UIResponder。UIResponder继承NSObject。</p>\n<p>（2）UIButton的继承关系：UIButton继承UIControl，UIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。</p>\n<p>（3）UIWindow继承UIView。</p>\n<p><strong>5、    UIView与UIButton有什么区别？UISwitch呢？</strong></p>\n<p>UIView继承自UIResponder，它能响应某个动作。UIButton继承UIControl。它不仅可以响应某个动作，还能为某个对象添加对应的动作加以响应。<br>UIButton也能实现UISwitch的功能，它们的区别是分发的事件不一样。</p>\n<p><strong>6、    简述UIControl的继承关系，它用来做什么？</strong></p>\n<p>UIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。它能为某个特定对象添加事件。能进行事件分发。</p>\n<p><strong>7、    简述UIViewController中view的生命周期。</strong></p>\n<p>先调用loadView方法，再调用viewDidLoad方法，调用viewWillAppear方法，调用viewWillLayoutSubviews方法，调用viewDidLayoutSubviews方法，再调用viewDidApper方法。控制器消失的时候先调用viewWillDisappear方法，再调用viewDidDisapper方法。最后调用dealloc方法。当出现内存警告的时候会调用didReceiveMemoryWarning方法。</p>\n<p><strong>8、    简述UITableView的代理方法调用顺序。</strong></p>\n<p>先调用numberOfSectionsInTableView:方法，</p>\n<p>numberOfRowsInSection:</p>\n<p>heightForRowAtIndexPath:</p>\n<p>cellForRowAtIndexPath:</p>\n<p><strong>9、    你在用CollectionView的时候有没有遇到什么问题？问题是怎么解决的？</strong></p>\n<p>刷新的时候会闪烁。在刷新的时候会默认附加一个隐式的fade动画。可以通过取消动画来达到取消闪烁的目的。</p>\n<p><strong>10、    简述UIResponder类的作用。</strong></p>\n<p>UIResponder类主要是为那些需要响应并处理事件的对象定义了一组接口。这些事件包括：触摸事件、运动事件、远程控制事件（如耳机控制音视频播放）。当用户触发某一事件时，UIKit会创建一个UIEvent事件对象，事件对象会加入到一个FIFO先进先出的队列中。UIApplication对象处理事件时，会从队列头部取出一个事件对象进行分发。</p>\n<p><strong>11、    如何监听View的触摸事件？事件如何传递？简述视图的响应者链。</strong></p>\n<p>可以通过View类的touchesBegan、touchesMoved、touchesEnded、touchesCancelled方法监听视图的触摸。</p>\n<p>当触摸一个视图对象时，系统会捕捉此事件，并给这个事件创建一个UIEvent对象，将此对象加入当前应用程序的事件队列中，然后由UIApplication对象从队列中取出来进行事件分发，首先会分发给UIWindow对象，然后由UIWindow对象分发给触摸的视图对象，即第一响应者对象。</p>\n<p>响应者链：当事件交给第一响应者处理，如果第一响应者不处理，事件就会沿着响应者链向上传递，交给下一个响应者。一般来说，第一响应者是一个视图对象或者是其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象，然后是它的父视图对象，以此类推，直到顶层视图。接下来会沿着顶层视图到UIWindow对象，再到UIApplication对象。如果整个过程都没有响应这个事件，该事件就会被丢弃，一般情况下，在响应者链中只要有对象处理事件，事件就会停止传递。有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。</p>\n<p><strong>12、    CALayer与UIView有什么区别？</strong></p>\n<p>（1）UIView是iOS系统中界面元素的继承。所有的界面元素都继承自它，他本身完全是由CoreAnimation来实现的。它真正的绘图部分，是由一个叫CALayer的类来管理。UIView本身更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，如frame,bounds等，实际上内部都是在访问它所包含的CALayer的相关属性。</p>\n<p>（2）UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示。</p>\n<p>（3）UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer。</p>\n<p>（4）CALayer坐标系统与UIView有点不一样，它多了一个anchorPoint的属性。</p>\n<p>（5）UIView的layer树形在系统内部，被系统维护着三份copy。逻辑树，动画树，显示树。</p>\n<p>（6）CALayer默认修改属性支持隐式动画</p>\n<p>（7）View可以接受并处理事件，Layer不可以。</p>\n<p><strong>13、    如何优化UITableView?</strong></p>\n<p>（1）复用单元格</p>\n<p>（2）使用不透明的视图，单元格中少使用动画。</p>\n<p>（3）图片使用异步加载，设置图片加载的并发数。</p>\n<p>（4）滑动时不加载图片，停止滑动时再加载。</p>\n<p>（5）图片和文字可以直接drawRect</p>\n<p>（6）如果cell是动态行高，计算缓存单元格高度</p>\n<p>（7）尽量少reloadData，只reloadRowsAtIndexPaths</p>\n<p>（8）cell高度固定直接用rowHeight属性设置高度。</p>\n<p><strong>14、    简述加载到控制器上的根视图创建与加载时机。</strong></p>\n<p>视图控制器的根视图加载是在UIViewController的loadView方法中。当视图控制中的loadView方法被调用时，会先通过NSBundle加载，通过控制器的类名作为xib文件名加载xib文件，如果存在，加载View为根视图，如果不存在，则自动创建一个View作为根视图。</p>\n<p><strong>15、    简述UITableView中cell的复用机制。</strong></p>\n<p>UITableView会创建屏幕显示单元格个数（N）+1个单元格，当滑动到第N+2个单元格时就会复用第1个单元格。UITableView中还有单元格复用池的概念。<br>当tableView调用初始化单元格协议方法获取单元格时，它会根据你设定的reuse identifier先去复用池中查找可用的复用单元格，找到则复用该单元格，没找到这创建一个新的单元格对象。</p>\n<p><strong>本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！</strong></p>\n<p><strong>如需转载，请注明出处</strong></p>"},{"layout":"post","title":"iOS面试题系列之Objective-C相关","date":"2016-04-24T15:58:04.000Z","comments":1,"keywords":"ios开发, iOS面试","_content":"\n**1、简述你项目中常用的设计模式。它们有什么优缺点？**\n\n\r常用的设计模式有：代理、观察者、单例。\n\n\r（1）单例：它是用来限制一个类只能创建一个对象。这个对象中的属性可以存储全局共享的数据。所有的类都能访问、设置此单例中的属性数据。\n\n\r优点：是它只会创建一个对象容易供外界访问，节约性能。\n<!--more-->\n\r缺点：是一个类只有一个对象，可能造成责任过重，在一定程度上违背了“单一职责原则”。单例模式中没有抽象层，所以单例类的扩展有很大的困难。不能过多创建单例，因为单例从创建到程序关闭前会一直存在，过多的单例会影响性能，浪费系统资源。\n\n\r（2）观察者（KVO）:它提供了观察某一属性变化的方法。当指定对象的属性发生改变后，它会自动通知相应的观察者。\n\n\r优点：能提供被观察者属性的新值与旧值。用keypaths来观察属性，因此也可以观察嵌套对象。 \n\n\r缺点：需要注册观察者，实现observeValueForKeyPath:方法，属性必须通过KVC的方法来修改。否则观察者收不到通知。\n\n\r（3）代理：可以实现类与类之间一对一的通信。\n\n\r优点：代理协议方法都有清晰的定义。代理方法可以设置可选或必须实现。\n\n\r缺点：需要定义协议方法，需要设置代理对象，代理对象实现协议方法。内存管理方面，需要注意循环引用问题。\n\n**2、代理模式能否实现一对多的通信？**\n\n\r可以，采用多播委托的方式来实现。多播委托：它是指允许创建方法的调用列表或者链表的能力。当多播委托被调用时，列表中的方法均自动执行。\n\n\r普通代理只能是一对一的回调，无法做到一对多的回调，而多播委托正式对delegate的一种扩展与延伸，多了一个注册和取消的过程。任何需要回调的对象都必须先注册。\n\n**3、\t重复注册通知会有问题吗？**\n\n\r不会出现问题，若多次发送同一通知，对方就会多次响应。如果重复注册通知，也会有多次响应的效果。为了避免重复注册通知而造成的错误，建议每次注册一个通知前，可以移除一次该通知。\n\n\n**4、项目中是否用过多线程编程？简述你常用的多线程实现方式？**\n\n\r常用的是GCD。\n\n\nGCD是苹果开发中一个多核编程的解决方案。GCD的队列分为两种类型，SerialDispatchQueue与ConcurrentDispatchQueue。系统默认提供了一个dispatch_get_main_queue，一个dispatch_get_global_queue。\n\n\n**5、简述NSOperationQueue与GCD的区别。**\n\n\r(1)\tGCD是底层的C语言构成的API。NSOperationQueue及相关对象是Objc对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构。而Operation作为一个对象，为我们提供了更多的选择。\n\n\r(2)\t在NSOperationQueue中，我们可以取消任务，而GCD没法停止已经加入queue的block。\n\n\r(3)\tNSOperation能够方便的设置依赖关系。还能设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行。在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务优先级也需要大量复杂代码。\rNSOperation还可以设置并发数。\n\n**6、实现多线程有哪几种方式？**\n\n\r（1）NSThread:detachNewThreadSelector:\n\n\r（2）继承NSOperation\n\n\r（3）GCD：dispatch_async\n\n\r（4）NSObject：performSelectorInBackground:\n\n\n**7、KVC、KVO是什么？简述KVO的实现原理。KVO能否监听数组？如何实现？**\n\n\rKVC:键值编码，它是一种间接访问对象实例变量机制，可以不通过存取方法访问对象的实例变量。\n\n\rKVO:键值观察，它可以使对象获取其他对象属性变化的通知机制。\n\n\r键值编码和键值观察是根据isa-swizzling技术来实现的，主要依据runtime的强大动态能力。当给某个对象第一次添加KVO监听的时候，运行时会动态的创建一个被监听对象的派生类，然后重写KVO需要监听属性值对应的setter方法，在这个setter方法中实现了通知机制。最后将被监听对象的isa指向动态创建的派生类。这样当使用KVC修改属性值时，就会调用动态创建的派生类中对应的setter方法，触发通知机制，从而实现了KVO了。\rKVO可以监听数组。\n\n\r实现 NSMutableArray 的增删改操作遵从 KVC 的规则，需要实现其对应方法:\n\n\r增操作 -insertObject:in<Key>AtIndex: 或者 -insert<Key>:atIndexes:\n\n\r删操作 -removeObjectFrom<Key>AtIndex: 或者 -remove<Key>AtIndexes:\n\n\r改操作 -replaceObjectIn<Key>AtIndex:withObject: 或者 -replace<Key>AtIndexes:with<Key>:\n\n\r并将这些接口暴露给调用者，在对数组进行操作时需使用上述实现的接口。\n\n\n**8、简单说下C++，JAVA，Objective-C这几种语言有什么区别？**\n\n\rObjective-C与JAVA都是单继承语言，C++是多继承语言。\n\n\rObjective-C不支持命名空间机制，通过类名前面加前缀NS来区分。\n\n\rObjective-C与JAVA不支持运算符重载。\n\n\rObjective-C协议可选实现，JAVA的接口必须实现。\n\n\n**9、数组添加nil元素有问题吗？字典object与key可以设置为nil吗？**\n\n\r会有问题，数组中添加nil元素，程序会崩溃！报object cannot be nil错误。字典的key不能为nil，否则会造成崩溃。字典的object也不能为nil。\n\n**10、oc中向一个nil对象发送消息会出现问题吗？**\n\n\r不会出现问题，因为objc是动态语言，每个方法在运行时会被动态转为消息发送。即：objc_msgSend(receiver，selector)。objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。\n\n\n**11、可变数组是线程安全的吗？什么情况下不安全？可以加锁吗？它锁住的是添加元素操作还是数组对象？**\n\n\r可变数组不是线程安全的，在异步读取数据的情况下是不安全的。可以加锁，锁住的是数组。\n\n\n**12、数组能添加一个block吗？数组添加一个block之后再取出来，这个block还有用吗？**\n\n\r可以，还有用，它只是多retain了一次\n\n\n**13、NSMutableDictionary中的setObject:forKey:与setValue:forKey:方法有什么区别?**\n\n\rsetObject:forkey:中value是不能够为nil的，不然会报错。\n\n\rsetValue:forKey:中的value能够为nil，但是当value为nil的时候，会自动调用removeObject:forKey方法。\n\n\rsetValue:forKey:中的key的参数只能是NSString类型，而setObject:forKey是可以任何类型。\n\n\n**14、简述copy与mutablecopy的区别。**\n\n\n\r（1）非容器对象：\n\n\r对不可变对象：copy是指针复制（浅拷贝）， mutableCopy是对象复制（深拷贝）。\r对可变对象：copy和mutableCopy都是对象复制。\n\n\r（2）容器对象：\n\n\r对不可变对象：copy是指针复制，mutableCopy是对象复制。\n\n\r对可变对象：copy和mutableCopy都是对象复制，只是返回的对象类型不一样，前者返回的是不可变对象，后者返回的是可变对象。\n\n\r容器对象复制仅限于对象本身，对象元素仍然是指针复制。\n\n\n**15、简述weak与assign的区别。**\n\n\rweak用来修饰对象，不能修饰基本数据类型。assign一般用来修饰基本数据类型。weak修饰对象，在对象释放之后会把对象置为nil。\n\n\n**16、ARC下，不显示指定任何属性关键字时，默认的关键字有哪些？**\n\n\r基本数据类型默认修饰关键字：atomic,readwrite,assign\n\n\r普通的OC对象默认修饰关键字：atomic,readwrite,strong\n\n\n**17、weak在什么时候置空？**\n\n\n\rruntime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。\n\n\r我们可以设计一个函数（伪代码）来表示上述机制：\n\n\robjc_storeWeak(&a, b)函数：\n\n\robjc_storeWeak函数把第二个参数--赋值对象（b）的内存地址作为键值key，将第一个参数--weak修饰的属性变量（a）的内存地址（&a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&a）从weak表中删除，\r你可以把objc_storeWeak(&a, b)理解为：objc_storeWeak(value, key)，并且当key变nil，将value置nil。\n\n\r在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。\n\n\r而如果a是由assign修饰的，则： 在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。\n\n\r下面我们将基于objc_storeWeak(&a, b)函数，使用伪代码模拟“runtime如何实现weak属性”：\n\n\r// 使用伪代码模拟：runtime如何实现weak属性\rid obj1;\robjc_initWeak(&obj1, obj);\r/*obj引用计数变为0，变量作用域结束*/\robjc_destroyWeak(&obj1);\n\n\r下面对用到的两个方法objc_initWeak和objc_destroyWeak做下解释：\n\n\r总体说来，作用是： 通过objc_initWeak函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过objc_destoryWeak函数释放该变量（obj1）。\n\n\r下面分别介绍下方法的内部实现：\n\n\robjc_initWeak函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用objc_storeWeak函数。\robj1 = 0；\robj_storeWeak(&obj1, obj);\n\n\r也就是说：\rweak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）\r然后obj_destroyWeak函数将0（nil）作为参数，调用objc_storeWeak函数。\robjc_storeWeak(&obj1, 0);\r前面的源代码与下列源代码相同。\n\n\r// 使用伪代码模拟：runtime如何实现weak属性\rid obj1;\robj1 = 0;\robjc_storeWeak(&obj1, obj);\r/* ... obj的引用计数变为0，被置nil ... */\robjc_storeWeak(&obj1, 0);\n\n\robjc_storeWeak函数把第二个参数--赋值对象（obj）的内存地址作为键值，将第一个参数--weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除，在后面的相关一题会详解。\n\n\r以上内容总结如下：\n\n\r（1）从weak表中获取废弃对象的地址为键值的记录\n\n\r（2）将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil\n\n\r（3）从weak表中删除该记录\n\n\r（4）从引用计数表中删除废弃对象的地址为键值的记录。\n\n\n**18、自动释放池用过吗？它是什么时候释放？什么情况下对象会被加入到自动释放池，它会加入到哪个自动释放池?**\n\n\n\r主线程默认开启runloop,同时runloop会自动创建一个autoreleasepool，autorelease对象会自动被加入autoreleasepool中，一次runloop后清空自动释放池。用__autoreleasing修饰符修饰，或类方法创建会自动加入autoreleasepool。它会加入到最近的autoreleasepool中。\n\n\n**19、你知道iOS中有哪些数据持久化方式吗？请简要加以说明。**\n\n\riOS中数据持久化方式有：SQLite3数据库，CoreData，文件归档，属性列表（plist文件写入）。\n\n\r属性列表：涉及的主要类是NSUserDefaults，存储小量的数据。\n\n\r文件归档：对象必须实现NSCoding协议。实现initWithCoder:方法与encodeWithCoder方法。同时也建议实现NSCopying协议。\n\n\rSQLite3数据库:SQLite是一个开源的嵌入式关系数据库。可移植性好，容易使用，需要内存开销小。适合嵌入式设备。\n\n\rCoreData：它可以使用SQLite保存数据，而且不需要写SQL语句。另外它还可以使用XML方式保存数据。要使用CoreData，需要在Xcode中的数据模型编辑器中设计好各个实体以及定义好他们的属性和关系。通过操作这些对象来完成数据的持久化。\n\n**20、fmdb中支持多线程吗？它是如何实现的！**\n\n\r支持多线程。它里面有个FMDatabaseQueue类。它看似是一个队列，实际上它本身并不是，它继承NSObject，通过内部创建一个Serial的dipatch_queue_t来处理inDatabase和inTransaction传入的Block，所以当我们在主线程（或者后台）调用inDatabase或者inTransaction时，代码实际上是同步的。FMDatabaseQueue如此设计的目的是为了避免并发访问数据库的线程安全问题，所有的数据库访问都是同步执行，比@synchronized与NSLock效率高。\n\n\n**21、简述category与extension的区别。Category与extension加载的时机。**\n\n\rcategory中只能增加方法，不可添加实例变量（可添加属性）。extension不仅可以增加方法，还可以增加实例变量或属性（私有的）。extension不能像category一样有独立的实现部分。category是运行时决定的。extension是编译期决定的。\n\n\n**22、category的方法能被子类继承吗？它覆盖原有类的方法后，原有类的方法还能调用吗？如果能，你说明理由。**\n\n\rcategory的方法可以被子类继承。category并不是绝对的覆盖了类的同名方法，而是category的方法排在了类的同名方法之前，方法的检索方式是顺序检索，所以在调用方法时，调用到的同名方法是category，从而产生了覆盖。\r利用运行时遍历方法列表，可以调用被category覆盖的方法。\n\n\n**23、\t扩展一个类的方式用继承好还是category好？请说明理由。**\n\n\r用类目好。因为继承还需要定义子类。类目不需要通过创建子类来增加现有类的方法。用category去重写一个类的方法，仅仅只对本category有效，不会影响到其他类与原有类的关系。\n\n\n**24、\tblock有几种类型？block的实现？**\n\n\rblock分为三种类型:\n\n\r_NSConcreteGlobalBlock\n\n\r_NSConcreteStackBlock\n\n\r_NSConcreteMallocBlock\n\n\rblock：匿名函数\n\n\n**25、\tSwift用的多吗？简单的说说1.0与2.0的区别。**\n\n\rswift2.0新增:guard语句，异常处理，协议扩展，打印语句改变，avaliable检查，do-while语句重命名：repeat-while，defer关键字\n\n\n**26、\t在Swift用有没有用过defer关键字？**\n\n\r对defer语句进行的延迟，函数结束时调用。\n\n\n**27、\tSDWebImage的图片保存在什么位置？**\n\n\r图片保存在沙盒中的library/caches文件夹下。\n\n\n**28、\tObjective-C中类目为什么不能添加实例变量？**\n\n\r因为在运行时，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局。\n\n\n**29、\tObjective-C中的协议默认是@optional还是@require？在使用协议的时候应当注意哪些问题？**\n\n\rObjective-C中的协议默是必须实现的@require，使用协议的时候应当注意循环引用问题，多个协议之间采用逗号分隔。\n\n\n**30、\tObjective-C的协议与JAVA中的接口有什么区别？**\n\rOC中的协议可选实现，JAVA中的接口必须实现。\n\n**31、\t类目的应用场景有哪些？**\n\n\r（1）可以把类的实现分开在几个不同的文件里面\n\n\r（2）声明私有方法\n\n\r（3）模拟多继承\n\n\r（4）把Framework的私有方法公开\n\n\n**32、\tself与super的区别？**\n\n\rsuper本质上是一个编译器标示符，它和self指向的是同一个消息接受者，两者不同在于：super会告诉编译器，调用class这个方法时，要去父类方法，而不是本类方法。\r\n**33、\t图片缓存为什么不保存到沙盒下的tmp文件目录中？**\n\n\r因为tmp文件夹是用来存放临时文件，iTunes不会备份和恢复此目录，此目录下文件可能会在应用退出后删除。\n\n\n**34、\tNSURLConnection与NSURLSession。**\n\rNSURLConnection它是CoreFoundation/CFNetwork框架的API之上的一个抽象。\n\nNSURLConnection这个名字实际指代Foundation框架的URL加载系统中一系列有关联的组件：NSURLRequest、NSURLResponse、NSURLProtocol、NSURLCache、NSHTTPCookieStorage、NSURLCredentialStorage以及同名类NSURLConnection。NSURLRequest 被传递给 NSURLConnection。被委托对象（遵守以前的非正式协议 <NSURLConnectionDelegate> 和 <NSURLConnectionDataDelegate>）异步地返回一个 NSURLResponse 以及包含服务器返回信息的 NSData。\n\n\rNSURLSession包括：NSURLRequest、NSURLCache、NSURLSession、NSURLSessionConfiguration、NSURLSessionDataTask、NSURLSessionUploadTask、NSURLSessionDownloadTask。\r它与NSURLConnection的区别在于：NSURLSession最直接的改进就是可以配置每个Session的缓存，协议，cookie以及正式策略。甚至跨程序共享这些信息。每个NSURLSession对象都由一个NSURLSessionConfiguration对象来进行初始化。\rsession task：负责处理数据的加载以及文件和数据在客户端与服务器之间的上次和下载。\n\n\n**35、\t简述ARC与MRC的区别。**\n\n\rARC:自动引用计数。MRC：手动引用计数。ARC是把内存交给系统管理。系统会在编译的时候自动插入retain/release。MRC则需要手动管理对象的引用计数。当你alloc,new,copy,mutablecopy或者retain一个对象时，你就有义务向它发送一条release或autorelease消息。\n\n**36、\t简述ARC的实现原理。它在什么时机插入retain/release？**\n\n\rARC：自动引用计数。它会在对象创建或者消亡的时候自动插入retain/release。达到自动管理内存的目的。\r\n\n**37、\tFramework与Library的区别？动态库与静态库的区别？**\n\rlibrary与Framework的区别：\n\n\r在iOS中，Library 仅能包含编译后的代码，即 .a 文件。\r但一般来说，一个完整的模块不仅有代码，还可能包含.h 头文修的、.nib 视图文件、图片资源文件、说明文档。（像 UMeng 提供的那些库，集成时，要把一堆的文件拖到Xcode中，配置起来真不是省心的事。\rFramework 作为 Cocoa/Cocoa Touch 中使用的一种资源打包方式，可以上述文件等集中打包在一起，方便开发者使用（就像Bundle）。\n\n\r静态库与动态库的区别：\n\n\r简单的说，静态链接库是指模块被编译合并到应用中，应用程序本身比较大，但不再需要依赖第三方库。运行多个含有该库的应用时，就会有多个该库的Copy在内存中，冗余。\r动态库可以分开发布，在运行时查找并载入到内存，如果有通用的库，可以共用，节省空间和内存。同时库也可以直接单独升级，或作为插件发布。\n\n\n**38、\t什么是runloop？**\n\n\r一般来说，一个线程一次只能执行一个任务，执行完成后线程就会退出，如果我们需要一个机制，让线程能随时处理事件但并不退出。代码逻辑如下：\n\n\n```\n\rfunction loop() {\r\t\tinitialize();\r\t\tdo {\r\tvar message = get_next_message();\r\tprocess_message(message);\r} while(message != quit)\r}\n\n```\n\n\r这种模型我们通常称之为EventLoop（事件循环）。RunLoop实际上是一个对象，这个对象管理了其需要处理的事件和消息。并提供了一个入口函数来执行上面EventLoop逻辑。在OSX/iOS系统中，提供了两个这样的对象：NSRunLoop和CFRunLoopRef。\n\n\rCFRunLoopRef是在CoreFoundation框架内，它提供了纯C函数的API,所有这些API都是线程安全的。\n\n\rNSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API，这些API不是线程安全的。\n\n\r苹果不允许直接创建RunLoop，只提供了两个自动获取的函数：CFRunLoopGetMain()和CFRunLoopGetCurrent()。\n\n\r线程和RunLoop之间是一一对应的。\n\n\n**39、#include与#import的区别？#import与@class的区别？**\n\n\r\"#include\"与\"#import\"功能一样，都是导出头文件。只是#import不会引起交叉编译，可以确保头文件只导入一次。#import会包含这个类的所有信息。包括实例变量和方法，而@class只是告诉编译器，它后面声明的名称是类的名称，至于类的定义，后面会告诉你。使用#import编译效率高，可以防止相互包含的编译错误。\n\n\n**40、Static与const的区别？**\n\rconst表示只读的意思，只在声明中使用。\n\n\rstatic一般有2个作用，规定作用域和存储方法。对于局部变量，static规定其为静态存储区，每次调用的初始值为上一次调用的值，调用结束后存储空间不释放。\n\n\r对于全局变量，如果以文件划分作用域的话，此变量只在当前文件可见，对于static函数也是在当前模块内函数可见。\n\n\n**41、简述GET请求与POST请求的区别。**\n\n\r(1)POST 需要明确制定方法 GET不需要 ，并且默认就是GET方法，并且GET有缓存，POST没有缓存\n\n\r(2)GET的参数放在URL的后面,并且第一个参数用?拼接,后面的从第二个参数开始,直到最后一个,如果有多个,用&分割;POST 的参数放在请求体里面,并且第一个参数,不用,后面从第二开始,直到最后,如果有多个,用&分割;\n\n\r(3)GET 一般用于获取数据，POST向服务器提交数据用到\n\n\r(4)GET的参数是暴漏在地址栏的,不安全;POST的参数隐藏在请求体里面,相对安全一点;\n\n\r(5)GET请求没有请求体，POST请求有请求体。\t\n\n\r(6)GET请求提交数据受浏览器限制，1k，POST请求理论上无限制。\r\n\n**42、属性用__block修饰时在内存中会发生什么变化？**\n\n为什么在block外面用weak修饰属性来打破循环，在block还需要把属性转换成strong。\n\n\n**43、谈谈block与函数的区别。**\n\n\rblock可以写在方法里面，函数需要写在方法外面。block可以访问方法中的局部变量。\n\n\n**44、你了解runloop吗？它有几种模式？简要的说下它的应用场景。**\n\n\rrunloop模式：\n\n\rDefault：\n\n\rNSDefaultRunLoopMode(Cocoa)、kCFRunLoopDefaultMode(CoreFoundation)\n\n\nConnection：\n\n\rNSConnectionReplyMode\n\n\rModal：\n\n\rNSModalPanelRunLoopMode\n\n\rEvent tracking:\n\n\rNSEventTrackingRunLoopMode\n\n\rCommon modes:\n\n\nNSRunLoopCommonModes(Cocoa)、kCFRunLoopCommonModes(CoreFoundation)\n\n\r应用场景：\n\n\r（1）使用端口或自定义输入源与其他线程通信。\n\n\r（2）在线程中使用计时器\n\n\r（3）使用任意的performSelector方法\n\n\r（4）保持线程去执行一个周期任务。\n\n\r**45、你工作中用到的版本管理工具是什么？**\n\n\r用的是git工具来进行版本管理。\n\n\n**46、你用过git工具吗？用过哪些常见的命令？**\n\n\rgit init，git add, git commit，git merge，git branch，git checkout，git pull，git push等\n\n\n**47、CoreAnimation常用的动画有哪些类型？**\n\n\r所有的核心动画的动画类都从CAAnimation类继承而来。CAAnimationGroup组动画，CATransition转场动画，CABasicAnimation:基础动画，CAKeyframeAnimation关键帧动画。\n\n\n**48、GCD中系统提供了几种queue？**\n\n\r两种：DispatchSerialQueue、DispatchConcurrentQueue。\n\n\n**49、二叉搜索树的概念及时间复杂度是多少？**\n\n\rO(n)\n\n\n**50、block中的weak self，是任何时候都需要加的么？**\n\n\r不一定，可加可不加。将block置nil也可以打破循环引用。\n\n\n**51、GCD的queue，main queue中执行的代码，一定是在main thread么？**\n\n\n是的。一定是在main thread。\n\n\n**52、你在使用数据库的过程中有没有遇到过问题？如何解决？**\n\n\r遇到过多线程操作数据库读写死锁问题，采用fmdb中提供的回滚的方式解决\r\n\n**53、简述iOS中的沙盒机制。**\n\n\riOS中的沙盒机制是一种安全体系，它规定了应用程序只能在为该应用创建的文件夹读取文件，不可以访问其他地方的内容。所有非代码文件都保存在这个地方。如图片，声音，属性列表及文本文件等。\n\n\r（1）每个应用程序都在自己的沙盒内\n\n\r（2）不能随意跨越自己的沙盒去访问别的应用程序沙盒的内容\n\n\r（3）应用程序向外请求或者接收数据都需要经过权限认证。\n\n\r沙盒目录结构这种，因为应用是在沙箱（sandbox）中的，在文件读写权限上受到限制，只能在几个目录下读写文件：\n\n\rDocuments：应用中用户数据可以放在这里，iTunes备份和恢复的时候会包括此目录\n\n\rtmp：存放临时文件，iTunes不会备份和恢复此目录，此目录下文件可能会在应用退出后删除\n\n\nLibrary：存储程序的默认设置或其他状态信息。\n\n\rLibrary/Caches：存放缓存文件，iTunes不会备份此目录，此目录下文件不会在应用退出删除\n\n\n**54、字符串为什么要用copy修饰？**\n\n\r是为了防止mutablestring被无意中修改，NSMutableString是NSString的子类。因此NSString指针可以持有NSMutableString对象。\r\n\n**55、nonatomic与atomic有什么区别？**\n\n\ratomic是Objective-C使用的一种线程保护技术，它是为了防止写操作在未完成的时候被另外一个线程读取。从而造成数据错误。这种机制是非常耗费系统资源的，所以在iphone这种小的移动设备上，如果没有使用多线程间的通讯编程。建议使用nonatomic。\n\n\r默认的访问器是原子操作，就是说在多线程环境下，解析的访问器提供一个对属性安全访问，从获取器得到的返回值或者通过设置器设置的值可以一次完成，即便是多线程也在对其进行访问，如果不指定nonatomic ，在自己管理内存的环境中，解析的访问器保留并自动释放保留的值，如果是指定了nonatomic，访问器只是简单的返回一个值。\n\n\n**56、@synthesize与@dynamic的区别？**\n\n\r@synthesize：如果你没有手动实现setter方法和getter方法，编译器会自动为帮你生成setter方法和getter方法。\n\n\r@dynamic：告诉编译器属性的setter和getter方法由用户自己实现，不自动生成。如果一个属性声明为@dynamic var，又没有提供setter和getter方法，编译的时候不会有问题，如果程序中运行到person.name = newName;或newName=person.name时候就会导致程序崩溃。因为”unrecognized selector sent to instance …”这就是动态绑定。\n\n\n**57、@property(copy)NSMutableArray *array;这句代码有什么问题？如果有请简述原因；**\n\n\r（1）添加、删除、修改数组内的元素的时候，程序会因为找不到对应的方法而崩溃，因为copy就是复制一个不可变的NSArray对象。\n\n\r（2）没有使用nonatomic属性修饰符，默认是 atomic修饰，这样会严重影响性能。\n\n\n**58、NSString *str = @“hello world!”与NSString *str =  [[NSString alloc] initWithString:@\"hello world!”];在内存管理上有什么区别？**\n\n\r在MRC中，前者表示，你不持有这个对象，所以不需要手动管理其内存。后者意味着你持有这个字符串，需要自己手动管理内存，对其进行释放。\n\n\n**59、对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别是什么类型的对象?**\n\n\r编译时是NSString类型对象，运行时时NSData类型对象\r首先，声明NSString*testObject是告诉编译器,obj是一个指向某个Objective-C对象的指针，因为不管指向的是什么类型的对象，一个指针所占的内存空间都是固定的，所以这里声明称任何类型的对象，最终生成的可执行代码都是没有区别的。这里限定了NSString只不过是告诉编译器，请把obj当做一个NSString来检查，如果后面调用了非NSString的方法，会产生警告，接着，你创建了一个NSData对象，然后把这个对象所在的内存地址保存在obj里。那么运行时，obj指向的内存空间就是一个NSData对象。你可以把obj当做一个NSData对象来用。\n\n**60、self.name=object与name=object在内存管理上有什么区别？**\n\n\r前者通过调用setter方法设置值，后者是普通的赋值操作。\n\n\n**61、为什么property声明中只有”copy”特性而没有“mutableCopy”特性？**\n\n\r这是由于当声明property为\"copy\"特性时，系统会自动根据receiver的特点决定使用copy（已含retain的情况）还是mutableCopy。\n\n\n**62、Objective-C中id与void*有什么区别？id与instancetype有什么区别？nil、null、NULL三者有什么区别？**\n\n\rObjective-C中id与void*区别：\n\n\rid是指向OC类对象的指针，它可以声明为任何类对象的指针，当在OC中使用id时，编译器会假定你知道，id指向哪个类的对象。与void*不同，void*编译器不知道也不假定指向任何类型的指针。\n\n\rid与instancetype区别：\n\n\rid返回的是id类型，instancetype返回的是所在类的类型。\n\n\r相同点是同样都是作为方法的返回类型。\n\n\r区别：\n\n\r(1)\tinstancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象。\n\n\r(2)\tinstancetype只能作为返回值，id可以作为参数。\n\n\rnil、Nil、NULL三者区别：\n\n\rnil是一个指向不存在的对象指针（对象空指针）。Nil是指向不存在的类指针（类空指针）。NULL指向其他类型的空指针。NSNull在集合对象中，表示空值的对象。\n\n\n**63、数据解析方式有几种？他们有什么区别？你项目中采用的是哪种数据解析方式？**\n\n\rJSON和XML。\n\n\n**64、用预处理指令#define声明一个常数，用以表明1年中有多少秒（忽略闰年问题）**\n\n\r“#define SECONDS_PER_YEAR(60*60*24*365)UL”\n\n\r**65、写一个”标准\"宏MIN ，这个宏输入两个参数并返回较小的一个。**\n\n\r“#define MIN(X,Y) ((X)>(Y)?(X):(Y))”\n\n\n**66、+load和+initialize 的区别是什么？**\n\n\r+initialize:第一次初始化这个类之前被调用，我们用它来初始化静态变量。\n\n\r+load方法会在加载类的时候就被调用，也就是iOS应用启动的时候，就会加载所有的类。\n\n\r+initialize方法类似一个懒加载，如果没有使用这个类，系统默认不会去调用这个方法，且默认只加载一次。\n\n\r如果是在类别中，+load方法会全都执行，但是类别中的load方法会后于类中的方法，+initialize方法会覆盖类中的方法，只执行一个。\n\n\r+initialize的调用发生在+init方法之前。子类会去调用父类的+initialize方法。\n\n\n**67、new和alloc/init的区别**\n\n\r概括来说，new和alloc/init在功能上几乎是一致的，分配内存并完成初始化。\r差别在于，采用new的方式只能采用默认的init方法完成初始化。\r而采用alloc的方式可以用其他定制的初始化方法。\n\n\n**68、如果让你设计接口与API，应该注意点什么？**\n\n\r（1）用前缀避免命名空间冲突\n\n\r（2）提供“全能初始化方法”\n\n\r（3）实现description方法\n\n\r（4）尽量使用不可变对象\n\n\r（5）使用清晰而协调的命名方法\n\n\r（6）为私有方法名加前缀\n\n\r（7）错误处理\n\n\r（8）实现NSCopying协议。\n\n\n**69、你在项目中用过懒加载吗？能简单的说说懒加载吗？**\n\n\r懒加载又称为延迟加载。写的是其get方法。如果是懒加载的话则一定要注意先判断是否已经有了，如果没有那么再去进行实例化。\n\n\r好处是不必将创建对象的代码全部写在viewDidLoad方法中，代码的可读性更强。每个控件的getter方法中分别负责各自的实例化处理，代码彼此之间的独立性强，松耦合。\n\n\n**70、进程和线程的区别与联系。**\n\n\r进程是个静态的容器，里面容纳了很多个线程，线程是一系列方法的线性执行路径。\n\n\n**71、简述内存分区情况。**\n\n\r栈区：存放函数的参数值，局部变量的值等。由编译器自动分配释放\n\n\r堆区：由程序员分配释放。程序员如果不释放，则程序结束时可能由系统回收\n\n\r全局区：全局变量和静态变量是存储在一块的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在另一块区域。程序结束后由系统释放。全局区可分为未初始化全局区：.bbs段和初始化全局区：data段。\n\n\r常量区：存放常量字符串，程序结束后由系统释放\n\n\r代码区：存放函数体的二进制代码。\n\n**72、队列与栈有什么区别?**\n\n\r栈：限定仅在表尾进行插入或删除操作的线性表。表尾是栈顶，表头是栈底。它又称后进先出线性表。\n\n\r队列：是一种先进先出的线性表。它只允许在表的一端进行插入，而在另一端删除元素。\n\n\n**73、Objective-C中多线程的编程方式有几种**\n\n\rpthread、NSThread、NSOperation、GCD。\n\n**74、Objective-C运行时（runtime）机制了解吗？简单的说说对象调用方法的过程。**\n\n\r对象调用方法的过程：(<a href=\"http://tech.glowing.com/cn/objective-c-runtime/\">Objective-C Runtime</a>)\n\n\r（1）在对象类的dispatch table中尝试找到该消息。如果找到了，跳到相应的函数IMP去执行实现代码\n\n\r（2）如果没有找到，Runtime会发送+resolveInstanceMethod: 或者 +resolveClassMethod: 尝试去resolve这个消息\n\n\r（3）如果resolve方法返回NO，Runtime就发送 -forwardingTargetForSelector: 允许你把这个消息转发给另一个对象；\n\n（4）如果没有新的目标对象返回，Runtime 就会发送 -methodSignatureForSelector: 和 -forwardInvocation: 消息。你可以发送 -invokeWithTarget: 消息来手动转发消息或者发送 -doesNotRecognizeSelector: 抛出异常。\n\n\n\n**参考资料如下：**\n\n\n（1）<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md\" target=\"_blank\">《招聘一个靠谱的 iOS》—参考答案（上）</a>\n\n\n（2）<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md\" target=\"_blank\">《招聘一个靠谱的 iOS》—参考答案（下）</a>\n\n\n**本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！**\n\n**如需转载，请注明出处**\n\n\r","source":"_posts/2016-04-24-iosmian-shi-ti-zhi-objective-cji-chu.markdown","raw":"---\nlayout: post\ntitle: \"iOS面试题系列之Objective-C相关\"\ndate: 2016-04-24 23:58:04 +0800\ncomments: true\ntags: [iOS, xcode, iOS面试]\nkeywords: ios开发, iOS面试\ncategories: Others\n---\n\n**1、简述你项目中常用的设计模式。它们有什么优缺点？**\n\n\r常用的设计模式有：代理、观察者、单例。\n\n\r（1）单例：它是用来限制一个类只能创建一个对象。这个对象中的属性可以存储全局共享的数据。所有的类都能访问、设置此单例中的属性数据。\n\n\r优点：是它只会创建一个对象容易供外界访问，节约性能。\n<!--more-->\n\r缺点：是一个类只有一个对象，可能造成责任过重，在一定程度上违背了“单一职责原则”。单例模式中没有抽象层，所以单例类的扩展有很大的困难。不能过多创建单例，因为单例从创建到程序关闭前会一直存在，过多的单例会影响性能，浪费系统资源。\n\n\r（2）观察者（KVO）:它提供了观察某一属性变化的方法。当指定对象的属性发生改变后，它会自动通知相应的观察者。\n\n\r优点：能提供被观察者属性的新值与旧值。用keypaths来观察属性，因此也可以观察嵌套对象。 \n\n\r缺点：需要注册观察者，实现observeValueForKeyPath:方法，属性必须通过KVC的方法来修改。否则观察者收不到通知。\n\n\r（3）代理：可以实现类与类之间一对一的通信。\n\n\r优点：代理协议方法都有清晰的定义。代理方法可以设置可选或必须实现。\n\n\r缺点：需要定义协议方法，需要设置代理对象，代理对象实现协议方法。内存管理方面，需要注意循环引用问题。\n\n**2、代理模式能否实现一对多的通信？**\n\n\r可以，采用多播委托的方式来实现。多播委托：它是指允许创建方法的调用列表或者链表的能力。当多播委托被调用时，列表中的方法均自动执行。\n\n\r普通代理只能是一对一的回调，无法做到一对多的回调，而多播委托正式对delegate的一种扩展与延伸，多了一个注册和取消的过程。任何需要回调的对象都必须先注册。\n\n**3、\t重复注册通知会有问题吗？**\n\n\r不会出现问题，若多次发送同一通知，对方就会多次响应。如果重复注册通知，也会有多次响应的效果。为了避免重复注册通知而造成的错误，建议每次注册一个通知前，可以移除一次该通知。\n\n\n**4、项目中是否用过多线程编程？简述你常用的多线程实现方式？**\n\n\r常用的是GCD。\n\n\nGCD是苹果开发中一个多核编程的解决方案。GCD的队列分为两种类型，SerialDispatchQueue与ConcurrentDispatchQueue。系统默认提供了一个dispatch_get_main_queue，一个dispatch_get_global_queue。\n\n\n**5、简述NSOperationQueue与GCD的区别。**\n\n\r(1)\tGCD是底层的C语言构成的API。NSOperationQueue及相关对象是Objc对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构。而Operation作为一个对象，为我们提供了更多的选择。\n\n\r(2)\t在NSOperationQueue中，我们可以取消任务，而GCD没法停止已经加入queue的block。\n\n\r(3)\tNSOperation能够方便的设置依赖关系。还能设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行。在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务优先级也需要大量复杂代码。\rNSOperation还可以设置并发数。\n\n**6、实现多线程有哪几种方式？**\n\n\r（1）NSThread:detachNewThreadSelector:\n\n\r（2）继承NSOperation\n\n\r（3）GCD：dispatch_async\n\n\r（4）NSObject：performSelectorInBackground:\n\n\n**7、KVC、KVO是什么？简述KVO的实现原理。KVO能否监听数组？如何实现？**\n\n\rKVC:键值编码，它是一种间接访问对象实例变量机制，可以不通过存取方法访问对象的实例变量。\n\n\rKVO:键值观察，它可以使对象获取其他对象属性变化的通知机制。\n\n\r键值编码和键值观察是根据isa-swizzling技术来实现的，主要依据runtime的强大动态能力。当给某个对象第一次添加KVO监听的时候，运行时会动态的创建一个被监听对象的派生类，然后重写KVO需要监听属性值对应的setter方法，在这个setter方法中实现了通知机制。最后将被监听对象的isa指向动态创建的派生类。这样当使用KVC修改属性值时，就会调用动态创建的派生类中对应的setter方法，触发通知机制，从而实现了KVO了。\rKVO可以监听数组。\n\n\r实现 NSMutableArray 的增删改操作遵从 KVC 的规则，需要实现其对应方法:\n\n\r增操作 -insertObject:in<Key>AtIndex: 或者 -insert<Key>:atIndexes:\n\n\r删操作 -removeObjectFrom<Key>AtIndex: 或者 -remove<Key>AtIndexes:\n\n\r改操作 -replaceObjectIn<Key>AtIndex:withObject: 或者 -replace<Key>AtIndexes:with<Key>:\n\n\r并将这些接口暴露给调用者，在对数组进行操作时需使用上述实现的接口。\n\n\n**8、简单说下C++，JAVA，Objective-C这几种语言有什么区别？**\n\n\rObjective-C与JAVA都是单继承语言，C++是多继承语言。\n\n\rObjective-C不支持命名空间机制，通过类名前面加前缀NS来区分。\n\n\rObjective-C与JAVA不支持运算符重载。\n\n\rObjective-C协议可选实现，JAVA的接口必须实现。\n\n\n**9、数组添加nil元素有问题吗？字典object与key可以设置为nil吗？**\n\n\r会有问题，数组中添加nil元素，程序会崩溃！报object cannot be nil错误。字典的key不能为nil，否则会造成崩溃。字典的object也不能为nil。\n\n**10、oc中向一个nil对象发送消息会出现问题吗？**\n\n\r不会出现问题，因为objc是动态语言，每个方法在运行时会被动态转为消息发送。即：objc_msgSend(receiver，selector)。objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。\n\n\n**11、可变数组是线程安全的吗？什么情况下不安全？可以加锁吗？它锁住的是添加元素操作还是数组对象？**\n\n\r可变数组不是线程安全的，在异步读取数据的情况下是不安全的。可以加锁，锁住的是数组。\n\n\n**12、数组能添加一个block吗？数组添加一个block之后再取出来，这个block还有用吗？**\n\n\r可以，还有用，它只是多retain了一次\n\n\n**13、NSMutableDictionary中的setObject:forKey:与setValue:forKey:方法有什么区别?**\n\n\rsetObject:forkey:中value是不能够为nil的，不然会报错。\n\n\rsetValue:forKey:中的value能够为nil，但是当value为nil的时候，会自动调用removeObject:forKey方法。\n\n\rsetValue:forKey:中的key的参数只能是NSString类型，而setObject:forKey是可以任何类型。\n\n\n**14、简述copy与mutablecopy的区别。**\n\n\n\r（1）非容器对象：\n\n\r对不可变对象：copy是指针复制（浅拷贝）， mutableCopy是对象复制（深拷贝）。\r对可变对象：copy和mutableCopy都是对象复制。\n\n\r（2）容器对象：\n\n\r对不可变对象：copy是指针复制，mutableCopy是对象复制。\n\n\r对可变对象：copy和mutableCopy都是对象复制，只是返回的对象类型不一样，前者返回的是不可变对象，后者返回的是可变对象。\n\n\r容器对象复制仅限于对象本身，对象元素仍然是指针复制。\n\n\n**15、简述weak与assign的区别。**\n\n\rweak用来修饰对象，不能修饰基本数据类型。assign一般用来修饰基本数据类型。weak修饰对象，在对象释放之后会把对象置为nil。\n\n\n**16、ARC下，不显示指定任何属性关键字时，默认的关键字有哪些？**\n\n\r基本数据类型默认修饰关键字：atomic,readwrite,assign\n\n\r普通的OC对象默认修饰关键字：atomic,readwrite,strong\n\n\n**17、weak在什么时候置空？**\n\n\n\rruntime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。\n\n\r我们可以设计一个函数（伪代码）来表示上述机制：\n\n\robjc_storeWeak(&a, b)函数：\n\n\robjc_storeWeak函数把第二个参数--赋值对象（b）的内存地址作为键值key，将第一个参数--weak修饰的属性变量（a）的内存地址（&a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&a）从weak表中删除，\r你可以把objc_storeWeak(&a, b)理解为：objc_storeWeak(value, key)，并且当key变nil，将value置nil。\n\n\r在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。\n\n\r而如果a是由assign修饰的，则： 在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。\n\n\r下面我们将基于objc_storeWeak(&a, b)函数，使用伪代码模拟“runtime如何实现weak属性”：\n\n\r// 使用伪代码模拟：runtime如何实现weak属性\rid obj1;\robjc_initWeak(&obj1, obj);\r/*obj引用计数变为0，变量作用域结束*/\robjc_destroyWeak(&obj1);\n\n\r下面对用到的两个方法objc_initWeak和objc_destroyWeak做下解释：\n\n\r总体说来，作用是： 通过objc_initWeak函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过objc_destoryWeak函数释放该变量（obj1）。\n\n\r下面分别介绍下方法的内部实现：\n\n\robjc_initWeak函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用objc_storeWeak函数。\robj1 = 0；\robj_storeWeak(&obj1, obj);\n\n\r也就是说：\rweak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）\r然后obj_destroyWeak函数将0（nil）作为参数，调用objc_storeWeak函数。\robjc_storeWeak(&obj1, 0);\r前面的源代码与下列源代码相同。\n\n\r// 使用伪代码模拟：runtime如何实现weak属性\rid obj1;\robj1 = 0;\robjc_storeWeak(&obj1, obj);\r/* ... obj的引用计数变为0，被置nil ... */\robjc_storeWeak(&obj1, 0);\n\n\robjc_storeWeak函数把第二个参数--赋值对象（obj）的内存地址作为键值，将第一个参数--weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除，在后面的相关一题会详解。\n\n\r以上内容总结如下：\n\n\r（1）从weak表中获取废弃对象的地址为键值的记录\n\n\r（2）将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil\n\n\r（3）从weak表中删除该记录\n\n\r（4）从引用计数表中删除废弃对象的地址为键值的记录。\n\n\n**18、自动释放池用过吗？它是什么时候释放？什么情况下对象会被加入到自动释放池，它会加入到哪个自动释放池?**\n\n\n\r主线程默认开启runloop,同时runloop会自动创建一个autoreleasepool，autorelease对象会自动被加入autoreleasepool中，一次runloop后清空自动释放池。用__autoreleasing修饰符修饰，或类方法创建会自动加入autoreleasepool。它会加入到最近的autoreleasepool中。\n\n\n**19、你知道iOS中有哪些数据持久化方式吗？请简要加以说明。**\n\n\riOS中数据持久化方式有：SQLite3数据库，CoreData，文件归档，属性列表（plist文件写入）。\n\n\r属性列表：涉及的主要类是NSUserDefaults，存储小量的数据。\n\n\r文件归档：对象必须实现NSCoding协议。实现initWithCoder:方法与encodeWithCoder方法。同时也建议实现NSCopying协议。\n\n\rSQLite3数据库:SQLite是一个开源的嵌入式关系数据库。可移植性好，容易使用，需要内存开销小。适合嵌入式设备。\n\n\rCoreData：它可以使用SQLite保存数据，而且不需要写SQL语句。另外它还可以使用XML方式保存数据。要使用CoreData，需要在Xcode中的数据模型编辑器中设计好各个实体以及定义好他们的属性和关系。通过操作这些对象来完成数据的持久化。\n\n**20、fmdb中支持多线程吗？它是如何实现的！**\n\n\r支持多线程。它里面有个FMDatabaseQueue类。它看似是一个队列，实际上它本身并不是，它继承NSObject，通过内部创建一个Serial的dipatch_queue_t来处理inDatabase和inTransaction传入的Block，所以当我们在主线程（或者后台）调用inDatabase或者inTransaction时，代码实际上是同步的。FMDatabaseQueue如此设计的目的是为了避免并发访问数据库的线程安全问题，所有的数据库访问都是同步执行，比@synchronized与NSLock效率高。\n\n\n**21、简述category与extension的区别。Category与extension加载的时机。**\n\n\rcategory中只能增加方法，不可添加实例变量（可添加属性）。extension不仅可以增加方法，还可以增加实例变量或属性（私有的）。extension不能像category一样有独立的实现部分。category是运行时决定的。extension是编译期决定的。\n\n\n**22、category的方法能被子类继承吗？它覆盖原有类的方法后，原有类的方法还能调用吗？如果能，你说明理由。**\n\n\rcategory的方法可以被子类继承。category并不是绝对的覆盖了类的同名方法，而是category的方法排在了类的同名方法之前，方法的检索方式是顺序检索，所以在调用方法时，调用到的同名方法是category，从而产生了覆盖。\r利用运行时遍历方法列表，可以调用被category覆盖的方法。\n\n\n**23、\t扩展一个类的方式用继承好还是category好？请说明理由。**\n\n\r用类目好。因为继承还需要定义子类。类目不需要通过创建子类来增加现有类的方法。用category去重写一个类的方法，仅仅只对本category有效，不会影响到其他类与原有类的关系。\n\n\n**24、\tblock有几种类型？block的实现？**\n\n\rblock分为三种类型:\n\n\r_NSConcreteGlobalBlock\n\n\r_NSConcreteStackBlock\n\n\r_NSConcreteMallocBlock\n\n\rblock：匿名函数\n\n\n**25、\tSwift用的多吗？简单的说说1.0与2.0的区别。**\n\n\rswift2.0新增:guard语句，异常处理，协议扩展，打印语句改变，avaliable检查，do-while语句重命名：repeat-while，defer关键字\n\n\n**26、\t在Swift用有没有用过defer关键字？**\n\n\r对defer语句进行的延迟，函数结束时调用。\n\n\n**27、\tSDWebImage的图片保存在什么位置？**\n\n\r图片保存在沙盒中的library/caches文件夹下。\n\n\n**28、\tObjective-C中类目为什么不能添加实例变量？**\n\n\r因为在运行时，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局。\n\n\n**29、\tObjective-C中的协议默认是@optional还是@require？在使用协议的时候应当注意哪些问题？**\n\n\rObjective-C中的协议默是必须实现的@require，使用协议的时候应当注意循环引用问题，多个协议之间采用逗号分隔。\n\n\n**30、\tObjective-C的协议与JAVA中的接口有什么区别？**\n\rOC中的协议可选实现，JAVA中的接口必须实现。\n\n**31、\t类目的应用场景有哪些？**\n\n\r（1）可以把类的实现分开在几个不同的文件里面\n\n\r（2）声明私有方法\n\n\r（3）模拟多继承\n\n\r（4）把Framework的私有方法公开\n\n\n**32、\tself与super的区别？**\n\n\rsuper本质上是一个编译器标示符，它和self指向的是同一个消息接受者，两者不同在于：super会告诉编译器，调用class这个方法时，要去父类方法，而不是本类方法。\r\n**33、\t图片缓存为什么不保存到沙盒下的tmp文件目录中？**\n\n\r因为tmp文件夹是用来存放临时文件，iTunes不会备份和恢复此目录，此目录下文件可能会在应用退出后删除。\n\n\n**34、\tNSURLConnection与NSURLSession。**\n\rNSURLConnection它是CoreFoundation/CFNetwork框架的API之上的一个抽象。\n\nNSURLConnection这个名字实际指代Foundation框架的URL加载系统中一系列有关联的组件：NSURLRequest、NSURLResponse、NSURLProtocol、NSURLCache、NSHTTPCookieStorage、NSURLCredentialStorage以及同名类NSURLConnection。NSURLRequest 被传递给 NSURLConnection。被委托对象（遵守以前的非正式协议 <NSURLConnectionDelegate> 和 <NSURLConnectionDataDelegate>）异步地返回一个 NSURLResponse 以及包含服务器返回信息的 NSData。\n\n\rNSURLSession包括：NSURLRequest、NSURLCache、NSURLSession、NSURLSessionConfiguration、NSURLSessionDataTask、NSURLSessionUploadTask、NSURLSessionDownloadTask。\r它与NSURLConnection的区别在于：NSURLSession最直接的改进就是可以配置每个Session的缓存，协议，cookie以及正式策略。甚至跨程序共享这些信息。每个NSURLSession对象都由一个NSURLSessionConfiguration对象来进行初始化。\rsession task：负责处理数据的加载以及文件和数据在客户端与服务器之间的上次和下载。\n\n\n**35、\t简述ARC与MRC的区别。**\n\n\rARC:自动引用计数。MRC：手动引用计数。ARC是把内存交给系统管理。系统会在编译的时候自动插入retain/release。MRC则需要手动管理对象的引用计数。当你alloc,new,copy,mutablecopy或者retain一个对象时，你就有义务向它发送一条release或autorelease消息。\n\n**36、\t简述ARC的实现原理。它在什么时机插入retain/release？**\n\n\rARC：自动引用计数。它会在对象创建或者消亡的时候自动插入retain/release。达到自动管理内存的目的。\r\n\n**37、\tFramework与Library的区别？动态库与静态库的区别？**\n\rlibrary与Framework的区别：\n\n\r在iOS中，Library 仅能包含编译后的代码，即 .a 文件。\r但一般来说，一个完整的模块不仅有代码，还可能包含.h 头文修的、.nib 视图文件、图片资源文件、说明文档。（像 UMeng 提供的那些库，集成时，要把一堆的文件拖到Xcode中，配置起来真不是省心的事。\rFramework 作为 Cocoa/Cocoa Touch 中使用的一种资源打包方式，可以上述文件等集中打包在一起，方便开发者使用（就像Bundle）。\n\n\r静态库与动态库的区别：\n\n\r简单的说，静态链接库是指模块被编译合并到应用中，应用程序本身比较大，但不再需要依赖第三方库。运行多个含有该库的应用时，就会有多个该库的Copy在内存中，冗余。\r动态库可以分开发布，在运行时查找并载入到内存，如果有通用的库，可以共用，节省空间和内存。同时库也可以直接单独升级，或作为插件发布。\n\n\n**38、\t什么是runloop？**\n\n\r一般来说，一个线程一次只能执行一个任务，执行完成后线程就会退出，如果我们需要一个机制，让线程能随时处理事件但并不退出。代码逻辑如下：\n\n\n```\n\rfunction loop() {\r\t\tinitialize();\r\t\tdo {\r\tvar message = get_next_message();\r\tprocess_message(message);\r} while(message != quit)\r}\n\n```\n\n\r这种模型我们通常称之为EventLoop（事件循环）。RunLoop实际上是一个对象，这个对象管理了其需要处理的事件和消息。并提供了一个入口函数来执行上面EventLoop逻辑。在OSX/iOS系统中，提供了两个这样的对象：NSRunLoop和CFRunLoopRef。\n\n\rCFRunLoopRef是在CoreFoundation框架内，它提供了纯C函数的API,所有这些API都是线程安全的。\n\n\rNSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API，这些API不是线程安全的。\n\n\r苹果不允许直接创建RunLoop，只提供了两个自动获取的函数：CFRunLoopGetMain()和CFRunLoopGetCurrent()。\n\n\r线程和RunLoop之间是一一对应的。\n\n\n**39、#include与#import的区别？#import与@class的区别？**\n\n\r\"#include\"与\"#import\"功能一样，都是导出头文件。只是#import不会引起交叉编译，可以确保头文件只导入一次。#import会包含这个类的所有信息。包括实例变量和方法，而@class只是告诉编译器，它后面声明的名称是类的名称，至于类的定义，后面会告诉你。使用#import编译效率高，可以防止相互包含的编译错误。\n\n\n**40、Static与const的区别？**\n\rconst表示只读的意思，只在声明中使用。\n\n\rstatic一般有2个作用，规定作用域和存储方法。对于局部变量，static规定其为静态存储区，每次调用的初始值为上一次调用的值，调用结束后存储空间不释放。\n\n\r对于全局变量，如果以文件划分作用域的话，此变量只在当前文件可见，对于static函数也是在当前模块内函数可见。\n\n\n**41、简述GET请求与POST请求的区别。**\n\n\r(1)POST 需要明确制定方法 GET不需要 ，并且默认就是GET方法，并且GET有缓存，POST没有缓存\n\n\r(2)GET的参数放在URL的后面,并且第一个参数用?拼接,后面的从第二个参数开始,直到最后一个,如果有多个,用&分割;POST 的参数放在请求体里面,并且第一个参数,不用,后面从第二开始,直到最后,如果有多个,用&分割;\n\n\r(3)GET 一般用于获取数据，POST向服务器提交数据用到\n\n\r(4)GET的参数是暴漏在地址栏的,不安全;POST的参数隐藏在请求体里面,相对安全一点;\n\n\r(5)GET请求没有请求体，POST请求有请求体。\t\n\n\r(6)GET请求提交数据受浏览器限制，1k，POST请求理论上无限制。\r\n\n**42、属性用__block修饰时在内存中会发生什么变化？**\n\n为什么在block外面用weak修饰属性来打破循环，在block还需要把属性转换成strong。\n\n\n**43、谈谈block与函数的区别。**\n\n\rblock可以写在方法里面，函数需要写在方法外面。block可以访问方法中的局部变量。\n\n\n**44、你了解runloop吗？它有几种模式？简要的说下它的应用场景。**\n\n\rrunloop模式：\n\n\rDefault：\n\n\rNSDefaultRunLoopMode(Cocoa)、kCFRunLoopDefaultMode(CoreFoundation)\n\n\nConnection：\n\n\rNSConnectionReplyMode\n\n\rModal：\n\n\rNSModalPanelRunLoopMode\n\n\rEvent tracking:\n\n\rNSEventTrackingRunLoopMode\n\n\rCommon modes:\n\n\nNSRunLoopCommonModes(Cocoa)、kCFRunLoopCommonModes(CoreFoundation)\n\n\r应用场景：\n\n\r（1）使用端口或自定义输入源与其他线程通信。\n\n\r（2）在线程中使用计时器\n\n\r（3）使用任意的performSelector方法\n\n\r（4）保持线程去执行一个周期任务。\n\n\r**45、你工作中用到的版本管理工具是什么？**\n\n\r用的是git工具来进行版本管理。\n\n\n**46、你用过git工具吗？用过哪些常见的命令？**\n\n\rgit init，git add, git commit，git merge，git branch，git checkout，git pull，git push等\n\n\n**47、CoreAnimation常用的动画有哪些类型？**\n\n\r所有的核心动画的动画类都从CAAnimation类继承而来。CAAnimationGroup组动画，CATransition转场动画，CABasicAnimation:基础动画，CAKeyframeAnimation关键帧动画。\n\n\n**48、GCD中系统提供了几种queue？**\n\n\r两种：DispatchSerialQueue、DispatchConcurrentQueue。\n\n\n**49、二叉搜索树的概念及时间复杂度是多少？**\n\n\rO(n)\n\n\n**50、block中的weak self，是任何时候都需要加的么？**\n\n\r不一定，可加可不加。将block置nil也可以打破循环引用。\n\n\n**51、GCD的queue，main queue中执行的代码，一定是在main thread么？**\n\n\n是的。一定是在main thread。\n\n\n**52、你在使用数据库的过程中有没有遇到过问题？如何解决？**\n\n\r遇到过多线程操作数据库读写死锁问题，采用fmdb中提供的回滚的方式解决\r\n\n**53、简述iOS中的沙盒机制。**\n\n\riOS中的沙盒机制是一种安全体系，它规定了应用程序只能在为该应用创建的文件夹读取文件，不可以访问其他地方的内容。所有非代码文件都保存在这个地方。如图片，声音，属性列表及文本文件等。\n\n\r（1）每个应用程序都在自己的沙盒内\n\n\r（2）不能随意跨越自己的沙盒去访问别的应用程序沙盒的内容\n\n\r（3）应用程序向外请求或者接收数据都需要经过权限认证。\n\n\r沙盒目录结构这种，因为应用是在沙箱（sandbox）中的，在文件读写权限上受到限制，只能在几个目录下读写文件：\n\n\rDocuments：应用中用户数据可以放在这里，iTunes备份和恢复的时候会包括此目录\n\n\rtmp：存放临时文件，iTunes不会备份和恢复此目录，此目录下文件可能会在应用退出后删除\n\n\nLibrary：存储程序的默认设置或其他状态信息。\n\n\rLibrary/Caches：存放缓存文件，iTunes不会备份此目录，此目录下文件不会在应用退出删除\n\n\n**54、字符串为什么要用copy修饰？**\n\n\r是为了防止mutablestring被无意中修改，NSMutableString是NSString的子类。因此NSString指针可以持有NSMutableString对象。\r\n\n**55、nonatomic与atomic有什么区别？**\n\n\ratomic是Objective-C使用的一种线程保护技术，它是为了防止写操作在未完成的时候被另外一个线程读取。从而造成数据错误。这种机制是非常耗费系统资源的，所以在iphone这种小的移动设备上，如果没有使用多线程间的通讯编程。建议使用nonatomic。\n\n\r默认的访问器是原子操作，就是说在多线程环境下，解析的访问器提供一个对属性安全访问，从获取器得到的返回值或者通过设置器设置的值可以一次完成，即便是多线程也在对其进行访问，如果不指定nonatomic ，在自己管理内存的环境中，解析的访问器保留并自动释放保留的值，如果是指定了nonatomic，访问器只是简单的返回一个值。\n\n\n**56、@synthesize与@dynamic的区别？**\n\n\r@synthesize：如果你没有手动实现setter方法和getter方法，编译器会自动为帮你生成setter方法和getter方法。\n\n\r@dynamic：告诉编译器属性的setter和getter方法由用户自己实现，不自动生成。如果一个属性声明为@dynamic var，又没有提供setter和getter方法，编译的时候不会有问题，如果程序中运行到person.name = newName;或newName=person.name时候就会导致程序崩溃。因为”unrecognized selector sent to instance …”这就是动态绑定。\n\n\n**57、@property(copy)NSMutableArray *array;这句代码有什么问题？如果有请简述原因；**\n\n\r（1）添加、删除、修改数组内的元素的时候，程序会因为找不到对应的方法而崩溃，因为copy就是复制一个不可变的NSArray对象。\n\n\r（2）没有使用nonatomic属性修饰符，默认是 atomic修饰，这样会严重影响性能。\n\n\n**58、NSString *str = @“hello world!”与NSString *str =  [[NSString alloc] initWithString:@\"hello world!”];在内存管理上有什么区别？**\n\n\r在MRC中，前者表示，你不持有这个对象，所以不需要手动管理其内存。后者意味着你持有这个字符串，需要自己手动管理内存，对其进行释放。\n\n\n**59、对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别是什么类型的对象?**\n\n\r编译时是NSString类型对象，运行时时NSData类型对象\r首先，声明NSString*testObject是告诉编译器,obj是一个指向某个Objective-C对象的指针，因为不管指向的是什么类型的对象，一个指针所占的内存空间都是固定的，所以这里声明称任何类型的对象，最终生成的可执行代码都是没有区别的。这里限定了NSString只不过是告诉编译器，请把obj当做一个NSString来检查，如果后面调用了非NSString的方法，会产生警告，接着，你创建了一个NSData对象，然后把这个对象所在的内存地址保存在obj里。那么运行时，obj指向的内存空间就是一个NSData对象。你可以把obj当做一个NSData对象来用。\n\n**60、self.name=object与name=object在内存管理上有什么区别？**\n\n\r前者通过调用setter方法设置值，后者是普通的赋值操作。\n\n\n**61、为什么property声明中只有”copy”特性而没有“mutableCopy”特性？**\n\n\r这是由于当声明property为\"copy\"特性时，系统会自动根据receiver的特点决定使用copy（已含retain的情况）还是mutableCopy。\n\n\n**62、Objective-C中id与void*有什么区别？id与instancetype有什么区别？nil、null、NULL三者有什么区别？**\n\n\rObjective-C中id与void*区别：\n\n\rid是指向OC类对象的指针，它可以声明为任何类对象的指针，当在OC中使用id时，编译器会假定你知道，id指向哪个类的对象。与void*不同，void*编译器不知道也不假定指向任何类型的指针。\n\n\rid与instancetype区别：\n\n\rid返回的是id类型，instancetype返回的是所在类的类型。\n\n\r相同点是同样都是作为方法的返回类型。\n\n\r区别：\n\n\r(1)\tinstancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象。\n\n\r(2)\tinstancetype只能作为返回值，id可以作为参数。\n\n\rnil、Nil、NULL三者区别：\n\n\rnil是一个指向不存在的对象指针（对象空指针）。Nil是指向不存在的类指针（类空指针）。NULL指向其他类型的空指针。NSNull在集合对象中，表示空值的对象。\n\n\n**63、数据解析方式有几种？他们有什么区别？你项目中采用的是哪种数据解析方式？**\n\n\rJSON和XML。\n\n\n**64、用预处理指令#define声明一个常数，用以表明1年中有多少秒（忽略闰年问题）**\n\n\r“#define SECONDS_PER_YEAR(60*60*24*365)UL”\n\n\r**65、写一个”标准\"宏MIN ，这个宏输入两个参数并返回较小的一个。**\n\n\r“#define MIN(X,Y) ((X)>(Y)?(X):(Y))”\n\n\n**66、+load和+initialize 的区别是什么？**\n\n\r+initialize:第一次初始化这个类之前被调用，我们用它来初始化静态变量。\n\n\r+load方法会在加载类的时候就被调用，也就是iOS应用启动的时候，就会加载所有的类。\n\n\r+initialize方法类似一个懒加载，如果没有使用这个类，系统默认不会去调用这个方法，且默认只加载一次。\n\n\r如果是在类别中，+load方法会全都执行，但是类别中的load方法会后于类中的方法，+initialize方法会覆盖类中的方法，只执行一个。\n\n\r+initialize的调用发生在+init方法之前。子类会去调用父类的+initialize方法。\n\n\n**67、new和alloc/init的区别**\n\n\r概括来说，new和alloc/init在功能上几乎是一致的，分配内存并完成初始化。\r差别在于，采用new的方式只能采用默认的init方法完成初始化。\r而采用alloc的方式可以用其他定制的初始化方法。\n\n\n**68、如果让你设计接口与API，应该注意点什么？**\n\n\r（1）用前缀避免命名空间冲突\n\n\r（2）提供“全能初始化方法”\n\n\r（3）实现description方法\n\n\r（4）尽量使用不可变对象\n\n\r（5）使用清晰而协调的命名方法\n\n\r（6）为私有方法名加前缀\n\n\r（7）错误处理\n\n\r（8）实现NSCopying协议。\n\n\n**69、你在项目中用过懒加载吗？能简单的说说懒加载吗？**\n\n\r懒加载又称为延迟加载。写的是其get方法。如果是懒加载的话则一定要注意先判断是否已经有了，如果没有那么再去进行实例化。\n\n\r好处是不必将创建对象的代码全部写在viewDidLoad方法中，代码的可读性更强。每个控件的getter方法中分别负责各自的实例化处理，代码彼此之间的独立性强，松耦合。\n\n\n**70、进程和线程的区别与联系。**\n\n\r进程是个静态的容器，里面容纳了很多个线程，线程是一系列方法的线性执行路径。\n\n\n**71、简述内存分区情况。**\n\n\r栈区：存放函数的参数值，局部变量的值等。由编译器自动分配释放\n\n\r堆区：由程序员分配释放。程序员如果不释放，则程序结束时可能由系统回收\n\n\r全局区：全局变量和静态变量是存储在一块的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在另一块区域。程序结束后由系统释放。全局区可分为未初始化全局区：.bbs段和初始化全局区：data段。\n\n\r常量区：存放常量字符串，程序结束后由系统释放\n\n\r代码区：存放函数体的二进制代码。\n\n**72、队列与栈有什么区别?**\n\n\r栈：限定仅在表尾进行插入或删除操作的线性表。表尾是栈顶，表头是栈底。它又称后进先出线性表。\n\n\r队列：是一种先进先出的线性表。它只允许在表的一端进行插入，而在另一端删除元素。\n\n\n**73、Objective-C中多线程的编程方式有几种**\n\n\rpthread、NSThread、NSOperation、GCD。\n\n**74、Objective-C运行时（runtime）机制了解吗？简单的说说对象调用方法的过程。**\n\n\r对象调用方法的过程：(<a href=\"http://tech.glowing.com/cn/objective-c-runtime/\">Objective-C Runtime</a>)\n\n\r（1）在对象类的dispatch table中尝试找到该消息。如果找到了，跳到相应的函数IMP去执行实现代码\n\n\r（2）如果没有找到，Runtime会发送+resolveInstanceMethod: 或者 +resolveClassMethod: 尝试去resolve这个消息\n\n\r（3）如果resolve方法返回NO，Runtime就发送 -forwardingTargetForSelector: 允许你把这个消息转发给另一个对象；\n\n（4）如果没有新的目标对象返回，Runtime 就会发送 -methodSignatureForSelector: 和 -forwardInvocation: 消息。你可以发送 -invokeWithTarget: 消息来手动转发消息或者发送 -doesNotRecognizeSelector: 抛出异常。\n\n\n\n**参考资料如下：**\n\n\n（1）<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md\" target=\"_blank\">《招聘一个靠谱的 iOS》—参考答案（上）</a>\n\n\n（2）<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md\" target=\"_blank\">《招聘一个靠谱的 iOS》—参考答案（下）</a>\n\n\n**本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！**\n\n**如需转载，请注明出处**\n\n\r","slug":"iosmian-shi-ti-zhi-objective-cji-chu","published":1,"updated":"2016-09-10T05:18:16.000Z","_id":"ciswie9dv000ye3u23cjv9pdj","photos":[],"link":"","content":"<p><strong>1、简述你项目中常用的设计模式。它们有什么优缺点？</strong></p>\n<p>常用的设计模式有：代理、观察者、单例。</p>\n<p>（1）单例：它是用来限制一个类只能创建一个对象。这个对象中的属性可以存储全局共享的数据。所有的类都能访问、设置此单例中的属性数据。</p>\n<p>优点：是它只会创建一个对象容易供外界访问，节约性能。<br><a id=\"more\"></a></p>\n<p>缺点：是一个类只有一个对象，可能造成责任过重，在一定程度上违背了“单一职责原则”。单例模式中没有抽象层，所以单例类的扩展有很大的困难。不能过多创建单例，因为单例从创建到程序关闭前会一直存在，过多的单例会影响性能，浪费系统资源。</p>\n<p>（2）观察者（KVO）:它提供了观察某一属性变化的方法。当指定对象的属性发生改变后，它会自动通知相应的观察者。</p>\n<p>优点：能提供被观察者属性的新值与旧值。用keypaths来观察属性，因此也可以观察嵌套对象。 </p>\n<p>缺点：需要注册观察者，实现observeValueForKeyPath:方法，属性必须通过KVC的方法来修改。否则观察者收不到通知。</p>\n<p>（3）代理：可以实现类与类之间一对一的通信。</p>\n<p>优点：代理协议方法都有清晰的定义。代理方法可以设置可选或必须实现。</p>\n<p>缺点：需要定义协议方法，需要设置代理对象，代理对象实现协议方法。内存管理方面，需要注意循环引用问题。</p>\n<p><strong>2、代理模式能否实现一对多的通信？</strong></p>\n<p>可以，采用多播委托的方式来实现。多播委托：它是指允许创建方法的调用列表或者链表的能力。当多播委托被调用时，列表中的方法均自动执行。</p>\n<p>普通代理只能是一对一的回调，无法做到一对多的回调，而多播委托正式对delegate的一种扩展与延伸，多了一个注册和取消的过程。任何需要回调的对象都必须先注册。</p>\n<p><strong>3、    重复注册通知会有问题吗？</strong></p>\n<p>不会出现问题，若多次发送同一通知，对方就会多次响应。如果重复注册通知，也会有多次响应的效果。为了避免重复注册通知而造成的错误，建议每次注册一个通知前，可以移除一次该通知。</p>\n<p><strong>4、项目中是否用过多线程编程？简述你常用的多线程实现方式？</strong></p>\n<p>常用的是GCD。</p>\n<p>GCD是苹果开发中一个多核编程的解决方案。GCD的队列分为两种类型，SerialDispatchQueue与ConcurrentDispatchQueue。系统默认提供了一个dispatch_get_main_queue，一个dispatch_get_global_queue。</p>\n<p><strong>5、简述NSOperationQueue与GCD的区别。</strong></p>\n<p>(1)    GCD是底层的C语言构成的API。NSOperationQueue及相关对象是Objc对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构。而Operation作为一个对象，为我们提供了更多的选择。</p>\n<p>(2)    在NSOperationQueue中，我们可以取消任务，而GCD没法停止已经加入queue的block。</p>\n<p>(3)    NSOperation能够方便的设置依赖关系。还能设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行。在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务优先级也需要大量复杂代码。<br>NSOperation还可以设置并发数。</p>\n<p><strong>6、实现多线程有哪几种方式？</strong></p>\n<p>（1）NSThread:detachNewThreadSelector:</p>\n<p>（2）继承NSOperation</p>\n<p>（3）GCD：dispatch_async</p>\n<p>（4）NSObject：performSelectorInBackground:</p>\n<p><strong>7、KVC、KVO是什么？简述KVO的实现原理。KVO能否监听数组？如何实现？</strong></p>\n<p>KVC:键值编码，它是一种间接访问对象实例变量机制，可以不通过存取方法访问对象的实例变量。</p>\n<p>KVO:键值观察，它可以使对象获取其他对象属性变化的通知机制。</p>\n<p>键值编码和键值观察是根据isa-swizzling技术来实现的，主要依据runtime的强大动态能力。当给某个对象第一次添加KVO监听的时候，运行时会动态的创建一个被监听对象的派生类，然后重写KVO需要监听属性值对应的setter方法，在这个setter方法中实现了通知机制。最后将被监听对象的isa指向动态创建的派生类。这样当使用KVC修改属性值时，就会调用动态创建的派生类中对应的setter方法，触发通知机制，从而实现了KVO了。<br>KVO可以监听数组。</p>\n<p>实现 NSMutableArray 的增删改操作遵从 KVC 的规则，需要实现其对应方法:</p>\n<p>增操作 -insertObject:in<key>AtIndex: 或者 -insert<key>:atIndexes:</key></key></p>\n<p>删操作 -removeObjectFrom<key>AtIndex: 或者 -remove<key>AtIndexes:</key></key></p>\n<p>改操作 -replaceObjectIn<key>AtIndex:withObject: 或者 -replace<key>AtIndexes:with<key>:</key></key></key></p>\n<p>并将这些接口暴露给调用者，在对数组进行操作时需使用上述实现的接口。</p>\n<p><strong>8、简单说下C++，JAVA，Objective-C这几种语言有什么区别？</strong></p>\n<p>Objective-C与JAVA都是单继承语言，C++是多继承语言。</p>\n<p>Objective-C不支持命名空间机制，通过类名前面加前缀NS来区分。</p>\n<p>Objective-C与JAVA不支持运算符重载。</p>\n<p>Objective-C协议可选实现，JAVA的接口必须实现。</p>\n<p><strong>9、数组添加nil元素有问题吗？字典object与key可以设置为nil吗？</strong></p>\n<p>会有问题，数组中添加nil元素，程序会崩溃！报object cannot be nil错误。字典的key不能为nil，否则会造成崩溃。字典的object也不能为nil。</p>\n<p><strong>10、oc中向一个nil对象发送消息会出现问题吗？</strong></p>\n<p>不会出现问题，因为objc是动态语言，每个方法在运行时会被动态转为消息发送。即：objc_msgSend(receiver，selector)。objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p>\n<p><strong>11、可变数组是线程安全的吗？什么情况下不安全？可以加锁吗？它锁住的是添加元素操作还是数组对象？</strong></p>\n<p>可变数组不是线程安全的，在异步读取数据的情况下是不安全的。可以加锁，锁住的是数组。</p>\n<p><strong>12、数组能添加一个block吗？数组添加一个block之后再取出来，这个block还有用吗？</strong></p>\n<p>可以，还有用，它只是多retain了一次</p>\n<p><strong>13、NSMutableDictionary中的setObject:forKey:与setValue:forKey:方法有什么区别?</strong></p>\n<p>setObject:forkey:中value是不能够为nil的，不然会报错。</p>\n<p>setValue:forKey:中的value能够为nil，但是当value为nil的时候，会自动调用removeObject:forKey方法。</p>\n<p>setValue:forKey:中的key的参数只能是NSString类型，而setObject:forKey是可以任何类型。</p>\n<p><strong>14、简述copy与mutablecopy的区别。</strong></p>\n<p>（1）非容器对象：</p>\n<p>对不可变对象：copy是指针复制（浅拷贝）， mutableCopy是对象复制（深拷贝）。<br>对可变对象：copy和mutableCopy都是对象复制。</p>\n<p>（2）容器对象：</p>\n<p>对不可变对象：copy是指针复制，mutableCopy是对象复制。</p>\n<p>对可变对象：copy和mutableCopy都是对象复制，只是返回的对象类型不一样，前者返回的是不可变对象，后者返回的是可变对象。</p>\n<p>容器对象复制仅限于对象本身，对象元素仍然是指针复制。</p>\n<p><strong>15、简述weak与assign的区别。</strong></p>\n<p>weak用来修饰对象，不能修饰基本数据类型。assign一般用来修饰基本数据类型。weak修饰对象，在对象释放之后会把对象置为nil。</p>\n<p><strong>16、ARC下，不显示指定任何属性关键字时，默认的关键字有哪些？</strong></p>\n<p>基本数据类型默认修饰关键字：atomic,readwrite,assign</p>\n<p>普通的OC对象默认修饰关键字：atomic,readwrite,strong</p>\n<p><strong>17、weak在什么时候置空？</strong></p>\n<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>\n<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>\n<p>objc_storeWeak(&amp;a, b)函数：</p>\n<p>objc_storeWeak函数把第二个参数–赋值对象（b）的内存地址作为键值key，将第一个参数–weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，<br>你可以把objc_storeWeak(&amp;a, b)理解为：objc_storeWeak(value, key)，并且当key变nil，将value置nil。</p>\n<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>\n<p>而如果a是由assign修饰的，则： 在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。</p>\n<p>下面我们将基于objc_storeWeak(&amp;a, b)函数，使用伪代码模拟“runtime如何实现weak属性”：</p>\n<p>// 使用伪代码模拟：runtime如何实现weak属性<br>id obj1;<br>objc_initWeak(&amp;obj1, obj);<br>/<em>obj引用计数变为0，变量作用域结束</em>/<br>objc_destroyWeak(&amp;obj1);</p>\n<p>下面对用到的两个方法objc_initWeak和objc_destroyWeak做下解释：</p>\n<p>总体说来，作用是： 通过objc_initWeak函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过objc_destoryWeak函数释放该变量（obj1）。</p>\n<p>下面分别介绍下方法的内部实现：</p>\n<p>objc_initWeak函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用objc_storeWeak函数。<br>obj1 = 0；<br>obj_storeWeak(&amp;obj1, obj);</p>\n<p>也就是说：<br>weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）<br>然后obj_destroyWeak函数将0（nil）作为参数，调用objc_storeWeak函数。<br>objc_storeWeak(&amp;obj1, 0);<br>前面的源代码与下列源代码相同。</p>\n<p>// 使用伪代码模拟：runtime如何实现weak属性<br>id obj1;<br>obj1 = 0;<br>objc_storeWeak(&amp;obj1, obj);<br>/<em> … obj的引用计数变为0，被置nil … </em>/<br>objc_storeWeak(&amp;obj1, 0);</p>\n<p>objc_storeWeak函数把第二个参数–赋值对象（obj）的内存地址作为键值，将第一个参数–weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除，在后面的相关一题会详解。</p>\n<p>以上内容总结如下：</p>\n<p>（1）从weak表中获取废弃对象的地址为键值的记录</p>\n<p>（2）将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil</p>\n<p>（3）从weak表中删除该记录</p>\n<p>（4）从引用计数表中删除废弃对象的地址为键值的记录。</p>\n<p><strong>18、自动释放池用过吗？它是什么时候释放？什么情况下对象会被加入到自动释放池，它会加入到哪个自动释放池?</strong></p>\n<p>主线程默认开启runloop,同时runloop会自动创建一个autoreleasepool，autorelease对象会自动被加入autoreleasepool中，一次runloop后清空自动释放池。用__autoreleasing修饰符修饰，或类方法创建会自动加入autoreleasepool。它会加入到最近的autoreleasepool中。</p>\n<p><strong>19、你知道iOS中有哪些数据持久化方式吗？请简要加以说明。</strong></p>\n<p>iOS中数据持久化方式有：SQLite3数据库，CoreData，文件归档，属性列表（plist文件写入）。</p>\n<p>属性列表：涉及的主要类是NSUserDefaults，存储小量的数据。</p>\n<p>文件归档：对象必须实现NSCoding协议。实现initWithCoder:方法与encodeWithCoder方法。同时也建议实现NSCopying协议。</p>\n<p>SQLite3数据库:SQLite是一个开源的嵌入式关系数据库。可移植性好，容易使用，需要内存开销小。适合嵌入式设备。</p>\n<p>CoreData：它可以使用SQLite保存数据，而且不需要写SQL语句。另外它还可以使用XML方式保存数据。要使用CoreData，需要在Xcode中的数据模型编辑器中设计好各个实体以及定义好他们的属性和关系。通过操作这些对象来完成数据的持久化。</p>\n<p><strong>20、fmdb中支持多线程吗？它是如何实现的！</strong></p>\n<p>支持多线程。它里面有个FMDatabaseQueue类。它看似是一个队列，实际上它本身并不是，它继承NSObject，通过内部创建一个Serial的dipatch_queue_t来处理inDatabase和inTransaction传入的Block，所以当我们在主线程（或者后台）调用inDatabase或者inTransaction时，代码实际上是同步的。FMDatabaseQueue如此设计的目的是为了避免并发访问数据库的线程安全问题，所有的数据库访问都是同步执行，比@synchronized与NSLock效率高。</p>\n<p><strong>21、简述category与extension的区别。Category与extension加载的时机。</strong></p>\n<p>category中只能增加方法，不可添加实例变量（可添加属性）。extension不仅可以增加方法，还可以增加实例变量或属性（私有的）。extension不能像category一样有独立的实现部分。category是运行时决定的。extension是编译期决定的。</p>\n<p><strong>22、category的方法能被子类继承吗？它覆盖原有类的方法后，原有类的方法还能调用吗？如果能，你说明理由。</strong></p>\n<p>category的方法可以被子类继承。category并不是绝对的覆盖了类的同名方法，而是category的方法排在了类的同名方法之前，方法的检索方式是顺序检索，所以在调用方法时，调用到的同名方法是category，从而产生了覆盖。<br>利用运行时遍历方法列表，可以调用被category覆盖的方法。</p>\n<p><strong>23、    扩展一个类的方式用继承好还是category好？请说明理由。</strong></p>\n<p>用类目好。因为继承还需要定义子类。类目不需要通过创建子类来增加现有类的方法。用category去重写一个类的方法，仅仅只对本category有效，不会影响到其他类与原有类的关系。</p>\n<p><strong>24、    block有几种类型？block的实现？</strong></p>\n<p>block分为三种类型:</p>\n<p>_NSConcreteGlobalBlock</p>\n<p>_NSConcreteStackBlock</p>\n<p>_NSConcreteMallocBlock</p>\n<p>block：匿名函数</p>\n<p><strong>25、    Swift用的多吗？简单的说说1.0与2.0的区别。</strong></p>\n<p>swift2.0新增:guard语句，异常处理，协议扩展，打印语句改变，avaliable检查，do-while语句重命名：repeat-while，defer关键字</p>\n<p><strong>26、    在Swift用有没有用过defer关键字？</strong></p>\n<p>对defer语句进行的延迟，函数结束时调用。</p>\n<p><strong>27、    SDWebImage的图片保存在什么位置？</strong></p>\n<p>图片保存在沙盒中的library/caches文件夹下。</p>\n<p><strong>28、    Objective-C中类目为什么不能添加实例变量？</strong></p>\n<p>因为在运行时，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局。</p>\n<p><strong>29、    Objective-C中的协议默认是@optional还是@require？在使用协议的时候应当注意哪些问题？</strong></p>\n<p>Objective-C中的协议默是必须实现的@require，使用协议的时候应当注意循环引用问题，多个协议之间采用逗号分隔。</p>\n<p><strong>30、    Objective-C的协议与JAVA中的接口有什么区别？</strong></p>\n<p>OC中的协议可选实现，JAVA中的接口必须实现。</p>\n<p><strong>31、    类目的应用场景有哪些？</strong></p>\n<p>（1）可以把类的实现分开在几个不同的文件里面</p>\n<p>（2）声明私有方法</p>\n<p>（3）模拟多继承</p>\n<p>（4）把Framework的私有方法公开</p>\n<p><strong>32、    self与super的区别？</strong></p>\n<p>super本质上是一个编译器标示符，它和self指向的是同一个消息接受者，两者不同在于：super会告诉编译器，调用class这个方法时，要去父类方法，而不是本类方法。<br><strong>33、    图片缓存为什么不保存到沙盒下的tmp文件目录中？</strong></p>\n<p>因为tmp文件夹是用来存放临时文件，iTunes不会备份和恢复此目录，此目录下文件可能会在应用退出后删除。</p>\n<p><strong>34、    NSURLConnection与NSURLSession。</strong></p>\n<p>NSURLConnection它是CoreFoundation/CFNetwork框架的API之上的一个抽象。</p>\n<p>NSURLConnection这个名字实际指代Foundation框架的URL加载系统中一系列有关联的组件：NSURLRequest、NSURLResponse、NSURLProtocol、NSURLCache、NSHTTPCookieStorage、NSURLCredentialStorage以及同名类NSURLConnection。NSURLRequest 被传递给 NSURLConnection。被委托对象（遵守以前的非正式协议 <nsurlconnectiondelegate> 和 <nsurlconnectiondatadelegate>）异步地返回一个 NSURLResponse 以及包含服务器返回信息的 NSData。</nsurlconnectiondatadelegate></nsurlconnectiondelegate></p>\n<p>NSURLSession包括：NSURLRequest、NSURLCache、NSURLSession、NSURLSessionConfiguration、NSURLSessionDataTask、NSURLSessionUploadTask、NSURLSessionDownloadTask。<br>它与NSURLConnection的区别在于：NSURLSession最直接的改进就是可以配置每个Session的缓存，协议，cookie以及正式策略。甚至跨程序共享这些信息。每个NSURLSession对象都由一个NSURLSessionConfiguration对象来进行初始化。<br>session task：负责处理数据的加载以及文件和数据在客户端与服务器之间的上次和下载。</p>\n<p><strong>35、    简述ARC与MRC的区别。</strong></p>\n<p>ARC:自动引用计数。MRC：手动引用计数。ARC是把内存交给系统管理。系统会在编译的时候自动插入retain/release。MRC则需要手动管理对象的引用计数。当你alloc,new,copy,mutablecopy或者retain一个对象时，你就有义务向它发送一条release或autorelease消息。</p>\n<p><strong>36、    简述ARC的实现原理。它在什么时机插入retain/release？</strong></p>\n<p>ARC：自动引用计数。它会在对象创建或者消亡的时候自动插入retain/release。达到自动管理内存的目的。</p>\n<p><strong>37、    Framework与Library的区别？动态库与静态库的区别？</strong></p>\n<p>library与Framework的区别：</p>\n<p>在iOS中，Library 仅能包含编译后的代码，即 .a 文件。<br>但一般来说，一个完整的模块不仅有代码，还可能包含.h 头文修的、.nib 视图文件、图片资源文件、说明文档。（像 UMeng 提供的那些库，集成时，要把一堆的文件拖到Xcode中，配置起来真不是省心的事。<br>Framework 作为 Cocoa/Cocoa Touch 中使用的一种资源打包方式，可以上述文件等集中打包在一起，方便开发者使用（就像Bundle）。</p>\n<p>静态库与动态库的区别：</p>\n<p>简单的说，静态链接库是指模块被编译合并到应用中，应用程序本身比较大，但不再需要依赖第三方库。运行多个含有该库的应用时，就会有多个该库的Copy在内存中，冗余。<br>动态库可以分开发布，在运行时查找并载入到内存，如果有通用的库，可以共用，节省空间和内存。同时库也可以直接单独升级，或作为插件发布。</p>\n<p><strong>38、    什么是runloop？</strong></p>\n<p>一般来说，一个线程一次只能执行一个任务，执行完成后线程就会退出，如果我们需要一个机制，让线程能随时处理事件但并不退出。代码逻辑如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rfunction loop() &#123;\r\t\tinitialize();\r\t\tdo &#123;\r\tvar message = get_next_message();\r\tprocess_message(message);\r&#125; while(message != quit)\r&#125;</div></pre></td></tr></table></figure>\n<p>这种模型我们通常称之为EventLoop（事件循环）。RunLoop实际上是一个对象，这个对象管理了其需要处理的事件和消息。并提供了一个入口函数来执行上面EventLoop逻辑。在OSX/iOS系统中，提供了两个这样的对象：NSRunLoop和CFRunLoopRef。</p>\n<p>CFRunLoopRef是在CoreFoundation框架内，它提供了纯C函数的API,所有这些API都是线程安全的。</p>\n<p>NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API，这些API不是线程安全的。</p>\n<p>苹果不允许直接创建RunLoop，只提供了两个自动获取的函数：CFRunLoopGetMain()和CFRunLoopGetCurrent()。</p>\n<p>线程和RunLoop之间是一一对应的。</p>\n<p><strong>39、#include与#import的区别？#import与@class的区别？</strong></p>\n<p>“#include”与”#import”功能一样，都是导出头文件。只是#import不会引起交叉编译，可以确保头文件只导入一次。#import会包含这个类的所有信息。包括实例变量和方法，而@class只是告诉编译器，它后面声明的名称是类的名称，至于类的定义，后面会告诉你。使用#import编译效率高，可以防止相互包含的编译错误。</p>\n<p><strong>40、Static与const的区别？</strong></p>\n<p>const表示只读的意思，只在声明中使用。</p>\n<p>static一般有2个作用，规定作用域和存储方法。对于局部变量，static规定其为静态存储区，每次调用的初始值为上一次调用的值，调用结束后存储空间不释放。</p>\n<p>对于全局变量，如果以文件划分作用域的话，此变量只在当前文件可见，对于static函数也是在当前模块内函数可见。</p>\n<p><strong>41、简述GET请求与POST请求的区别。</strong></p>\n<p>(1)POST 需要明确制定方法 GET不需要 ，并且默认就是GET方法，并且GET有缓存，POST没有缓存</p>\n<p>(2)GET的参数放在URL的后面,并且第一个参数用?拼接,后面的从第二个参数开始,直到最后一个,如果有多个,用&amp;分割;POST 的参数放在请求体里面,并且第一个参数,不用,后面从第二开始,直到最后,如果有多个,用&amp;分割;</p>\n<p>(3)GET 一般用于获取数据，POST向服务器提交数据用到</p>\n<p>(4)GET的参数是暴漏在地址栏的,不安全;POST的参数隐藏在请求体里面,相对安全一点;</p>\n<p>(5)GET请求没有请求体，POST请求有请求体。    </p>\n<p>(6)GET请求提交数据受浏览器限制，1k，POST请求理论上无限制。</p>\n<p><strong>42、属性用__block修饰时在内存中会发生什么变化？</strong></p>\n<p>为什么在block外面用weak修饰属性来打破循环，在block还需要把属性转换成strong。</p>\n<p><strong>43、谈谈block与函数的区别。</strong></p>\n<p>block可以写在方法里面，函数需要写在方法外面。block可以访问方法中的局部变量。</p>\n<p><strong>44、你了解runloop吗？它有几种模式？简要的说下它的应用场景。</strong></p>\n<p>runloop模式：</p>\n<p>Default：</p>\n<p>NSDefaultRunLoopMode(Cocoa)、kCFRunLoopDefaultMode(CoreFoundation)</p>\n<p>Connection：</p>\n<p>NSConnectionReplyMode</p>\n<p>Modal：</p>\n<p>NSModalPanelRunLoopMode</p>\n<p>Event tracking:</p>\n<p>NSEventTrackingRunLoopMode</p>\n<p>Common modes:</p>\n<p>NSRunLoopCommonModes(Cocoa)、kCFRunLoopCommonModes(CoreFoundation)</p>\n<p>应用场景：</p>\n<p>（1）使用端口或自定义输入源与其他线程通信。</p>\n<p>（2）在线程中使用计时器</p>\n<p>（3）使用任意的performSelector方法</p>\n<p>（4）保持线程去执行一个周期任务。</p>\n<p><strong>45、你工作中用到的版本管理工具是什么？</strong></p>\n<p>用的是git工具来进行版本管理。</p>\n<p><strong>46、你用过git工具吗？用过哪些常见的命令？</strong></p>\n<p>git init，git add, git commit，git merge，git branch，git checkout，git pull，git push等</p>\n<p><strong>47、CoreAnimation常用的动画有哪些类型？</strong></p>\n<p>所有的核心动画的动画类都从CAAnimation类继承而来。CAAnimationGroup组动画，CATransition转场动画，CABasicAnimation:基础动画，CAKeyframeAnimation关键帧动画。</p>\n<p><strong>48、GCD中系统提供了几种queue？</strong></p>\n<p>两种：DispatchSerialQueue、DispatchConcurrentQueue。</p>\n<p><strong>49、二叉搜索树的概念及时间复杂度是多少？</strong></p>\n<p>O(n)</p>\n<p><strong>50、block中的weak self，是任何时候都需要加的么？</strong></p>\n<p>不一定，可加可不加。将block置nil也可以打破循环引用。</p>\n<p><strong>51、GCD的queue，main queue中执行的代码，一定是在main thread么？</strong></p>\n<p>是的。一定是在main thread。</p>\n<p><strong>52、你在使用数据库的过程中有没有遇到过问题？如何解决？</strong></p>\n<p>遇到过多线程操作数据库读写死锁问题，采用fmdb中提供的回滚的方式解决</p>\n<p><strong>53、简述iOS中的沙盒机制。</strong></p>\n<p>iOS中的沙盒机制是一种安全体系，它规定了应用程序只能在为该应用创建的文件夹读取文件，不可以访问其他地方的内容。所有非代码文件都保存在这个地方。如图片，声音，属性列表及文本文件等。</p>\n<p>（1）每个应用程序都在自己的沙盒内</p>\n<p>（2）不能随意跨越自己的沙盒去访问别的应用程序沙盒的内容</p>\n<p>（3）应用程序向外请求或者接收数据都需要经过权限认证。</p>\n<p>沙盒目录结构这种，因为应用是在沙箱（sandbox）中的，在文件读写权限上受到限制，只能在几个目录下读写文件：</p>\n<p>Documents：应用中用户数据可以放在这里，iTunes备份和恢复的时候会包括此目录</p>\n<p>tmp：存放临时文件，iTunes不会备份和恢复此目录，此目录下文件可能会在应用退出后删除</p>\n<p>Library：存储程序的默认设置或其他状态信息。</p>\n<p>Library/Caches：存放缓存文件，iTunes不会备份此目录，此目录下文件不会在应用退出删除</p>\n<p><strong>54、字符串为什么要用copy修饰？</strong></p>\n<p>是为了防止mutablestring被无意中修改，NSMutableString是NSString的子类。因此NSString指针可以持有NSMutableString对象。</p>\n<p><strong>55、nonatomic与atomic有什么区别？</strong></p>\n<p>atomic是Objective-C使用的一种线程保护技术，它是为了防止写操作在未完成的时候被另外一个线程读取。从而造成数据错误。这种机制是非常耗费系统资源的，所以在iphone这种小的移动设备上，如果没有使用多线程间的通讯编程。建议使用nonatomic。</p>\n<p>默认的访问器是原子操作，就是说在多线程环境下，解析的访问器提供一个对属性安全访问，从获取器得到的返回值或者通过设置器设置的值可以一次完成，即便是多线程也在对其进行访问，如果不指定nonatomic ，在自己管理内存的环境中，解析的访问器保留并自动释放保留的值，如果是指定了nonatomic，访问器只是简单的返回一个值。</p>\n<p><strong>56、@synthesize与@dynamic的区别？</strong></p>\n<p>@synthesize：如果你没有手动实现setter方法和getter方法，编译器会自动为帮你生成setter方法和getter方法。</p>\n<p>@dynamic：告诉编译器属性的setter和getter方法由用户自己实现，不自动生成。如果一个属性声明为@dynamic var，又没有提供setter和getter方法，编译的时候不会有问题，如果程序中运行到person.name = newName;或newName=person.name时候就会导致程序崩溃。因为”unrecognized selector sent to instance …”这就是动态绑定。</p>\n<p><strong>57、@property(copy)NSMutableArray *array;这句代码有什么问题？如果有请简述原因；</strong></p>\n<p>（1）添加、删除、修改数组内的元素的时候，程序会因为找不到对应的方法而崩溃，因为copy就是复制一个不可变的NSArray对象。</p>\n<p>（2）没有使用nonatomic属性修饰符，默认是 atomic修饰，这样会严重影响性能。</p>\n<p><strong>58、NSString <em>str = @“hello world!”与NSString </em>str =  [[NSString alloc] initWithString:@”hello world!”];在内存管理上有什么区别？</strong></p>\n<p>在MRC中，前者表示，你不持有这个对象，所以不需要手动管理其内存。后者意味着你持有这个字符串，需要自己手动管理内存，对其进行释放。</p>\n<p><strong>59、对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别是什么类型的对象?</strong></p>\n<p>编译时是NSString类型对象，运行时时NSData类型对象<br>首先，声明NSString*testObject是告诉编译器,obj是一个指向某个Objective-C对象的指针，因为不管指向的是什么类型的对象，一个指针所占的内存空间都是固定的，所以这里声明称任何类型的对象，最终生成的可执行代码都是没有区别的。这里限定了NSString只不过是告诉编译器，请把obj当做一个NSString来检查，如果后面调用了非NSString的方法，会产生警告，接着，你创建了一个NSData对象，然后把这个对象所在的内存地址保存在obj里。那么运行时，obj指向的内存空间就是一个NSData对象。你可以把obj当做一个NSData对象来用。</p>\n<p><strong>60、self.name=object与name=object在内存管理上有什么区别？</strong></p>\n<p>前者通过调用setter方法设置值，后者是普通的赋值操作。</p>\n<p><strong>61、为什么property声明中只有”copy”特性而没有“mutableCopy”特性？</strong></p>\n<p>这是由于当声明property为”copy”特性时，系统会自动根据receiver的特点决定使用copy（已含retain的情况）还是mutableCopy。</p>\n<p><strong>62、Objective-C中id与void*有什么区别？id与instancetype有什么区别？nil、null、NULL三者有什么区别？</strong></p>\n<p>Objective-C中id与void*区别：</p>\n<p>id是指向OC类对象的指针，它可以声明为任何类对象的指针，当在OC中使用id时，编译器会假定你知道，id指向哪个类的对象。与void<em>不同，void</em>编译器不知道也不假定指向任何类型的指针。</p>\n<p>id与instancetype区别：</p>\n<p>id返回的是id类型，instancetype返回的是所在类的类型。</p>\n<p>相同点是同样都是作为方法的返回类型。</p>\n<p>区别：</p>\n<p>(1)    instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象。</p>\n<p>(2)    instancetype只能作为返回值，id可以作为参数。</p>\n<p>nil、Nil、NULL三者区别：</p>\n<p>nil是一个指向不存在的对象指针（对象空指针）。Nil是指向不存在的类指针（类空指针）。NULL指向其他类型的空指针。NSNull在集合对象中，表示空值的对象。</p>\n<p><strong>63、数据解析方式有几种？他们有什么区别？你项目中采用的是哪种数据解析方式？</strong></p>\n<p>JSON和XML。</p>\n<p><strong>64、用预处理指令#define声明一个常数，用以表明1年中有多少秒（忽略闰年问题）</strong></p>\n<p>“#define SECONDS_PER_YEAR(60<em>60</em>24*365)UL”</p>\n<p><strong>65、写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。</strong></p>\n<p>“#define MIN(X,Y) ((X)&gt;(Y)?(X):(Y))”</p>\n<p><strong>66、+load和+initialize 的区别是什么？</strong></p>\n<p>+initialize:第一次初始化这个类之前被调用，我们用它来初始化静态变量。</p>\n<p>+load方法会在加载类的时候就被调用，也就是iOS应用启动的时候，就会加载所有的类。</p>\n<p>+initialize方法类似一个懒加载，如果没有使用这个类，系统默认不会去调用这个方法，且默认只加载一次。</p>\n<p>如果是在类别中，+load方法会全都执行，但是类别中的load方法会后于类中的方法，+initialize方法会覆盖类中的方法，只执行一个。</p>\n<p>+initialize的调用发生在+init方法之前。子类会去调用父类的+initialize方法。</p>\n<p><strong>67、new和alloc/init的区别</strong></p>\n<p>概括来说，new和alloc/init在功能上几乎是一致的，分配内存并完成初始化。<br>差别在于，采用new的方式只能采用默认的init方法完成初始化。<br>而采用alloc的方式可以用其他定制的初始化方法。</p>\n<p><strong>68、如果让你设计接口与API，应该注意点什么？</strong></p>\n<p>（1）用前缀避免命名空间冲突</p>\n<p>（2）提供“全能初始化方法”</p>\n<p>（3）实现description方法</p>\n<p>（4）尽量使用不可变对象</p>\n<p>（5）使用清晰而协调的命名方法</p>\n<p>（6）为私有方法名加前缀</p>\n<p>（7）错误处理</p>\n<p>（8）实现NSCopying协议。</p>\n<p><strong>69、你在项目中用过懒加载吗？能简单的说说懒加载吗？</strong></p>\n<p>懒加载又称为延迟加载。写的是其get方法。如果是懒加载的话则一定要注意先判断是否已经有了，如果没有那么再去进行实例化。</p>\n<p>好处是不必将创建对象的代码全部写在viewDidLoad方法中，代码的可读性更强。每个控件的getter方法中分别负责各自的实例化处理，代码彼此之间的独立性强，松耦合。</p>\n<p><strong>70、进程和线程的区别与联系。</strong></p>\n<p>进程是个静态的容器，里面容纳了很多个线程，线程是一系列方法的线性执行路径。</p>\n<p><strong>71、简述内存分区情况。</strong></p>\n<p>栈区：存放函数的参数值，局部变量的值等。由编译器自动分配释放</p>\n<p>堆区：由程序员分配释放。程序员如果不释放，则程序结束时可能由系统回收</p>\n<p>全局区：全局变量和静态变量是存储在一块的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在另一块区域。程序结束后由系统释放。全局区可分为未初始化全局区：.bbs段和初始化全局区：data段。</p>\n<p>常量区：存放常量字符串，程序结束后由系统释放</p>\n<p>代码区：存放函数体的二进制代码。</p>\n<p><strong>72、队列与栈有什么区别?</strong></p>\n<p>栈：限定仅在表尾进行插入或删除操作的线性表。表尾是栈顶，表头是栈底。它又称后进先出线性表。</p>\n<p>队列：是一种先进先出的线性表。它只允许在表的一端进行插入，而在另一端删除元素。</p>\n<p><strong>73、Objective-C中多线程的编程方式有几种</strong></p>\n<p>pthread、NSThread、NSOperation、GCD。</p>\n<p><strong>74、Objective-C运行时（runtime）机制了解吗？简单的说说对象调用方法的过程。</strong></p>\n<p>对象调用方法的过程：(<a href=\"http://tech.glowing.com/cn/objective-c-runtime/\" target=\"_blank\" rel=\"external\">Objective-C Runtime</a>)</p>\n<p>（1）在对象类的dispatch table中尝试找到该消息。如果找到了，跳到相应的函数IMP去执行实现代码</p>\n<p>（2）如果没有找到，Runtime会发送+resolveInstanceMethod: 或者 +resolveClassMethod: 尝试去resolve这个消息</p>\n<p>（3）如果resolve方法返回NO，Runtime就发送 -forwardingTargetForSelector: 允许你把这个消息转发给另一个对象；</p>\n<p>（4）如果没有新的目标对象返回，Runtime 就会发送 -methodSignatureForSelector: 和 -forwardInvocation: 消息。你可以发送 -invokeWithTarget: 消息来手动转发消息或者发送 -doesNotRecognizeSelector: 抛出异常。</p>\n<p><strong>参考资料如下：</strong></p>\n<p>（1）<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md\" target=\"_blank\">《招聘一个靠谱的 iOS》—参考答案（上）</a></p>\n<p>（2）<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md\" target=\"_blank\">《招聘一个靠谱的 iOS》—参考答案（下）</a></p>\n<p><strong>本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！</strong></p>\n<p><strong>如需转载，请注明出处</strong></p>\n","excerpt":"<p><strong>1、简述你项目中常用的设计模式。它们有什么优缺点？</strong></p>\n<p>常用的设计模式有：代理、观察者、单例。</p>\n<p>（1）单例：它是用来限制一个类只能创建一个对象。这个对象中的属性可以存储全局共享的数据。所有的类都能访问、设置此单例中的属性数据。</p>\n<p>优点：是它只会创建一个对象容易供外界访问，节约性能。<br>","more":"</p>\n<p>缺点：是一个类只有一个对象，可能造成责任过重，在一定程度上违背了“单一职责原则”。单例模式中没有抽象层，所以单例类的扩展有很大的困难。不能过多创建单例，因为单例从创建到程序关闭前会一直存在，过多的单例会影响性能，浪费系统资源。</p>\n<p>（2）观察者（KVO）:它提供了观察某一属性变化的方法。当指定对象的属性发生改变后，它会自动通知相应的观察者。</p>\n<p>优点：能提供被观察者属性的新值与旧值。用keypaths来观察属性，因此也可以观察嵌套对象。 </p>\n<p>缺点：需要注册观察者，实现observeValueForKeyPath:方法，属性必须通过KVC的方法来修改。否则观察者收不到通知。</p>\n<p>（3）代理：可以实现类与类之间一对一的通信。</p>\n<p>优点：代理协议方法都有清晰的定义。代理方法可以设置可选或必须实现。</p>\n<p>缺点：需要定义协议方法，需要设置代理对象，代理对象实现协议方法。内存管理方面，需要注意循环引用问题。</p>\n<p><strong>2、代理模式能否实现一对多的通信？</strong></p>\n<p>可以，采用多播委托的方式来实现。多播委托：它是指允许创建方法的调用列表或者链表的能力。当多播委托被调用时，列表中的方法均自动执行。</p>\n<p>普通代理只能是一对一的回调，无法做到一对多的回调，而多播委托正式对delegate的一种扩展与延伸，多了一个注册和取消的过程。任何需要回调的对象都必须先注册。</p>\n<p><strong>3、    重复注册通知会有问题吗？</strong></p>\n<p>不会出现问题，若多次发送同一通知，对方就会多次响应。如果重复注册通知，也会有多次响应的效果。为了避免重复注册通知而造成的错误，建议每次注册一个通知前，可以移除一次该通知。</p>\n<p><strong>4、项目中是否用过多线程编程？简述你常用的多线程实现方式？</strong></p>\n<p>常用的是GCD。</p>\n<p>GCD是苹果开发中一个多核编程的解决方案。GCD的队列分为两种类型，SerialDispatchQueue与ConcurrentDispatchQueue。系统默认提供了一个dispatch_get_main_queue，一个dispatch_get_global_queue。</p>\n<p><strong>5、简述NSOperationQueue与GCD的区别。</strong></p>\n<p>(1)    GCD是底层的C语言构成的API。NSOperationQueue及相关对象是Objc对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构。而Operation作为一个对象，为我们提供了更多的选择。</p>\n<p>(2)    在NSOperationQueue中，我们可以取消任务，而GCD没法停止已经加入queue的block。</p>\n<p>(3)    NSOperation能够方便的设置依赖关系。还能设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行。在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务优先级也需要大量复杂代码。<br>NSOperation还可以设置并发数。</p>\n<p><strong>6、实现多线程有哪几种方式？</strong></p>\n<p>（1）NSThread:detachNewThreadSelector:</p>\n<p>（2）继承NSOperation</p>\n<p>（3）GCD：dispatch_async</p>\n<p>（4）NSObject：performSelectorInBackground:</p>\n<p><strong>7、KVC、KVO是什么？简述KVO的实现原理。KVO能否监听数组？如何实现？</strong></p>\n<p>KVC:键值编码，它是一种间接访问对象实例变量机制，可以不通过存取方法访问对象的实例变量。</p>\n<p>KVO:键值观察，它可以使对象获取其他对象属性变化的通知机制。</p>\n<p>键值编码和键值观察是根据isa-swizzling技术来实现的，主要依据runtime的强大动态能力。当给某个对象第一次添加KVO监听的时候，运行时会动态的创建一个被监听对象的派生类，然后重写KVO需要监听属性值对应的setter方法，在这个setter方法中实现了通知机制。最后将被监听对象的isa指向动态创建的派生类。这样当使用KVC修改属性值时，就会调用动态创建的派生类中对应的setter方法，触发通知机制，从而实现了KVO了。<br>KVO可以监听数组。</p>\n<p>实现 NSMutableArray 的增删改操作遵从 KVC 的规则，需要实现其对应方法:</p>\n<p>增操作 -insertObject:in<Key>AtIndex: 或者 -insert<Key>:atIndexes:</p>\n<p>删操作 -removeObjectFrom<Key>AtIndex: 或者 -remove<Key>AtIndexes:</p>\n<p>改操作 -replaceObjectIn<Key>AtIndex:withObject: 或者 -replace<Key>AtIndexes:with<Key>:</p>\n<p>并将这些接口暴露给调用者，在对数组进行操作时需使用上述实现的接口。</p>\n<p><strong>8、简单说下C++，JAVA，Objective-C这几种语言有什么区别？</strong></p>\n<p>Objective-C与JAVA都是单继承语言，C++是多继承语言。</p>\n<p>Objective-C不支持命名空间机制，通过类名前面加前缀NS来区分。</p>\n<p>Objective-C与JAVA不支持运算符重载。</p>\n<p>Objective-C协议可选实现，JAVA的接口必须实现。</p>\n<p><strong>9、数组添加nil元素有问题吗？字典object与key可以设置为nil吗？</strong></p>\n<p>会有问题，数组中添加nil元素，程序会崩溃！报object cannot be nil错误。字典的key不能为nil，否则会造成崩溃。字典的object也不能为nil。</p>\n<p><strong>10、oc中向一个nil对象发送消息会出现问题吗？</strong></p>\n<p>不会出现问题，因为objc是动态语言，每个方法在运行时会被动态转为消息发送。即：objc_msgSend(receiver，selector)。objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。</p>\n<p><strong>11、可变数组是线程安全的吗？什么情况下不安全？可以加锁吗？它锁住的是添加元素操作还是数组对象？</strong></p>\n<p>可变数组不是线程安全的，在异步读取数据的情况下是不安全的。可以加锁，锁住的是数组。</p>\n<p><strong>12、数组能添加一个block吗？数组添加一个block之后再取出来，这个block还有用吗？</strong></p>\n<p>可以，还有用，它只是多retain了一次</p>\n<p><strong>13、NSMutableDictionary中的setObject:forKey:与setValue:forKey:方法有什么区别?</strong></p>\n<p>setObject:forkey:中value是不能够为nil的，不然会报错。</p>\n<p>setValue:forKey:中的value能够为nil，但是当value为nil的时候，会自动调用removeObject:forKey方法。</p>\n<p>setValue:forKey:中的key的参数只能是NSString类型，而setObject:forKey是可以任何类型。</p>\n<p><strong>14、简述copy与mutablecopy的区别。</strong></p>\n<p>（1）非容器对象：</p>\n<p>对不可变对象：copy是指针复制（浅拷贝）， mutableCopy是对象复制（深拷贝）。<br>对可变对象：copy和mutableCopy都是对象复制。</p>\n<p>（2）容器对象：</p>\n<p>对不可变对象：copy是指针复制，mutableCopy是对象复制。</p>\n<p>对可变对象：copy和mutableCopy都是对象复制，只是返回的对象类型不一样，前者返回的是不可变对象，后者返回的是可变对象。</p>\n<p>容器对象复制仅限于对象本身，对象元素仍然是指针复制。</p>\n<p><strong>15、简述weak与assign的区别。</strong></p>\n<p>weak用来修饰对象，不能修饰基本数据类型。assign一般用来修饰基本数据类型。weak修饰对象，在对象释放之后会把对象置为nil。</p>\n<p><strong>16、ARC下，不显示指定任何属性关键字时，默认的关键字有哪些？</strong></p>\n<p>基本数据类型默认修饰关键字：atomic,readwrite,assign</p>\n<p>普通的OC对象默认修饰关键字：atomic,readwrite,strong</p>\n<p><strong>17、weak在什么时候置空？</strong></p>\n<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>\n<p>我们可以设计一个函数（伪代码）来表示上述机制：</p>\n<p>objc_storeWeak(&amp;a, b)函数：</p>\n<p>objc_storeWeak函数把第二个参数–赋值对象（b）的内存地址作为键值key，将第一个参数–weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除，<br>你可以把objc_storeWeak(&amp;a, b)理解为：objc_storeWeak(value, key)，并且当key变nil，将value置nil。</p>\n<p>在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>\n<p>而如果a是由assign修饰的，则： 在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。</p>\n<p>下面我们将基于objc_storeWeak(&amp;a, b)函数，使用伪代码模拟“runtime如何实现weak属性”：</p>\n<p>// 使用伪代码模拟：runtime如何实现weak属性<br>id obj1;<br>objc_initWeak(&amp;obj1, obj);<br>/<em>obj引用计数变为0，变量作用域结束</em>/<br>objc_destroyWeak(&amp;obj1);</p>\n<p>下面对用到的两个方法objc_initWeak和objc_destroyWeak做下解释：</p>\n<p>总体说来，作用是： 通过objc_initWeak函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过objc_destoryWeak函数释放该变量（obj1）。</p>\n<p>下面分别介绍下方法的内部实现：</p>\n<p>objc_initWeak函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用objc_storeWeak函数。<br>obj1 = 0；<br>obj_storeWeak(&amp;obj1, obj);</p>\n<p>也就是说：<br>weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）<br>然后obj_destroyWeak函数将0（nil）作为参数，调用objc_storeWeak函数。<br>objc_storeWeak(&amp;obj1, 0);<br>前面的源代码与下列源代码相同。</p>\n<p>// 使用伪代码模拟：runtime如何实现weak属性<br>id obj1;<br>obj1 = 0;<br>objc_storeWeak(&amp;obj1, obj);<br>/<em> … obj的引用计数变为0，被置nil … </em>/<br>objc_storeWeak(&amp;obj1, 0);</p>\n<p>objc_storeWeak函数把第二个参数–赋值对象（obj）的内存地址作为键值，将第一个参数–weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除，在后面的相关一题会详解。</p>\n<p>以上内容总结如下：</p>\n<p>（1）从weak表中获取废弃对象的地址为键值的记录</p>\n<p>（2）将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil</p>\n<p>（3）从weak表中删除该记录</p>\n<p>（4）从引用计数表中删除废弃对象的地址为键值的记录。</p>\n<p><strong>18、自动释放池用过吗？它是什么时候释放？什么情况下对象会被加入到自动释放池，它会加入到哪个自动释放池?</strong></p>\n<p>主线程默认开启runloop,同时runloop会自动创建一个autoreleasepool，autorelease对象会自动被加入autoreleasepool中，一次runloop后清空自动释放池。用__autoreleasing修饰符修饰，或类方法创建会自动加入autoreleasepool。它会加入到最近的autoreleasepool中。</p>\n<p><strong>19、你知道iOS中有哪些数据持久化方式吗？请简要加以说明。</strong></p>\n<p>iOS中数据持久化方式有：SQLite3数据库，CoreData，文件归档，属性列表（plist文件写入）。</p>\n<p>属性列表：涉及的主要类是NSUserDefaults，存储小量的数据。</p>\n<p>文件归档：对象必须实现NSCoding协议。实现initWithCoder:方法与encodeWithCoder方法。同时也建议实现NSCopying协议。</p>\n<p>SQLite3数据库:SQLite是一个开源的嵌入式关系数据库。可移植性好，容易使用，需要内存开销小。适合嵌入式设备。</p>\n<p>CoreData：它可以使用SQLite保存数据，而且不需要写SQL语句。另外它还可以使用XML方式保存数据。要使用CoreData，需要在Xcode中的数据模型编辑器中设计好各个实体以及定义好他们的属性和关系。通过操作这些对象来完成数据的持久化。</p>\n<p><strong>20、fmdb中支持多线程吗？它是如何实现的！</strong></p>\n<p>支持多线程。它里面有个FMDatabaseQueue类。它看似是一个队列，实际上它本身并不是，它继承NSObject，通过内部创建一个Serial的dipatch_queue_t来处理inDatabase和inTransaction传入的Block，所以当我们在主线程（或者后台）调用inDatabase或者inTransaction时，代码实际上是同步的。FMDatabaseQueue如此设计的目的是为了避免并发访问数据库的线程安全问题，所有的数据库访问都是同步执行，比@synchronized与NSLock效率高。</p>\n<p><strong>21、简述category与extension的区别。Category与extension加载的时机。</strong></p>\n<p>category中只能增加方法，不可添加实例变量（可添加属性）。extension不仅可以增加方法，还可以增加实例变量或属性（私有的）。extension不能像category一样有独立的实现部分。category是运行时决定的。extension是编译期决定的。</p>\n<p><strong>22、category的方法能被子类继承吗？它覆盖原有类的方法后，原有类的方法还能调用吗？如果能，你说明理由。</strong></p>\n<p>category的方法可以被子类继承。category并不是绝对的覆盖了类的同名方法，而是category的方法排在了类的同名方法之前，方法的检索方式是顺序检索，所以在调用方法时，调用到的同名方法是category，从而产生了覆盖。<br>利用运行时遍历方法列表，可以调用被category覆盖的方法。</p>\n<p><strong>23、    扩展一个类的方式用继承好还是category好？请说明理由。</strong></p>\n<p>用类目好。因为继承还需要定义子类。类目不需要通过创建子类来增加现有类的方法。用category去重写一个类的方法，仅仅只对本category有效，不会影响到其他类与原有类的关系。</p>\n<p><strong>24、    block有几种类型？block的实现？</strong></p>\n<p>block分为三种类型:</p>\n<p>_NSConcreteGlobalBlock</p>\n<p>_NSConcreteStackBlock</p>\n<p>_NSConcreteMallocBlock</p>\n<p>block：匿名函数</p>\n<p><strong>25、    Swift用的多吗？简单的说说1.0与2.0的区别。</strong></p>\n<p>swift2.0新增:guard语句，异常处理，协议扩展，打印语句改变，avaliable检查，do-while语句重命名：repeat-while，defer关键字</p>\n<p><strong>26、    在Swift用有没有用过defer关键字？</strong></p>\n<p>对defer语句进行的延迟，函数结束时调用。</p>\n<p><strong>27、    SDWebImage的图片保存在什么位置？</strong></p>\n<p>图片保存在沙盒中的library/caches文件夹下。</p>\n<p><strong>28、    Objective-C中类目为什么不能添加实例变量？</strong></p>\n<p>因为在运行时，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局。</p>\n<p><strong>29、    Objective-C中的协议默认是@optional还是@require？在使用协议的时候应当注意哪些问题？</strong></p>\n<p>Objective-C中的协议默是必须实现的@require，使用协议的时候应当注意循环引用问题，多个协议之间采用逗号分隔。</p>\n<p><strong>30、    Objective-C的协议与JAVA中的接口有什么区别？</strong></p>\n<p>OC中的协议可选实现，JAVA中的接口必须实现。</p>\n<p><strong>31、    类目的应用场景有哪些？</strong></p>\n<p>（1）可以把类的实现分开在几个不同的文件里面</p>\n<p>（2）声明私有方法</p>\n<p>（3）模拟多继承</p>\n<p>（4）把Framework的私有方法公开</p>\n<p><strong>32、    self与super的区别？</strong></p>\n<p>super本质上是一个编译器标示符，它和self指向的是同一个消息接受者，两者不同在于：super会告诉编译器，调用class这个方法时，要去父类方法，而不是本类方法。<br><strong>33、    图片缓存为什么不保存到沙盒下的tmp文件目录中？</strong></p>\n<p>因为tmp文件夹是用来存放临时文件，iTunes不会备份和恢复此目录，此目录下文件可能会在应用退出后删除。</p>\n<p><strong>34、    NSURLConnection与NSURLSession。</strong></p>\n<p>NSURLConnection它是CoreFoundation/CFNetwork框架的API之上的一个抽象。</p>\n<p>NSURLConnection这个名字实际指代Foundation框架的URL加载系统中一系列有关联的组件：NSURLRequest、NSURLResponse、NSURLProtocol、NSURLCache、NSHTTPCookieStorage、NSURLCredentialStorage以及同名类NSURLConnection。NSURLRequest 被传递给 NSURLConnection。被委托对象（遵守以前的非正式协议 <NSURLConnectionDelegate> 和 <NSURLConnectionDataDelegate>）异步地返回一个 NSURLResponse 以及包含服务器返回信息的 NSData。</p>\n<p>NSURLSession包括：NSURLRequest、NSURLCache、NSURLSession、NSURLSessionConfiguration、NSURLSessionDataTask、NSURLSessionUploadTask、NSURLSessionDownloadTask。<br>它与NSURLConnection的区别在于：NSURLSession最直接的改进就是可以配置每个Session的缓存，协议，cookie以及正式策略。甚至跨程序共享这些信息。每个NSURLSession对象都由一个NSURLSessionConfiguration对象来进行初始化。<br>session task：负责处理数据的加载以及文件和数据在客户端与服务器之间的上次和下载。</p>\n<p><strong>35、    简述ARC与MRC的区别。</strong></p>\n<p>ARC:自动引用计数。MRC：手动引用计数。ARC是把内存交给系统管理。系统会在编译的时候自动插入retain/release。MRC则需要手动管理对象的引用计数。当你alloc,new,copy,mutablecopy或者retain一个对象时，你就有义务向它发送一条release或autorelease消息。</p>\n<p><strong>36、    简述ARC的实现原理。它在什么时机插入retain/release？</strong></p>\n<p>ARC：自动引用计数。它会在对象创建或者消亡的时候自动插入retain/release。达到自动管理内存的目的。</p>\n<p><strong>37、    Framework与Library的区别？动态库与静态库的区别？</strong></p>\n<p>library与Framework的区别：</p>\n<p>在iOS中，Library 仅能包含编译后的代码，即 .a 文件。<br>但一般来说，一个完整的模块不仅有代码，还可能包含.h 头文修的、.nib 视图文件、图片资源文件、说明文档。（像 UMeng 提供的那些库，集成时，要把一堆的文件拖到Xcode中，配置起来真不是省心的事。<br>Framework 作为 Cocoa/Cocoa Touch 中使用的一种资源打包方式，可以上述文件等集中打包在一起，方便开发者使用（就像Bundle）。</p>\n<p>静态库与动态库的区别：</p>\n<p>简单的说，静态链接库是指模块被编译合并到应用中，应用程序本身比较大，但不再需要依赖第三方库。运行多个含有该库的应用时，就会有多个该库的Copy在内存中，冗余。<br>动态库可以分开发布，在运行时查找并载入到内存，如果有通用的库，可以共用，节省空间和内存。同时库也可以直接单独升级，或作为插件发布。</p>\n<p><strong>38、    什么是runloop？</strong></p>\n<p>一般来说，一个线程一次只能执行一个任务，执行完成后线程就会退出，如果我们需要一个机制，让线程能随时处理事件但并不退出。代码逻辑如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">\rfunction loop() &#123;\r\t\tinitialize();\r\t\tdo &#123;\r\tvar message = get_next_message();\r\tprocess_message(message);\r&#125; while(message != quit)\r&#125;</div></pre></td></tr></table></figure>\n<p>这种模型我们通常称之为EventLoop（事件循环）。RunLoop实际上是一个对象，这个对象管理了其需要处理的事件和消息。并提供了一个入口函数来执行上面EventLoop逻辑。在OSX/iOS系统中，提供了两个这样的对象：NSRunLoop和CFRunLoopRef。</p>\n<p>CFRunLoopRef是在CoreFoundation框架内，它提供了纯C函数的API,所有这些API都是线程安全的。</p>\n<p>NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API，这些API不是线程安全的。</p>\n<p>苹果不允许直接创建RunLoop，只提供了两个自动获取的函数：CFRunLoopGetMain()和CFRunLoopGetCurrent()。</p>\n<p>线程和RunLoop之间是一一对应的。</p>\n<p><strong>39、#include与#import的区别？#import与@class的区别？</strong></p>\n<p>“#include”与”#import”功能一样，都是导出头文件。只是#import不会引起交叉编译，可以确保头文件只导入一次。#import会包含这个类的所有信息。包括实例变量和方法，而@class只是告诉编译器，它后面声明的名称是类的名称，至于类的定义，后面会告诉你。使用#import编译效率高，可以防止相互包含的编译错误。</p>\n<p><strong>40、Static与const的区别？</strong></p>\n<p>const表示只读的意思，只在声明中使用。</p>\n<p>static一般有2个作用，规定作用域和存储方法。对于局部变量，static规定其为静态存储区，每次调用的初始值为上一次调用的值，调用结束后存储空间不释放。</p>\n<p>对于全局变量，如果以文件划分作用域的话，此变量只在当前文件可见，对于static函数也是在当前模块内函数可见。</p>\n<p><strong>41、简述GET请求与POST请求的区别。</strong></p>\n<p>(1)POST 需要明确制定方法 GET不需要 ，并且默认就是GET方法，并且GET有缓存，POST没有缓存</p>\n<p>(2)GET的参数放在URL的后面,并且第一个参数用?拼接,后面的从第二个参数开始,直到最后一个,如果有多个,用&amp;分割;POST 的参数放在请求体里面,并且第一个参数,不用,后面从第二开始,直到最后,如果有多个,用&amp;分割;</p>\n<p>(3)GET 一般用于获取数据，POST向服务器提交数据用到</p>\n<p>(4)GET的参数是暴漏在地址栏的,不安全;POST的参数隐藏在请求体里面,相对安全一点;</p>\n<p>(5)GET请求没有请求体，POST请求有请求体。    </p>\n<p>(6)GET请求提交数据受浏览器限制，1k，POST请求理论上无限制。</p>\n<p><strong>42、属性用__block修饰时在内存中会发生什么变化？</strong></p>\n<p>为什么在block外面用weak修饰属性来打破循环，在block还需要把属性转换成strong。</p>\n<p><strong>43、谈谈block与函数的区别。</strong></p>\n<p>block可以写在方法里面，函数需要写在方法外面。block可以访问方法中的局部变量。</p>\n<p><strong>44、你了解runloop吗？它有几种模式？简要的说下它的应用场景。</strong></p>\n<p>runloop模式：</p>\n<p>Default：</p>\n<p>NSDefaultRunLoopMode(Cocoa)、kCFRunLoopDefaultMode(CoreFoundation)</p>\n<p>Connection：</p>\n<p>NSConnectionReplyMode</p>\n<p>Modal：</p>\n<p>NSModalPanelRunLoopMode</p>\n<p>Event tracking:</p>\n<p>NSEventTrackingRunLoopMode</p>\n<p>Common modes:</p>\n<p>NSRunLoopCommonModes(Cocoa)、kCFRunLoopCommonModes(CoreFoundation)</p>\n<p>应用场景：</p>\n<p>（1）使用端口或自定义输入源与其他线程通信。</p>\n<p>（2）在线程中使用计时器</p>\n<p>（3）使用任意的performSelector方法</p>\n<p>（4）保持线程去执行一个周期任务。</p>\n<p><strong>45、你工作中用到的版本管理工具是什么？</strong></p>\n<p>用的是git工具来进行版本管理。</p>\n<p><strong>46、你用过git工具吗？用过哪些常见的命令？</strong></p>\n<p>git init，git add, git commit，git merge，git branch，git checkout，git pull，git push等</p>\n<p><strong>47、CoreAnimation常用的动画有哪些类型？</strong></p>\n<p>所有的核心动画的动画类都从CAAnimation类继承而来。CAAnimationGroup组动画，CATransition转场动画，CABasicAnimation:基础动画，CAKeyframeAnimation关键帧动画。</p>\n<p><strong>48、GCD中系统提供了几种queue？</strong></p>\n<p>两种：DispatchSerialQueue、DispatchConcurrentQueue。</p>\n<p><strong>49、二叉搜索树的概念及时间复杂度是多少？</strong></p>\n<p>O(n)</p>\n<p><strong>50、block中的weak self，是任何时候都需要加的么？</strong></p>\n<p>不一定，可加可不加。将block置nil也可以打破循环引用。</p>\n<p><strong>51、GCD的queue，main queue中执行的代码，一定是在main thread么？</strong></p>\n<p>是的。一定是在main thread。</p>\n<p><strong>52、你在使用数据库的过程中有没有遇到过问题？如何解决？</strong></p>\n<p>遇到过多线程操作数据库读写死锁问题，采用fmdb中提供的回滚的方式解决</p>\n<p><strong>53、简述iOS中的沙盒机制。</strong></p>\n<p>iOS中的沙盒机制是一种安全体系，它规定了应用程序只能在为该应用创建的文件夹读取文件，不可以访问其他地方的内容。所有非代码文件都保存在这个地方。如图片，声音，属性列表及文本文件等。</p>\n<p>（1）每个应用程序都在自己的沙盒内</p>\n<p>（2）不能随意跨越自己的沙盒去访问别的应用程序沙盒的内容</p>\n<p>（3）应用程序向外请求或者接收数据都需要经过权限认证。</p>\n<p>沙盒目录结构这种，因为应用是在沙箱（sandbox）中的，在文件读写权限上受到限制，只能在几个目录下读写文件：</p>\n<p>Documents：应用中用户数据可以放在这里，iTunes备份和恢复的时候会包括此目录</p>\n<p>tmp：存放临时文件，iTunes不会备份和恢复此目录，此目录下文件可能会在应用退出后删除</p>\n<p>Library：存储程序的默认设置或其他状态信息。</p>\n<p>Library/Caches：存放缓存文件，iTunes不会备份此目录，此目录下文件不会在应用退出删除</p>\n<p><strong>54、字符串为什么要用copy修饰？</strong></p>\n<p>是为了防止mutablestring被无意中修改，NSMutableString是NSString的子类。因此NSString指针可以持有NSMutableString对象。</p>\n<p><strong>55、nonatomic与atomic有什么区别？</strong></p>\n<p>atomic是Objective-C使用的一种线程保护技术，它是为了防止写操作在未完成的时候被另外一个线程读取。从而造成数据错误。这种机制是非常耗费系统资源的，所以在iphone这种小的移动设备上，如果没有使用多线程间的通讯编程。建议使用nonatomic。</p>\n<p>默认的访问器是原子操作，就是说在多线程环境下，解析的访问器提供一个对属性安全访问，从获取器得到的返回值或者通过设置器设置的值可以一次完成，即便是多线程也在对其进行访问，如果不指定nonatomic ，在自己管理内存的环境中，解析的访问器保留并自动释放保留的值，如果是指定了nonatomic，访问器只是简单的返回一个值。</p>\n<p><strong>56、@synthesize与@dynamic的区别？</strong></p>\n<p>@synthesize：如果你没有手动实现setter方法和getter方法，编译器会自动为帮你生成setter方法和getter方法。</p>\n<p>@dynamic：告诉编译器属性的setter和getter方法由用户自己实现，不自动生成。如果一个属性声明为@dynamic var，又没有提供setter和getter方法，编译的时候不会有问题，如果程序中运行到person.name = newName;或newName=person.name时候就会导致程序崩溃。因为”unrecognized selector sent to instance …”这就是动态绑定。</p>\n<p><strong>57、@property(copy)NSMutableArray *array;这句代码有什么问题？如果有请简述原因；</strong></p>\n<p>（1）添加、删除、修改数组内的元素的时候，程序会因为找不到对应的方法而崩溃，因为copy就是复制一个不可变的NSArray对象。</p>\n<p>（2）没有使用nonatomic属性修饰符，默认是 atomic修饰，这样会严重影响性能。</p>\n<p><strong>58、NSString <em>str = @“hello world!”与NSString </em>str =  [[NSString alloc] initWithString:@”hello world!”];在内存管理上有什么区别？</strong></p>\n<p>在MRC中，前者表示，你不持有这个对象，所以不需要手动管理其内存。后者意味着你持有这个字符串，需要自己手动管理内存，对其进行释放。</p>\n<p><strong>59、对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别是什么类型的对象?</strong></p>\n<p>编译时是NSString类型对象，运行时时NSData类型对象<br>首先，声明NSString*testObject是告诉编译器,obj是一个指向某个Objective-C对象的指针，因为不管指向的是什么类型的对象，一个指针所占的内存空间都是固定的，所以这里声明称任何类型的对象，最终生成的可执行代码都是没有区别的。这里限定了NSString只不过是告诉编译器，请把obj当做一个NSString来检查，如果后面调用了非NSString的方法，会产生警告，接着，你创建了一个NSData对象，然后把这个对象所在的内存地址保存在obj里。那么运行时，obj指向的内存空间就是一个NSData对象。你可以把obj当做一个NSData对象来用。</p>\n<p><strong>60、self.name=object与name=object在内存管理上有什么区别？</strong></p>\n<p>前者通过调用setter方法设置值，后者是普通的赋值操作。</p>\n<p><strong>61、为什么property声明中只有”copy”特性而没有“mutableCopy”特性？</strong></p>\n<p>这是由于当声明property为”copy”特性时，系统会自动根据receiver的特点决定使用copy（已含retain的情况）还是mutableCopy。</p>\n<p><strong>62、Objective-C中id与void*有什么区别？id与instancetype有什么区别？nil、null、NULL三者有什么区别？</strong></p>\n<p>Objective-C中id与void*区别：</p>\n<p>id是指向OC类对象的指针，它可以声明为任何类对象的指针，当在OC中使用id时，编译器会假定你知道，id指向哪个类的对象。与void<em>不同，void</em>编译器不知道也不假定指向任何类型的指针。</p>\n<p>id与instancetype区别：</p>\n<p>id返回的是id类型，instancetype返回的是所在类的类型。</p>\n<p>相同点是同样都是作为方法的返回类型。</p>\n<p>区别：</p>\n<p>(1)    instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象。</p>\n<p>(2)    instancetype只能作为返回值，id可以作为参数。</p>\n<p>nil、Nil、NULL三者区别：</p>\n<p>nil是一个指向不存在的对象指针（对象空指针）。Nil是指向不存在的类指针（类空指针）。NULL指向其他类型的空指针。NSNull在集合对象中，表示空值的对象。</p>\n<p><strong>63、数据解析方式有几种？他们有什么区别？你项目中采用的是哪种数据解析方式？</strong></p>\n<p>JSON和XML。</p>\n<p><strong>64、用预处理指令#define声明一个常数，用以表明1年中有多少秒（忽略闰年问题）</strong></p>\n<p>“#define SECONDS_PER_YEAR(60<em>60</em>24*365)UL”</p>\n<p><strong>65、写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。</strong></p>\n<p>“#define MIN(X,Y) ((X)&gt;(Y)?(X):(Y))”</p>\n<p><strong>66、+load和+initialize 的区别是什么？</strong></p>\n<p>+initialize:第一次初始化这个类之前被调用，我们用它来初始化静态变量。</p>\n<p>+load方法会在加载类的时候就被调用，也就是iOS应用启动的时候，就会加载所有的类。</p>\n<p>+initialize方法类似一个懒加载，如果没有使用这个类，系统默认不会去调用这个方法，且默认只加载一次。</p>\n<p>如果是在类别中，+load方法会全都执行，但是类别中的load方法会后于类中的方法，+initialize方法会覆盖类中的方法，只执行一个。</p>\n<p>+initialize的调用发生在+init方法之前。子类会去调用父类的+initialize方法。</p>\n<p><strong>67、new和alloc/init的区别</strong></p>\n<p>概括来说，new和alloc/init在功能上几乎是一致的，分配内存并完成初始化。<br>差别在于，采用new的方式只能采用默认的init方法完成初始化。<br>而采用alloc的方式可以用其他定制的初始化方法。</p>\n<p><strong>68、如果让你设计接口与API，应该注意点什么？</strong></p>\n<p>（1）用前缀避免命名空间冲突</p>\n<p>（2）提供“全能初始化方法”</p>\n<p>（3）实现description方法</p>\n<p>（4）尽量使用不可变对象</p>\n<p>（5）使用清晰而协调的命名方法</p>\n<p>（6）为私有方法名加前缀</p>\n<p>（7）错误处理</p>\n<p>（8）实现NSCopying协议。</p>\n<p><strong>69、你在项目中用过懒加载吗？能简单的说说懒加载吗？</strong></p>\n<p>懒加载又称为延迟加载。写的是其get方法。如果是懒加载的话则一定要注意先判断是否已经有了，如果没有那么再去进行实例化。</p>\n<p>好处是不必将创建对象的代码全部写在viewDidLoad方法中，代码的可读性更强。每个控件的getter方法中分别负责各自的实例化处理，代码彼此之间的独立性强，松耦合。</p>\n<p><strong>70、进程和线程的区别与联系。</strong></p>\n<p>进程是个静态的容器，里面容纳了很多个线程，线程是一系列方法的线性执行路径。</p>\n<p><strong>71、简述内存分区情况。</strong></p>\n<p>栈区：存放函数的参数值，局部变量的值等。由编译器自动分配释放</p>\n<p>堆区：由程序员分配释放。程序员如果不释放，则程序结束时可能由系统回收</p>\n<p>全局区：全局变量和静态变量是存储在一块的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在另一块区域。程序结束后由系统释放。全局区可分为未初始化全局区：.bbs段和初始化全局区：data段。</p>\n<p>常量区：存放常量字符串，程序结束后由系统释放</p>\n<p>代码区：存放函数体的二进制代码。</p>\n<p><strong>72、队列与栈有什么区别?</strong></p>\n<p>栈：限定仅在表尾进行插入或删除操作的线性表。表尾是栈顶，表头是栈底。它又称后进先出线性表。</p>\n<p>队列：是一种先进先出的线性表。它只允许在表的一端进行插入，而在另一端删除元素。</p>\n<p><strong>73、Objective-C中多线程的编程方式有几种</strong></p>\n<p>pthread、NSThread、NSOperation、GCD。</p>\n<p><strong>74、Objective-C运行时（runtime）机制了解吗？简单的说说对象调用方法的过程。</strong></p>\n<p>对象调用方法的过程：(<a href=\"http://tech.glowing.com/cn/objective-c-runtime/\">Objective-C Runtime</a>)</p>\n<p>（1）在对象类的dispatch table中尝试找到该消息。如果找到了，跳到相应的函数IMP去执行实现代码</p>\n<p>（2）如果没有找到，Runtime会发送+resolveInstanceMethod: 或者 +resolveClassMethod: 尝试去resolve这个消息</p>\n<p>（3）如果resolve方法返回NO，Runtime就发送 -forwardingTargetForSelector: 允许你把这个消息转发给另一个对象；</p>\n<p>（4）如果没有新的目标对象返回，Runtime 就会发送 -methodSignatureForSelector: 和 -forwardInvocation: 消息。你可以发送 -invokeWithTarget: 消息来手动转发消息或者发送 -doesNotRecognizeSelector: 抛出异常。</p>\n<p><strong>参考资料如下：</strong></p>\n<p>（1）<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md\" target=\"_blank\">《招聘一个靠谱的 iOS》—参考答案（上）</a></p>\n<p>（2）<a href=\"https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（下）.md\" target=\"_blank\">《招聘一个靠谱的 iOS》—参考答案（下）</a></p>\n<p><strong>本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！</strong></p>\n<p><strong>如需转载，请注明出处</strong></p>"},{"layout":"post","title":"React Native iOS 开发环境搭建","date":"2016-01-20T17:07:09.000Z","comments":1,"keywords":"React Native, Hybrid, iOS, Xcode","_content":"#### 一、React Native基础环境搭建\n\n1、安装<a href=\"http://brew.sh\">Homebrew</a>\n\n打开终端输入：\n`\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n`\n<!--more-->\n2、安装<a href=\"https://github.com/creationix/nvm#installation\">nvm</a>方法\n\n通过脚本安装方式，在终端执行：\n`\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.1/install.sh | bash\n`\n\n激活nvm,在安装脚本执行完之后，在终端执行:\n`\n. ~/.nvm/nvm.sh\n`\n\nnvm其他安装方式详见<a href=\"https://github.com/creationix/nvm#installation\">安装向导</a>\n\n3、默认安装最新版本的Node.js并且设置好命令行的环境变量\n`\nnvm install node && nvm alias default node\n`\n\n可以输入node命令启动Node.js环境，npm(node package manager)文档传送门:<a href=\"https://docs.npmjs.com\">\"点击此处\"</a>\n\n4、安装watchman\n\n在终端输入：\n`\nbrew install watchman\n`\n\n到此处React Native基础环境搭建基本完成，推荐经常运行`brew update && brew upgrade`命令保持你的程序是最新的。\n\n#### 二、iOS开发环境\n\n1、iOS开发环境：（默认读者已经安装**Xcode7.0或以上版本**，没有可自行前往AppStore下载）\n\n* 使用npm（node包管理工具）安装react-native-cli(此处应注意权限问题，如果遇到权限问题，请在下面的命令前加上sudo)\n\n`\nnpm install -g react-native-cli\n`\n\n* 初始化工程（下面的语句中千万不要加sudo，后果自负）\n\n`\nreact-native init ReactNativeProject（工程名）\n`\n\n在初始化的过程中，如果进度缓慢，推荐你将npm仓库源换成国内镜像：(翻墙用户请忽略)\n在终端输入：\n\n```\nnpm config set registry https://registry.npm.taobao.org\nnpm config set disturl https://npm.taobao.org/dist\n```\n\n2、使用Xcode运行调试程序\n\n* 查找ReactNativeProject文件目录\n\n按住快捷键`Command+Shift+G`，在弹出的“前往文件夹”对话框中输入路径`/Users/yangshebing/ReactNativeProject`（yangshebing表示电脑用户名，请自行更改）,点击前往。在文件目中的ios文件夹下找到“ReactNativeProject.xcodeproj”工程文件。如图所示：（有关终端查找该文件目录方法，请自行到文章末尾的参考文章中寻找）\n![](http://ww4.sinaimg.cn/large/7f266405jw1f0651k88wij216s0oa42t.jpg)\n\n* 运行ReactNativeProject工程\n\n使用Xcode打开“ReactNativeProject.xcodeproj”工程文件，按住快捷键\"Command+R\"运行此项目，运行成功后便可在模拟器上看到效果。\n\n* 编辑index.ios.js文件修改界面\n\n笔者编辑index.ios.js文件工具是Vim，每当编辑完index.ios.js文件并保存之后，在模拟器(Simulator)中，按`Command+R`可刷新界面查看改变后的效果。\n\n下面我们也试着稍微修改一下index.ios.js文件：\n\n```\n/**\n * Sample React Native App\n * https://github.com/facebook/react-native\n */\n'use strict';\nimport React, {\n  AppRegistry,\n  Component,\n  StyleSheet,\n  //添加Image全局变量\n  Image,\n  Text,\n  View\n} from 'react-native';\n\nclass ReactNativeProject extends Component {\n  render() {\n    return (\n      <View style={styles.container}>\n      //添加文本展示\n        <Text style={styles.welcome}>\n          美女\n        </Text>\n        //添加图片展示\n        <Image \n        source={{uri: 'http://h.hiphotos.baidu.com/image/pic/item/6609c93d70cf3bc7f0f5b7eed300baa1cd112a3e.jpg'}} \n        //这里需要指定图片的大小\n        style={styles.picture} />\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: '#F5FCFF',\n  },\n  //这里可以设置文本的字体，对齐方式等\n  welcome: {\n    fontSize: 20,\n    textAlign: 'center',\n    margin: 10,\n  },\n  //新增图片style，设置图片大小\n  picture: {\n    width: 80,\n    height: 150,\n  },\n});\n\nAppRegistry.registerComponent('ReactNativeProject', () => ReactNativeProject);\n```\n刷新后运行效果如下图所示：\n![](http://ww3.sinaimg.cn/mw690/7f266405jw1f06flkcxxgj20ku12a3zr.jpg)\n\n* 真机运行调试项目\n\n在`ReactNativeProject`工程中找到AppDelegate.m文件，将`localhost`替换成自己电脑的IP地址。\n\n```\n//  jsCodeLocation = [NSURL URLWithString:@\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\"];\n\n  jsCodeLocation = [NSURL URLWithString:@\"http://192.168.31.168:8081/index.ios.bundle?platform=ios&dev=true\"];\n```\n\n替换完成之后再次运行程序，这个时候可以通过摇晃设备唤出开发菜单。\n\n* 禁用开发菜单\n\n在打包提交市场前，需要禁用开发菜单。禁用开发菜单方法如下：\n打开工程，选择`Product → Scheme → Edit Scheme`或使用快捷键“Command + <”,在弹出的窗口中选择左边的Run菜单项。更改“Build Configuration” 设置项为“Release”。\n![](http://ww1.sinaimg.cn/large/7f266405jw1f06e3sf5qjj21ds0s0tc2.jpg)\n\n#### 三、参考资料地址：\n\n* <a href=\"https://facebook.github.io/react-native/docs/tutorial.html\">React Native开发指南英文版（官方）</a>\n* <a href=\"http://reactnative.cn/docs/getting-started.html#content\">React Native开发指南中文版</a>\n* <a href=\"http://www.cnblogs.com/meteoric_cry/p/4862314.html\">React Native入门遇到的一些问题</a>\n\n**此文仅供学习交流，转载请注明出处！**\n","source":"_posts/2016-01-21-react-native-ios-kai-fa-huan-jing-da-jian.markdown","raw":"---\nlayout: post\ntitle: \"React Native iOS 开发环境搭建\"\ndate: 2016-01-21 01:07:09 +0800\ncomments: true\ntags: [iOS, React Native, Node.js, Hybrid, Xcode]\nkeywords: React Native, Hybrid, iOS, Xcode\ncategories: Others\n---\n#### 一、React Native基础环境搭建\n\n1、安装<a href=\"http://brew.sh\">Homebrew</a>\n\n打开终端输入：\n`\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n`\n<!--more-->\n2、安装<a href=\"https://github.com/creationix/nvm#installation\">nvm</a>方法\n\n通过脚本安装方式，在终端执行：\n`\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.1/install.sh | bash\n`\n\n激活nvm,在安装脚本执行完之后，在终端执行:\n`\n. ~/.nvm/nvm.sh\n`\n\nnvm其他安装方式详见<a href=\"https://github.com/creationix/nvm#installation\">安装向导</a>\n\n3、默认安装最新版本的Node.js并且设置好命令行的环境变量\n`\nnvm install node && nvm alias default node\n`\n\n可以输入node命令启动Node.js环境，npm(node package manager)文档传送门:<a href=\"https://docs.npmjs.com\">\"点击此处\"</a>\n\n4、安装watchman\n\n在终端输入：\n`\nbrew install watchman\n`\n\n到此处React Native基础环境搭建基本完成，推荐经常运行`brew update && brew upgrade`命令保持你的程序是最新的。\n\n#### 二、iOS开发环境\n\n1、iOS开发环境：（默认读者已经安装**Xcode7.0或以上版本**，没有可自行前往AppStore下载）\n\n* 使用npm（node包管理工具）安装react-native-cli(此处应注意权限问题，如果遇到权限问题，请在下面的命令前加上sudo)\n\n`\nnpm install -g react-native-cli\n`\n\n* 初始化工程（下面的语句中千万不要加sudo，后果自负）\n\n`\nreact-native init ReactNativeProject（工程名）\n`\n\n在初始化的过程中，如果进度缓慢，推荐你将npm仓库源换成国内镜像：(翻墙用户请忽略)\n在终端输入：\n\n```\nnpm config set registry https://registry.npm.taobao.org\nnpm config set disturl https://npm.taobao.org/dist\n```\n\n2、使用Xcode运行调试程序\n\n* 查找ReactNativeProject文件目录\n\n按住快捷键`Command+Shift+G`，在弹出的“前往文件夹”对话框中输入路径`/Users/yangshebing/ReactNativeProject`（yangshebing表示电脑用户名，请自行更改）,点击前往。在文件目中的ios文件夹下找到“ReactNativeProject.xcodeproj”工程文件。如图所示：（有关终端查找该文件目录方法，请自行到文章末尾的参考文章中寻找）\n![](http://ww4.sinaimg.cn/large/7f266405jw1f0651k88wij216s0oa42t.jpg)\n\n* 运行ReactNativeProject工程\n\n使用Xcode打开“ReactNativeProject.xcodeproj”工程文件，按住快捷键\"Command+R\"运行此项目，运行成功后便可在模拟器上看到效果。\n\n* 编辑index.ios.js文件修改界面\n\n笔者编辑index.ios.js文件工具是Vim，每当编辑完index.ios.js文件并保存之后，在模拟器(Simulator)中，按`Command+R`可刷新界面查看改变后的效果。\n\n下面我们也试着稍微修改一下index.ios.js文件：\n\n```\n/**\n * Sample React Native App\n * https://github.com/facebook/react-native\n */\n'use strict';\nimport React, {\n  AppRegistry,\n  Component,\n  StyleSheet,\n  //添加Image全局变量\n  Image,\n  Text,\n  View\n} from 'react-native';\n\nclass ReactNativeProject extends Component {\n  render() {\n    return (\n      <View style={styles.container}>\n      //添加文本展示\n        <Text style={styles.welcome}>\n          美女\n        </Text>\n        //添加图片展示\n        <Image \n        source={{uri: 'http://h.hiphotos.baidu.com/image/pic/item/6609c93d70cf3bc7f0f5b7eed300baa1cd112a3e.jpg'}} \n        //这里需要指定图片的大小\n        style={styles.picture} />\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: '#F5FCFF',\n  },\n  //这里可以设置文本的字体，对齐方式等\n  welcome: {\n    fontSize: 20,\n    textAlign: 'center',\n    margin: 10,\n  },\n  //新增图片style，设置图片大小\n  picture: {\n    width: 80,\n    height: 150,\n  },\n});\n\nAppRegistry.registerComponent('ReactNativeProject', () => ReactNativeProject);\n```\n刷新后运行效果如下图所示：\n![](http://ww3.sinaimg.cn/mw690/7f266405jw1f06flkcxxgj20ku12a3zr.jpg)\n\n* 真机运行调试项目\n\n在`ReactNativeProject`工程中找到AppDelegate.m文件，将`localhost`替换成自己电脑的IP地址。\n\n```\n//  jsCodeLocation = [NSURL URLWithString:@\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\"];\n\n  jsCodeLocation = [NSURL URLWithString:@\"http://192.168.31.168:8081/index.ios.bundle?platform=ios&dev=true\"];\n```\n\n替换完成之后再次运行程序，这个时候可以通过摇晃设备唤出开发菜单。\n\n* 禁用开发菜单\n\n在打包提交市场前，需要禁用开发菜单。禁用开发菜单方法如下：\n打开工程，选择`Product → Scheme → Edit Scheme`或使用快捷键“Command + <”,在弹出的窗口中选择左边的Run菜单项。更改“Build Configuration” 设置项为“Release”。\n![](http://ww1.sinaimg.cn/large/7f266405jw1f06e3sf5qjj21ds0s0tc2.jpg)\n\n#### 三、参考资料地址：\n\n* <a href=\"https://facebook.github.io/react-native/docs/tutorial.html\">React Native开发指南英文版（官方）</a>\n* <a href=\"http://reactnative.cn/docs/getting-started.html#content\">React Native开发指南中文版</a>\n* <a href=\"http://www.cnblogs.com/meteoric_cry/p/4862314.html\">React Native入门遇到的一些问题</a>\n\n**此文仅供学习交流，转载请注明出处！**\n","slug":"react-native-ios-kai-fa-huan-jing-da-jian","published":1,"updated":"2016-09-10T05:17:57.000Z","_id":"ciswie9dx0010e3u283e71vtt","photos":[],"link":"","content":"<h4 id=\"一、React-Native基础环境搭建\"><a href=\"#一、React-Native基础环境搭建\" class=\"headerlink\" title=\"一、React Native基础环境搭建\"></a>一、React Native基础环境搭建</h4><p>1、安装<a href=\"http://brew.sh\" target=\"_blank\" rel=\"external\">Homebrew</a></p>\n<p>打开终端输入：<br><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code><br><a id=\"more\"></a><br>2、安装<a href=\"https://github.com/creationix/nvm#installation\" target=\"_blank\" rel=\"external\">nvm</a>方法</p>\n<p>通过脚本安装方式，在终端执行：<br><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.1/install.sh | bash</code></p>\n<p>激活nvm,在安装脚本执行完之后，在终端执行:<br><code>. ~/.nvm/nvm.sh</code></p>\n<p>nvm其他安装方式详见<a href=\"https://github.com/creationix/nvm#installation\" target=\"_blank\" rel=\"external\">安装向导</a></p>\n<p>3、默认安装最新版本的Node.js并且设置好命令行的环境变量<br><code>nvm install node &amp;&amp; nvm alias default node</code></p>\n<p>可以输入node命令启动Node.js环境，npm(node package manager)文档传送门:<a href=\"https://docs.npmjs.com\" target=\"_blank\" rel=\"external\">“点击此处”</a></p>\n<p>4、安装watchman</p>\n<p>在终端输入：<br><code>brew install watchman</code></p>\n<p>到此处React Native基础环境搭建基本完成，推荐经常运行<code>brew update &amp;&amp; brew upgrade</code>命令保持你的程序是最新的。</p>\n<h4 id=\"二、iOS开发环境\"><a href=\"#二、iOS开发环境\" class=\"headerlink\" title=\"二、iOS开发环境\"></a>二、iOS开发环境</h4><p>1、iOS开发环境：（默认读者已经安装<strong>Xcode7.0或以上版本</strong>，没有可自行前往AppStore下载）</p>\n<ul>\n<li>使用npm（node包管理工具）安装react-native-cli(此处应注意权限问题，如果遇到权限问题，请在下面的命令前加上sudo)</li>\n</ul>\n<p><code>npm install -g react-native-cli</code></p>\n<ul>\n<li>初始化工程（下面的语句中千万不要加sudo，后果自负）</li>\n</ul>\n<p><code>react-native init ReactNativeProject（工程名）</code></p>\n<p>在初始化的过程中，如果进度缓慢，推荐你将npm仓库源换成国内镜像：(翻墙用户请忽略)<br>在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm config set registry https://registry.npm.taobao.org</div><div class=\"line\">npm config set disturl https://npm.taobao.org/dist</div></pre></td></tr></table></figure>\n<p>2、使用Xcode运行调试程序</p>\n<ul>\n<li>查找ReactNativeProject文件目录</li>\n</ul>\n<p>按住快捷键<code>Command+Shift+G</code>，在弹出的“前往文件夹”对话框中输入路径<code>/Users/yangshebing/ReactNativeProject</code>（yangshebing表示电脑用户名，请自行更改）,点击前往。在文件目中的ios文件夹下找到“ReactNativeProject.xcodeproj”工程文件。如图所示：（有关终端查找该文件目录方法，请自行到文章末尾的参考文章中寻找）<br><img src=\"http://ww4.sinaimg.cn/large/7f266405jw1f0651k88wij216s0oa42t.jpg\" alt=\"\"></p>\n<ul>\n<li>运行ReactNativeProject工程</li>\n</ul>\n<p>使用Xcode打开“ReactNativeProject.xcodeproj”工程文件，按住快捷键”Command+R”运行此项目，运行成功后便可在模拟器上看到效果。</p>\n<ul>\n<li>编辑index.ios.js文件修改界面</li>\n</ul>\n<p>笔者编辑index.ios.js文件工具是Vim，每当编辑完index.ios.js文件并保存之后，在模拟器(Simulator)中，按<code>Command+R</code>可刷新界面查看改变后的效果。</p>\n<p>下面我们也试着稍微修改一下index.ios.js文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Sample React Native App</div><div class=\"line\"> * https://github.com/facebook/react-native</div><div class=\"line\"> */</div><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">import React, &#123;</div><div class=\"line\">  AppRegistry,</div><div class=\"line\">  Component,</div><div class=\"line\">  StyleSheet,</div><div class=\"line\">  //添加Image全局变量</div><div class=\"line\">  Image,</div><div class=\"line\">  Text,</div><div class=\"line\">  View</div><div class=\"line\">&#125; from &apos;react-native&apos;;</div><div class=\"line\"></div><div class=\"line\">class ReactNativeProject extends Component &#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class=\"line\">      //添加文本展示</div><div class=\"line\">        &lt;Text style=&#123;styles.welcome&#125;&gt;</div><div class=\"line\">          美女</div><div class=\"line\">        &lt;/Text&gt;</div><div class=\"line\">        //添加图片展示</div><div class=\"line\">        &lt;Image </div><div class=\"line\">        source=&#123;&#123;uri: &apos;http://h.hiphotos.baidu.com/image/pic/item/6609c93d70cf3bc7f0f5b7eed300baa1cd112a3e.jpg&apos;&#125;&#125; </div><div class=\"line\">        //这里需要指定图片的大小</div><div class=\"line\">        style=&#123;styles.picture&#125; /&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const styles = StyleSheet.create(&#123;</div><div class=\"line\">  container: &#123;</div><div class=\"line\">    flex: 1,</div><div class=\"line\">    justifyContent: &apos;center&apos;,</div><div class=\"line\">    alignItems: &apos;center&apos;,</div><div class=\"line\">    backgroundColor: &apos;#F5FCFF&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  //这里可以设置文本的字体，对齐方式等</div><div class=\"line\">  welcome: &#123;</div><div class=\"line\">    fontSize: 20,</div><div class=\"line\">    textAlign: &apos;center&apos;,</div><div class=\"line\">    margin: 10,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  //新增图片style，设置图片大小</div><div class=\"line\">  picture: &#123;</div><div class=\"line\">    width: 80,</div><div class=\"line\">    height: 150,</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">AppRegistry.registerComponent(&apos;ReactNativeProject&apos;, () =&gt; ReactNativeProject);</div></pre></td></tr></table></figure>\n<p>刷新后运行效果如下图所示：<br><img src=\"http://ww3.sinaimg.cn/mw690/7f266405jw1f06flkcxxgj20ku12a3zr.jpg\" alt=\"\"></p>\n<ul>\n<li>真机运行调试项目</li>\n</ul>\n<p>在<code>ReactNativeProject</code>工程中找到AppDelegate.m文件，将<code>localhost</code>替换成自己电脑的IP地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//  jsCodeLocation = [NSURL URLWithString:@&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;];</div><div class=\"line\"></div><div class=\"line\">  jsCodeLocation = [NSURL URLWithString:@&quot;http://192.168.31.168:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;];</div></pre></td></tr></table></figure>\n<p>替换完成之后再次运行程序，这个时候可以通过摇晃设备唤出开发菜单。</p>\n<ul>\n<li>禁用开发菜单</li>\n</ul>\n<p>在打包提交市场前，需要禁用开发菜单。禁用开发菜单方法如下：<br>打开工程，选择<code>Product → Scheme → Edit Scheme</code>或使用快捷键“Command + &lt;”,在弹出的窗口中选择左边的Run菜单项。更改“Build Configuration” 设置项为“Release”。<br><img src=\"http://ww1.sinaimg.cn/large/7f266405jw1f06e3sf5qjj21ds0s0tc2.jpg\" alt=\"\"></p>\n<h4 id=\"三、参考资料地址：\"><a href=\"#三、参考资料地址：\" class=\"headerlink\" title=\"三、参考资料地址：\"></a>三、参考资料地址：</h4><ul>\n<li><a href=\"https://facebook.github.io/react-native/docs/tutorial.html\" target=\"_blank\" rel=\"external\">React Native开发指南英文版（官方）</a></li>\n<li><a href=\"http://reactnative.cn/docs/getting-started.html#content\" target=\"_blank\" rel=\"external\">React Native开发指南中文版</a></li>\n<li><a href=\"http://www.cnblogs.com/meteoric_cry/p/4862314.html\" target=\"_blank\" rel=\"external\">React Native入门遇到的一些问题</a></li>\n</ul>\n<p><strong>此文仅供学习交流，转载请注明出处！</strong></p>\n","excerpt":"<h4 id=\"一、React-Native基础环境搭建\"><a href=\"#一、React-Native基础环境搭建\" class=\"headerlink\" title=\"一、React Native基础环境搭建\"></a>一、React Native基础环境搭建</h4><p>1、安装<a href=\"http://brew.sh\">Homebrew</a></p>\n<p>打开终端输入：<br><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code><br>","more":"<br>2、安装<a href=\"https://github.com/creationix/nvm#installation\">nvm</a>方法</p>\n<p>通过脚本安装方式，在终端执行：<br><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.1/install.sh | bash</code></p>\n<p>激活nvm,在安装脚本执行完之后，在终端执行:<br><code>. ~/.nvm/nvm.sh</code></p>\n<p>nvm其他安装方式详见<a href=\"https://github.com/creationix/nvm#installation\">安装向导</a></p>\n<p>3、默认安装最新版本的Node.js并且设置好命令行的环境变量<br><code>nvm install node &amp;&amp; nvm alias default node</code></p>\n<p>可以输入node命令启动Node.js环境，npm(node package manager)文档传送门:<a href=\"https://docs.npmjs.com\">“点击此处”</a></p>\n<p>4、安装watchman</p>\n<p>在终端输入：<br><code>brew install watchman</code></p>\n<p>到此处React Native基础环境搭建基本完成，推荐经常运行<code>brew update &amp;&amp; brew upgrade</code>命令保持你的程序是最新的。</p>\n<h4 id=\"二、iOS开发环境\"><a href=\"#二、iOS开发环境\" class=\"headerlink\" title=\"二、iOS开发环境\"></a>二、iOS开发环境</h4><p>1、iOS开发环境：（默认读者已经安装<strong>Xcode7.0或以上版本</strong>，没有可自行前往AppStore下载）</p>\n<ul>\n<li>使用npm（node包管理工具）安装react-native-cli(此处应注意权限问题，如果遇到权限问题，请在下面的命令前加上sudo)</li>\n</ul>\n<p><code>npm install -g react-native-cli</code></p>\n<ul>\n<li>初始化工程（下面的语句中千万不要加sudo，后果自负）</li>\n</ul>\n<p><code>react-native init ReactNativeProject（工程名）</code></p>\n<p>在初始化的过程中，如果进度缓慢，推荐你将npm仓库源换成国内镜像：(翻墙用户请忽略)<br>在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm config set registry https://registry.npm.taobao.org</div><div class=\"line\">npm config set disturl https://npm.taobao.org/dist</div></pre></td></tr></table></figure>\n<p>2、使用Xcode运行调试程序</p>\n<ul>\n<li>查找ReactNativeProject文件目录</li>\n</ul>\n<p>按住快捷键<code>Command+Shift+G</code>，在弹出的“前往文件夹”对话框中输入路径<code>/Users/yangshebing/ReactNativeProject</code>（yangshebing表示电脑用户名，请自行更改）,点击前往。在文件目中的ios文件夹下找到“ReactNativeProject.xcodeproj”工程文件。如图所示：（有关终端查找该文件目录方法，请自行到文章末尾的参考文章中寻找）<br><img src=\"http://ww4.sinaimg.cn/large/7f266405jw1f0651k88wij216s0oa42t.jpg\" alt=\"\"></p>\n<ul>\n<li>运行ReactNativeProject工程</li>\n</ul>\n<p>使用Xcode打开“ReactNativeProject.xcodeproj”工程文件，按住快捷键”Command+R”运行此项目，运行成功后便可在模拟器上看到效果。</p>\n<ul>\n<li>编辑index.ios.js文件修改界面</li>\n</ul>\n<p>笔者编辑index.ios.js文件工具是Vim，每当编辑完index.ios.js文件并保存之后，在模拟器(Simulator)中，按<code>Command+R</code>可刷新界面查看改变后的效果。</p>\n<p>下面我们也试着稍微修改一下index.ios.js文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Sample React Native App</div><div class=\"line\"> * https://github.com/facebook/react-native</div><div class=\"line\"> */</div><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">import React, &#123;</div><div class=\"line\">  AppRegistry,</div><div class=\"line\">  Component,</div><div class=\"line\">  StyleSheet,</div><div class=\"line\">  //添加Image全局变量</div><div class=\"line\">  Image,</div><div class=\"line\">  Text,</div><div class=\"line\">  View</div><div class=\"line\">&#125; from &apos;react-native&apos;;</div><div class=\"line\"></div><div class=\"line\">class ReactNativeProject extends Component &#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;View style=&#123;styles.container&#125;&gt;</div><div class=\"line\">      //添加文本展示</div><div class=\"line\">        &lt;Text style=&#123;styles.welcome&#125;&gt;</div><div class=\"line\">          美女</div><div class=\"line\">        &lt;/Text&gt;</div><div class=\"line\">        //添加图片展示</div><div class=\"line\">        &lt;Image </div><div class=\"line\">        source=&#123;&#123;uri: &apos;http://h.hiphotos.baidu.com/image/pic/item/6609c93d70cf3bc7f0f5b7eed300baa1cd112a3e.jpg&apos;&#125;&#125; </div><div class=\"line\">        //这里需要指定图片的大小</div><div class=\"line\">        style=&#123;styles.picture&#125; /&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const styles = StyleSheet.create(&#123;</div><div class=\"line\">  container: &#123;</div><div class=\"line\">    flex: 1,</div><div class=\"line\">    justifyContent: &apos;center&apos;,</div><div class=\"line\">    alignItems: &apos;center&apos;,</div><div class=\"line\">    backgroundColor: &apos;#F5FCFF&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  //这里可以设置文本的字体，对齐方式等</div><div class=\"line\">  welcome: &#123;</div><div class=\"line\">    fontSize: 20,</div><div class=\"line\">    textAlign: &apos;center&apos;,</div><div class=\"line\">    margin: 10,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  //新增图片style，设置图片大小</div><div class=\"line\">  picture: &#123;</div><div class=\"line\">    width: 80,</div><div class=\"line\">    height: 150,</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">AppRegistry.registerComponent(&apos;ReactNativeProject&apos;, () =&gt; ReactNativeProject);</div></pre></td></tr></table></figure>\n<p>刷新后运行效果如下图所示：<br><img src=\"http://ww3.sinaimg.cn/mw690/7f266405jw1f06flkcxxgj20ku12a3zr.jpg\" alt=\"\"></p>\n<ul>\n<li>真机运行调试项目</li>\n</ul>\n<p>在<code>ReactNativeProject</code>工程中找到AppDelegate.m文件，将<code>localhost</code>替换成自己电脑的IP地址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//  jsCodeLocation = [NSURL URLWithString:@&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;];</div><div class=\"line\"></div><div class=\"line\">  jsCodeLocation = [NSURL URLWithString:@&quot;http://192.168.31.168:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;];</div></pre></td></tr></table></figure>\n<p>替换完成之后再次运行程序，这个时候可以通过摇晃设备唤出开发菜单。</p>\n<ul>\n<li>禁用开发菜单</li>\n</ul>\n<p>在打包提交市场前，需要禁用开发菜单。禁用开发菜单方法如下：<br>打开工程，选择<code>Product → Scheme → Edit Scheme</code>或使用快捷键“Command + &lt;”,在弹出的窗口中选择左边的Run菜单项。更改“Build Configuration” 设置项为“Release”。<br><img src=\"http://ww1.sinaimg.cn/large/7f266405jw1f06e3sf5qjj21ds0s0tc2.jpg\" alt=\"\"></p>\n<h4 id=\"三、参考资料地址：\"><a href=\"#三、参考资料地址：\" class=\"headerlink\" title=\"三、参考资料地址：\"></a>三、参考资料地址：</h4><ul>\n<li><a href=\"https://facebook.github.io/react-native/docs/tutorial.html\">React Native开发指南英文版（官方）</a></li>\n<li><a href=\"http://reactnative.cn/docs/getting-started.html#content\">React Native开发指南中文版</a></li>\n<li><a href=\"http://www.cnblogs.com/meteoric_cry/p/4862314.html\">React Native入门遇到的一些问题</a></li>\n</ul>\n<p><strong>此文仅供学习交流，转载请注明出处！</strong></p>"},{"layout":"post","title":"iOS图形绘制CoreGraphics篇","date":"2016-05-14T13:57:43.000Z","comments":1,"keywords":"CoreGraphics, Quartz2D, 绘制图形","_content":"\n#### 1、绘制直线\n\n```\n\n//获取当前上下文\n    CGContextRef contextRef = UIGraphicsGetCurrentContext();\n    UIColor *color = [UIColor colorWithRed:0.5 green:0.35 blue:0.8 alpha:0.7];\n    //设置线条颜色\n//    CGContextSetStrokeColor(contextRef, CGColorGetComponents([UIColor redColor].CGColor));\n    //官方推荐首选这个API\n    CGContextSetStrokeColorWithColor(contextRef, [UIColor redColor].CGColor);\n    //设置线条颜色\n    CGContextSetLineWidth(contextRef, 5);\n    //设置线条端点(不带端点)\n    CGContextSetLineCap(contextRef, kCGLineCapButt);\n    //设置线条绘制的起始坐标点\n    CGContextMoveToPoint(contextRef, 50, 20);\n    //结束点\n    CGContextAddLineToPoint(contextRef, 100, 20);\n    //绘制线条路径\n    CGContextStrokePath(contextRef);\n    \n```\n<!--more-->\n**这里插播一个从指定UIColor对象中获取RGB值得方式，上面设置线条颜色方法：CGContextSetStrokeColor第二个参数有用到。**\n\n```\n\n    //它是返回一个存储RGB与Alpha值得数组\n    const CGFloat *componets =  CGColorGetComponents(color.CGColor);\n    CGFloat r,g,b,a;\n    //R值\n    r = componets[0];\n    //G值\n    g = componets[1];\n    //B值\n    b = componets[2];\n    //Alpha值\n    a = componets[3];\n\n    \n\n```\n\n**不信，此处看客可以打印RGB、Alpha值试试！**\n\n#### 2、绘制矩形\n\n```\n  //设置线条颜色\n    CGContextSetStrokeColorWithColor(contextRef, [UIColor blueColor].CGColor);\n    CGContextSetLineWidth(contextRef, 2);\n    //绘制矩形边框\n    CGContextStrokeRect(contextRef, CGRectMake(50, 30, 80, 80));\n//    CGContextSetFillColor(contextRef, CGColorGetComponents([UIColor cyanColor].CGColor));\n    //绘制实心矩形\n    CGContextSetFillColorWithColor(contextRef, [UIColor cyanColor].CGColor);\n    CGContextFillRect(contextRef, CGRectMake(50, 120, 80, 80));\n\n    //绘制带边框的矩形\n    CGContextSetStrokeColorWithColor(contextRef, [UIColor brownColor].CGColor);\n    CGContextSetFillColorWithColor(contextRef, [UIColor magentaColor].CGColor);\n    CGContextSetLineWidth(contextRef, 2);\n    CGContextAddRect(contextRef, CGRectMake(50, 210, 80, 80));\n    \n    //绘制路径方式：\n    /*CGPathDrawingMode:\n     *kCGPathFill,  //用非零绕数规则填充（什么鬼？）\n     *kCGPathEOFill,    //用奇偶规则填充不带边框\n     *kCGPathStroke,    //描线\n     *kCGPathFillStroke,    //描线填充\n     *kCGPathEOFillStroke   //奇偶填充带边框\n     */\n    CGContextDrawPath(contextRef, kCGPathFillStroke);\n    \n    \n```\n\n **这里介绍一下设置线型为虚线的方式（虚线绘制方式）**\n \n\n```\n\n/*\n*phase:    虚线开始部分绘制大小\n*const CGFloat *lengths:   虚线排列的大小规则数组，数组的值用来指定绘制与未绘制部分的长度（间隔）\n*例如{2，3}指交替绘制2个单元长度的线段与3个单元长度未绘制长度线段（间隙）\n*例子示意图：      --   --   --   --   --   --\n*{1，3，4，2}绘制一个单元长度线段，间隔3个单元长度空隙，接着绘制4个长度的线段，间隔2个单元长度的空隙\n*例子示意图：      -   ----  -   ----  -   ----  -   ----  -\n*size_t count: 虚线排列数组中参数值有用个数\n*/\n \nconst CGFloat spaceArr[] = {6, 4, 5, 7};\nCGContextSetLineDash(contextRef, 0, spaceArr, 4);\n\n```\n\n \n#### 3、绘制贝塞尔曲线\n \n \n```\n \nCGContextSetStrokeColorWithColor(contextRef, [UIColor redColor].CGColor);\nCGContextSetFillColorWithColor(contextRef, [UIColor grayColor].CGColor);\nCGContextSetLineWidth(contextRef, 1);\nCGContextMoveToPoint(contextRef, 50, 300);\n//添加三个point坐标。绘制一条曲线。\n//CGContextAddCurveToPoint(contextRef, 100, 320, 150, 300, 200, 360);\n//添加二次曲线\nCGContextAddQuadCurveToPoint(contextRef, 250, 380, 290, 280);\nCGContextDrawPath(contextRef, kCGPathStroke);\n \n \n```\n \n \n#### 4、绘制圆弧\n \n```\n\nCGContextAddArc(contextRef, 50, 390, 20.0, -10 * M_PI / 180, 60 * M_PI / 180, YES);\nCGContextDrawPath(contextRef, kCGPathStroke);\n\n\n```\n\n\n#### 5、绘制圆形\n\n\n```\n\n//绘制圆形:方式一\nCGContextSetStrokeColorWithColor(contextRef, [UIColor blueColor].CGColor);\nCGContextSetFillColorWithColor(contextRef, [UIColor redColor].CGColor);\nCGContextAddArc(contextRef, 50, 480, 20.0, -180 * M_PI / 180, 180 * M_PI / 180, NO);\nCGContextDrawPath(contextRef, kCGPathFillStroke);\n//绘制圆形：方式二\nCGContextAddEllipseInRect(contextRef, CGRectMake(0, 500, 80, 80));\nCGContextDrawPath(contextRef, kCGPathFillStroke);\n    \n    \n```\n  \n    \n#### 6、绘制多边型（六边形）\n\n```\n\n//绘制多边形\nCGContextMoveToPoint(contextRef, 180, 500);\nCGContextAddLineToPoint(contextRef, 100, 550);\nCGContextAddLineToPoint(contextRef, 180, 600);\nCGContextAddLineToPoint(contextRef, 260, 600);\nCGContextAddLineToPoint(contextRef, 340, 550);\nCGContextAddLineToPoint(contextRef, 260, 500);\nCGContextAddLineToPoint(contextRef, 180, 500);\nCGContextDrawPath(contextRef, kCGPathFillStroke);\n//最后关闭它！\nCGContextClosePath(contextRef);\n\n```\n \n**这里就不演示绘制图表了，其实过程都差不多，只是换一种绘制方法而已！\n关于简单的图表绘制请参考上一篇，详细请点击：<a href=\"http://yangshebing.github.io/blog/2016/05/14/iostu-xing-hui-zhi-uibezierpathpian/\">iOS图形绘制UIBezierPath篇</a>**\n\n**文中代码效果图：**\n\n![](http://ww1.sinaimg.cn/mw690/7f266405jw1f3va3hd4i9j20ku12aq57.jpg)\n**不要问我为什么画的这么丑，因为我是粗糙的程序员！随性**\n\n#### 参考博客地址： \n* <a href = \"http://ghui.me/post/2016/04/ios-core-graphics/\">iOS绘图之用Core Graphics框架绘制常见图形（这篇是用Swift语言写的）</a>\n\n转载请注明出处\n\n    \n    ","source":"_posts/2016-05-14-iostu-xing-hui-zhi-coregraphicspian.markdown","raw":"---\nlayout: post\ntitle: \"iOS图形绘制CoreGraphics篇\"\ndate: 2016-05-14 21:57:43 +0800\ncomments: true\ntags: [iOS9, Xcode7.3, Xcode, CoreGraphics, Quartz2D]\nkeywords: CoreGraphics, Quartz2D, 绘制图形\ncategories: Objective-C\n---\n\n#### 1、绘制直线\n\n```\n\n//获取当前上下文\n    CGContextRef contextRef = UIGraphicsGetCurrentContext();\n    UIColor *color = [UIColor colorWithRed:0.5 green:0.35 blue:0.8 alpha:0.7];\n    //设置线条颜色\n//    CGContextSetStrokeColor(contextRef, CGColorGetComponents([UIColor redColor].CGColor));\n    //官方推荐首选这个API\n    CGContextSetStrokeColorWithColor(contextRef, [UIColor redColor].CGColor);\n    //设置线条颜色\n    CGContextSetLineWidth(contextRef, 5);\n    //设置线条端点(不带端点)\n    CGContextSetLineCap(contextRef, kCGLineCapButt);\n    //设置线条绘制的起始坐标点\n    CGContextMoveToPoint(contextRef, 50, 20);\n    //结束点\n    CGContextAddLineToPoint(contextRef, 100, 20);\n    //绘制线条路径\n    CGContextStrokePath(contextRef);\n    \n```\n<!--more-->\n**这里插播一个从指定UIColor对象中获取RGB值得方式，上面设置线条颜色方法：CGContextSetStrokeColor第二个参数有用到。**\n\n```\n\n    //它是返回一个存储RGB与Alpha值得数组\n    const CGFloat *componets =  CGColorGetComponents(color.CGColor);\n    CGFloat r,g,b,a;\n    //R值\n    r = componets[0];\n    //G值\n    g = componets[1];\n    //B值\n    b = componets[2];\n    //Alpha值\n    a = componets[3];\n\n    \n\n```\n\n**不信，此处看客可以打印RGB、Alpha值试试！**\n\n#### 2、绘制矩形\n\n```\n  //设置线条颜色\n    CGContextSetStrokeColorWithColor(contextRef, [UIColor blueColor].CGColor);\n    CGContextSetLineWidth(contextRef, 2);\n    //绘制矩形边框\n    CGContextStrokeRect(contextRef, CGRectMake(50, 30, 80, 80));\n//    CGContextSetFillColor(contextRef, CGColorGetComponents([UIColor cyanColor].CGColor));\n    //绘制实心矩形\n    CGContextSetFillColorWithColor(contextRef, [UIColor cyanColor].CGColor);\n    CGContextFillRect(contextRef, CGRectMake(50, 120, 80, 80));\n\n    //绘制带边框的矩形\n    CGContextSetStrokeColorWithColor(contextRef, [UIColor brownColor].CGColor);\n    CGContextSetFillColorWithColor(contextRef, [UIColor magentaColor].CGColor);\n    CGContextSetLineWidth(contextRef, 2);\n    CGContextAddRect(contextRef, CGRectMake(50, 210, 80, 80));\n    \n    //绘制路径方式：\n    /*CGPathDrawingMode:\n     *kCGPathFill,  //用非零绕数规则填充（什么鬼？）\n     *kCGPathEOFill,    //用奇偶规则填充不带边框\n     *kCGPathStroke,    //描线\n     *kCGPathFillStroke,    //描线填充\n     *kCGPathEOFillStroke   //奇偶填充带边框\n     */\n    CGContextDrawPath(contextRef, kCGPathFillStroke);\n    \n    \n```\n\n **这里介绍一下设置线型为虚线的方式（虚线绘制方式）**\n \n\n```\n\n/*\n*phase:    虚线开始部分绘制大小\n*const CGFloat *lengths:   虚线排列的大小规则数组，数组的值用来指定绘制与未绘制部分的长度（间隔）\n*例如{2，3}指交替绘制2个单元长度的线段与3个单元长度未绘制长度线段（间隙）\n*例子示意图：      --   --   --   --   --   --\n*{1，3，4，2}绘制一个单元长度线段，间隔3个单元长度空隙，接着绘制4个长度的线段，间隔2个单元长度的空隙\n*例子示意图：      -   ----  -   ----  -   ----  -   ----  -\n*size_t count: 虚线排列数组中参数值有用个数\n*/\n \nconst CGFloat spaceArr[] = {6, 4, 5, 7};\nCGContextSetLineDash(contextRef, 0, spaceArr, 4);\n\n```\n\n \n#### 3、绘制贝塞尔曲线\n \n \n```\n \nCGContextSetStrokeColorWithColor(contextRef, [UIColor redColor].CGColor);\nCGContextSetFillColorWithColor(contextRef, [UIColor grayColor].CGColor);\nCGContextSetLineWidth(contextRef, 1);\nCGContextMoveToPoint(contextRef, 50, 300);\n//添加三个point坐标。绘制一条曲线。\n//CGContextAddCurveToPoint(contextRef, 100, 320, 150, 300, 200, 360);\n//添加二次曲线\nCGContextAddQuadCurveToPoint(contextRef, 250, 380, 290, 280);\nCGContextDrawPath(contextRef, kCGPathStroke);\n \n \n```\n \n \n#### 4、绘制圆弧\n \n```\n\nCGContextAddArc(contextRef, 50, 390, 20.0, -10 * M_PI / 180, 60 * M_PI / 180, YES);\nCGContextDrawPath(contextRef, kCGPathStroke);\n\n\n```\n\n\n#### 5、绘制圆形\n\n\n```\n\n//绘制圆形:方式一\nCGContextSetStrokeColorWithColor(contextRef, [UIColor blueColor].CGColor);\nCGContextSetFillColorWithColor(contextRef, [UIColor redColor].CGColor);\nCGContextAddArc(contextRef, 50, 480, 20.0, -180 * M_PI / 180, 180 * M_PI / 180, NO);\nCGContextDrawPath(contextRef, kCGPathFillStroke);\n//绘制圆形：方式二\nCGContextAddEllipseInRect(contextRef, CGRectMake(0, 500, 80, 80));\nCGContextDrawPath(contextRef, kCGPathFillStroke);\n    \n    \n```\n  \n    \n#### 6、绘制多边型（六边形）\n\n```\n\n//绘制多边形\nCGContextMoveToPoint(contextRef, 180, 500);\nCGContextAddLineToPoint(contextRef, 100, 550);\nCGContextAddLineToPoint(contextRef, 180, 600);\nCGContextAddLineToPoint(contextRef, 260, 600);\nCGContextAddLineToPoint(contextRef, 340, 550);\nCGContextAddLineToPoint(contextRef, 260, 500);\nCGContextAddLineToPoint(contextRef, 180, 500);\nCGContextDrawPath(contextRef, kCGPathFillStroke);\n//最后关闭它！\nCGContextClosePath(contextRef);\n\n```\n \n**这里就不演示绘制图表了，其实过程都差不多，只是换一种绘制方法而已！\n关于简单的图表绘制请参考上一篇，详细请点击：<a href=\"http://yangshebing.github.io/blog/2016/05/14/iostu-xing-hui-zhi-uibezierpathpian/\">iOS图形绘制UIBezierPath篇</a>**\n\n**文中代码效果图：**\n\n![](http://ww1.sinaimg.cn/mw690/7f266405jw1f3va3hd4i9j20ku12aq57.jpg)\n**不要问我为什么画的这么丑，因为我是粗糙的程序员！随性**\n\n#### 参考博客地址： \n* <a href = \"http://ghui.me/post/2016/04/ios-core-graphics/\">iOS绘图之用Core Graphics框架绘制常见图形（这篇是用Swift语言写的）</a>\n\n转载请注明出处\n\n    \n    ","slug":"iostu-xing-hui-zhi-coregraphicspian","published":1,"updated":"2016-09-10T05:15:53.000Z","_id":"ciswie9e00014e3u26om3dq7o","photos":[],"link":"","content":"<h4 id=\"1、绘制直线\"><a href=\"#1、绘制直线\" class=\"headerlink\" title=\"1、绘制直线\"></a>1、绘制直线</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//获取当前上下文</div><div class=\"line\">    CGContextRef contextRef = UIGraphicsGetCurrentContext();</div><div class=\"line\">    UIColor *color = [UIColor colorWithRed:0.5 green:0.35 blue:0.8 alpha:0.7];</div><div class=\"line\">    //设置线条颜色</div><div class=\"line\">//    CGContextSetStrokeColor(contextRef, CGColorGetComponents([UIColor redColor].CGColor));</div><div class=\"line\">    //官方推荐首选这个API</div><div class=\"line\">    CGContextSetStrokeColorWithColor(contextRef, [UIColor redColor].CGColor);</div><div class=\"line\">    //设置线条颜色</div><div class=\"line\">    CGContextSetLineWidth(contextRef, 5);</div><div class=\"line\">    //设置线条端点(不带端点)</div><div class=\"line\">    CGContextSetLineCap(contextRef, kCGLineCapButt);</div><div class=\"line\">    //设置线条绘制的起始坐标点</div><div class=\"line\">    CGContextMoveToPoint(contextRef, 50, 20);</div><div class=\"line\">    //结束点</div><div class=\"line\">    CGContextAddLineToPoint(contextRef, 100, 20);</div><div class=\"line\">    //绘制线条路径</div><div class=\"line\">    CGContextStrokePath(contextRef);</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p><strong>这里插播一个从指定UIColor对象中获取RGB值得方式，上面设置线条颜色方法：CGContextSetStrokeColor第二个参数有用到。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//它是返回一个存储RGB与Alpha值得数组</div><div class=\"line\">const CGFloat *componets =  CGColorGetComponents(color.CGColor);</div><div class=\"line\">CGFloat r,g,b,a;</div><div class=\"line\">//R值</div><div class=\"line\">r = componets[0];</div><div class=\"line\">//G值</div><div class=\"line\">g = componets[1];</div><div class=\"line\">//B值</div><div class=\"line\">b = componets[2];</div><div class=\"line\">//Alpha值</div><div class=\"line\">a = componets[3];</div></pre></td></tr></table></figure>\n<p><strong>不信，此处看客可以打印RGB、Alpha值试试！</strong></p>\n<h4 id=\"2、绘制矩形\"><a href=\"#2、绘制矩形\" class=\"headerlink\" title=\"2、绘制矩形\"></a>2、绘制矩形</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">  //设置线条颜色</div><div class=\"line\">    CGContextSetStrokeColorWithColor(contextRef, [UIColor blueColor].CGColor);</div><div class=\"line\">    CGContextSetLineWidth(contextRef, 2);</div><div class=\"line\">    //绘制矩形边框</div><div class=\"line\">    CGContextStrokeRect(contextRef, CGRectMake(50, 30, 80, 80));</div><div class=\"line\">//    CGContextSetFillColor(contextRef, CGColorGetComponents([UIColor cyanColor].CGColor));</div><div class=\"line\">    //绘制实心矩形</div><div class=\"line\">    CGContextSetFillColorWithColor(contextRef, [UIColor cyanColor].CGColor);</div><div class=\"line\">    CGContextFillRect(contextRef, CGRectMake(50, 120, 80, 80));</div><div class=\"line\"></div><div class=\"line\">    //绘制带边框的矩形</div><div class=\"line\">    CGContextSetStrokeColorWithColor(contextRef, [UIColor brownColor].CGColor);</div><div class=\"line\">    CGContextSetFillColorWithColor(contextRef, [UIColor magentaColor].CGColor);</div><div class=\"line\">    CGContextSetLineWidth(contextRef, 2);</div><div class=\"line\">    CGContextAddRect(contextRef, CGRectMake(50, 210, 80, 80));</div><div class=\"line\">    </div><div class=\"line\">    //绘制路径方式：</div><div class=\"line\">    /*CGPathDrawingMode:</div><div class=\"line\">     *kCGPathFill,  //用非零绕数规则填充（什么鬼？）</div><div class=\"line\">     *kCGPathEOFill,    //用奇偶规则填充不带边框</div><div class=\"line\">     *kCGPathStroke,    //描线</div><div class=\"line\">     *kCGPathFillStroke,    //描线填充</div><div class=\"line\">     *kCGPathEOFillStroke   //奇偶填充带边框</div><div class=\"line\">     */</div><div class=\"line\">    CGContextDrawPath(contextRef, kCGPathFillStroke);</div></pre></td></tr></table></figure>\n<p> <strong>这里介绍一下设置线型为虚线的方式（虚线绘制方式）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\">*phase:    虚线开始部分绘制大小</div><div class=\"line\">*const CGFloat *lengths:   虚线排列的大小规则数组，数组的值用来指定绘制与未绘制部分的长度（间隔）</div><div class=\"line\">*例如&#123;2，3&#125;指交替绘制2个单元长度的线段与3个单元长度未绘制长度线段（间隙）</div><div class=\"line\">*例子示意图：      --   --   --   --   --   --</div><div class=\"line\">*&#123;1，3，4，2&#125;绘制一个单元长度线段，间隔3个单元长度空隙，接着绘制4个长度的线段，间隔2个单元长度的空隙</div><div class=\"line\">*例子示意图：      -   ----  -   ----  -   ----  -   ----  -</div><div class=\"line\">*size_t count: 虚线排列数组中参数值有用个数</div><div class=\"line\">*/</div><div class=\"line\"> </div><div class=\"line\">const CGFloat spaceArr[] = &#123;6, 4, 5, 7&#125;;</div><div class=\"line\">CGContextSetLineDash(contextRef, 0, spaceArr, 4);</div></pre></td></tr></table></figure>\n<h4 id=\"3、绘制贝塞尔曲线\"><a href=\"#3、绘制贝塞尔曲线\" class=\"headerlink\" title=\"3、绘制贝塞尔曲线\"></a>3、绘制贝塞尔曲线</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> </div><div class=\"line\">CGContextSetStrokeColorWithColor(contextRef, [UIColor redColor].CGColor);</div><div class=\"line\">CGContextSetFillColorWithColor(contextRef, [UIColor grayColor].CGColor);</div><div class=\"line\">CGContextSetLineWidth(contextRef, 1);</div><div class=\"line\">CGContextMoveToPoint(contextRef, 50, 300);</div><div class=\"line\">//添加三个point坐标。绘制一条曲线。</div><div class=\"line\">//CGContextAddCurveToPoint(contextRef, 100, 320, 150, 300, 200, 360);</div><div class=\"line\">//添加二次曲线</div><div class=\"line\">CGContextAddQuadCurveToPoint(contextRef, 250, 380, 290, 280);</div><div class=\"line\">CGContextDrawPath(contextRef, kCGPathStroke);</div></pre></td></tr></table></figure>\n<h4 id=\"4、绘制圆弧\"><a href=\"#4、绘制圆弧\" class=\"headerlink\" title=\"4、绘制圆弧\"></a>4、绘制圆弧</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">CGContextAddArc(contextRef, 50, 390, 20.0, -10 * M_PI / 180, 60 * M_PI / 180, YES);</div><div class=\"line\">CGContextDrawPath(contextRef, kCGPathStroke);</div></pre></td></tr></table></figure>\n<h4 id=\"5、绘制圆形\"><a href=\"#5、绘制圆形\" class=\"headerlink\" title=\"5、绘制圆形\"></a>5、绘制圆形</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//绘制圆形:方式一</div><div class=\"line\">CGContextSetStrokeColorWithColor(contextRef, [UIColor blueColor].CGColor);</div><div class=\"line\">CGContextSetFillColorWithColor(contextRef, [UIColor redColor].CGColor);</div><div class=\"line\">CGContextAddArc(contextRef, 50, 480, 20.0, -180 * M_PI / 180, 180 * M_PI / 180, NO);</div><div class=\"line\">CGContextDrawPath(contextRef, kCGPathFillStroke);</div><div class=\"line\">//绘制圆形：方式二</div><div class=\"line\">CGContextAddEllipseInRect(contextRef, CGRectMake(0, 500, 80, 80));</div><div class=\"line\">CGContextDrawPath(contextRef, kCGPathFillStroke);</div></pre></td></tr></table></figure>\n<h4 id=\"6、绘制多边型（六边形）\"><a href=\"#6、绘制多边型（六边形）\" class=\"headerlink\" title=\"6、绘制多边型（六边形）\"></a>6、绘制多边型（六边形）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//绘制多边形</div><div class=\"line\">CGContextMoveToPoint(contextRef, 180, 500);</div><div class=\"line\">CGContextAddLineToPoint(contextRef, 100, 550);</div><div class=\"line\">CGContextAddLineToPoint(contextRef, 180, 600);</div><div class=\"line\">CGContextAddLineToPoint(contextRef, 260, 600);</div><div class=\"line\">CGContextAddLineToPoint(contextRef, 340, 550);</div><div class=\"line\">CGContextAddLineToPoint(contextRef, 260, 500);</div><div class=\"line\">CGContextAddLineToPoint(contextRef, 180, 500);</div><div class=\"line\">CGContextDrawPath(contextRef, kCGPathFillStroke);</div><div class=\"line\">//最后关闭它！</div><div class=\"line\">CGContextClosePath(contextRef);</div></pre></td></tr></table></figure>\n<p><strong>这里就不演示绘制图表了，其实过程都差不多，只是换一种绘制方法而已！<br>关于简单的图表绘制请参考上一篇，详细请点击：<a href=\"http://yangshebing.github.io/blog/2016/05/14/iostu-xing-hui-zhi-uibezierpathpian/\" target=\"_blank\" rel=\"external\">iOS图形绘制UIBezierPath篇</a></strong></p>\n<p><strong>文中代码效果图：</strong></p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/7f266405jw1f3va3hd4i9j20ku12aq57.jpg\" alt=\"\"><br><strong>不要问我为什么画的这么丑，因为我是粗糙的程序员！随性</strong></p>\n<h4 id=\"参考博客地址：\"><a href=\"#参考博客地址：\" class=\"headerlink\" title=\"参考博客地址：\"></a>参考博客地址：</h4><ul>\n<li><a href=\"http://ghui.me/post/2016/04/ios-core-graphics/\" target=\"_blank\" rel=\"external\">iOS绘图之用Core Graphics框架绘制常见图形（这篇是用Swift语言写的）</a></li>\n</ul>\n<p>转载请注明出处</p>\n","excerpt":"<h4 id=\"1、绘制直线\"><a href=\"#1、绘制直线\" class=\"headerlink\" title=\"1、绘制直线\"></a>1、绘制直线</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//获取当前上下文</div><div class=\"line\">    CGContextRef contextRef = UIGraphicsGetCurrentContext();</div><div class=\"line\">    UIColor *color = [UIColor colorWithRed:0.5 green:0.35 blue:0.8 alpha:0.7];</div><div class=\"line\">    //设置线条颜色</div><div class=\"line\">//    CGContextSetStrokeColor(contextRef, CGColorGetComponents([UIColor redColor].CGColor));</div><div class=\"line\">    //官方推荐首选这个API</div><div class=\"line\">    CGContextSetStrokeColorWithColor(contextRef, [UIColor redColor].CGColor);</div><div class=\"line\">    //设置线条颜色</div><div class=\"line\">    CGContextSetLineWidth(contextRef, 5);</div><div class=\"line\">    //设置线条端点(不带端点)</div><div class=\"line\">    CGContextSetLineCap(contextRef, kCGLineCapButt);</div><div class=\"line\">    //设置线条绘制的起始坐标点</div><div class=\"line\">    CGContextMoveToPoint(contextRef, 50, 20);</div><div class=\"line\">    //结束点</div><div class=\"line\">    CGContextAddLineToPoint(contextRef, 100, 20);</div><div class=\"line\">    //绘制线条路径</div><div class=\"line\">    CGContextStrokePath(contextRef);</div></pre></td></tr></table></figure>","more":"<p><strong>这里插播一个从指定UIColor对象中获取RGB值得方式，上面设置线条颜色方法：CGContextSetStrokeColor第二个参数有用到。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//它是返回一个存储RGB与Alpha值得数组</div><div class=\"line\">const CGFloat *componets =  CGColorGetComponents(color.CGColor);</div><div class=\"line\">CGFloat r,g,b,a;</div><div class=\"line\">//R值</div><div class=\"line\">r = componets[0];</div><div class=\"line\">//G值</div><div class=\"line\">g = componets[1];</div><div class=\"line\">//B值</div><div class=\"line\">b = componets[2];</div><div class=\"line\">//Alpha值</div><div class=\"line\">a = componets[3];</div></pre></td></tr></table></figure>\n<p><strong>不信，此处看客可以打印RGB、Alpha值试试！</strong></p>\n<h4 id=\"2、绘制矩形\"><a href=\"#2、绘制矩形\" class=\"headerlink\" title=\"2、绘制矩形\"></a>2、绘制矩形</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">  //设置线条颜色</div><div class=\"line\">    CGContextSetStrokeColorWithColor(contextRef, [UIColor blueColor].CGColor);</div><div class=\"line\">    CGContextSetLineWidth(contextRef, 2);</div><div class=\"line\">    //绘制矩形边框</div><div class=\"line\">    CGContextStrokeRect(contextRef, CGRectMake(50, 30, 80, 80));</div><div class=\"line\">//    CGContextSetFillColor(contextRef, CGColorGetComponents([UIColor cyanColor].CGColor));</div><div class=\"line\">    //绘制实心矩形</div><div class=\"line\">    CGContextSetFillColorWithColor(contextRef, [UIColor cyanColor].CGColor);</div><div class=\"line\">    CGContextFillRect(contextRef, CGRectMake(50, 120, 80, 80));</div><div class=\"line\"></div><div class=\"line\">    //绘制带边框的矩形</div><div class=\"line\">    CGContextSetStrokeColorWithColor(contextRef, [UIColor brownColor].CGColor);</div><div class=\"line\">    CGContextSetFillColorWithColor(contextRef, [UIColor magentaColor].CGColor);</div><div class=\"line\">    CGContextSetLineWidth(contextRef, 2);</div><div class=\"line\">    CGContextAddRect(contextRef, CGRectMake(50, 210, 80, 80));</div><div class=\"line\">    </div><div class=\"line\">    //绘制路径方式：</div><div class=\"line\">    /*CGPathDrawingMode:</div><div class=\"line\">     *kCGPathFill,  //用非零绕数规则填充（什么鬼？）</div><div class=\"line\">     *kCGPathEOFill,    //用奇偶规则填充不带边框</div><div class=\"line\">     *kCGPathStroke,    //描线</div><div class=\"line\">     *kCGPathFillStroke,    //描线填充</div><div class=\"line\">     *kCGPathEOFillStroke   //奇偶填充带边框</div><div class=\"line\">     */</div><div class=\"line\">    CGContextDrawPath(contextRef, kCGPathFillStroke);</div></pre></td></tr></table></figure>\n<p> <strong>这里介绍一下设置线型为虚线的方式（虚线绘制方式）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\">*phase:    虚线开始部分绘制大小</div><div class=\"line\">*const CGFloat *lengths:   虚线排列的大小规则数组，数组的值用来指定绘制与未绘制部分的长度（间隔）</div><div class=\"line\">*例如&#123;2，3&#125;指交替绘制2个单元长度的线段与3个单元长度未绘制长度线段（间隙）</div><div class=\"line\">*例子示意图：      --   --   --   --   --   --</div><div class=\"line\">*&#123;1，3，4，2&#125;绘制一个单元长度线段，间隔3个单元长度空隙，接着绘制4个长度的线段，间隔2个单元长度的空隙</div><div class=\"line\">*例子示意图：      -   ----  -   ----  -   ----  -   ----  -</div><div class=\"line\">*size_t count: 虚线排列数组中参数值有用个数</div><div class=\"line\">*/</div><div class=\"line\"> </div><div class=\"line\">const CGFloat spaceArr[] = &#123;6, 4, 5, 7&#125;;</div><div class=\"line\">CGContextSetLineDash(contextRef, 0, spaceArr, 4);</div></pre></td></tr></table></figure>\n<h4 id=\"3、绘制贝塞尔曲线\"><a href=\"#3、绘制贝塞尔曲线\" class=\"headerlink\" title=\"3、绘制贝塞尔曲线\"></a>3、绘制贝塞尔曲线</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> </div><div class=\"line\">CGContextSetStrokeColorWithColor(contextRef, [UIColor redColor].CGColor);</div><div class=\"line\">CGContextSetFillColorWithColor(contextRef, [UIColor grayColor].CGColor);</div><div class=\"line\">CGContextSetLineWidth(contextRef, 1);</div><div class=\"line\">CGContextMoveToPoint(contextRef, 50, 300);</div><div class=\"line\">//添加三个point坐标。绘制一条曲线。</div><div class=\"line\">//CGContextAddCurveToPoint(contextRef, 100, 320, 150, 300, 200, 360);</div><div class=\"line\">//添加二次曲线</div><div class=\"line\">CGContextAddQuadCurveToPoint(contextRef, 250, 380, 290, 280);</div><div class=\"line\">CGContextDrawPath(contextRef, kCGPathStroke);</div></pre></td></tr></table></figure>\n<h4 id=\"4、绘制圆弧\"><a href=\"#4、绘制圆弧\" class=\"headerlink\" title=\"4、绘制圆弧\"></a>4、绘制圆弧</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">CGContextAddArc(contextRef, 50, 390, 20.0, -10 * M_PI / 180, 60 * M_PI / 180, YES);</div><div class=\"line\">CGContextDrawPath(contextRef, kCGPathStroke);</div></pre></td></tr></table></figure>\n<h4 id=\"5、绘制圆形\"><a href=\"#5、绘制圆形\" class=\"headerlink\" title=\"5、绘制圆形\"></a>5、绘制圆形</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//绘制圆形:方式一</div><div class=\"line\">CGContextSetStrokeColorWithColor(contextRef, [UIColor blueColor].CGColor);</div><div class=\"line\">CGContextSetFillColorWithColor(contextRef, [UIColor redColor].CGColor);</div><div class=\"line\">CGContextAddArc(contextRef, 50, 480, 20.0, -180 * M_PI / 180, 180 * M_PI / 180, NO);</div><div class=\"line\">CGContextDrawPath(contextRef, kCGPathFillStroke);</div><div class=\"line\">//绘制圆形：方式二</div><div class=\"line\">CGContextAddEllipseInRect(contextRef, CGRectMake(0, 500, 80, 80));</div><div class=\"line\">CGContextDrawPath(contextRef, kCGPathFillStroke);</div></pre></td></tr></table></figure>\n<h4 id=\"6、绘制多边型（六边形）\"><a href=\"#6、绘制多边型（六边形）\" class=\"headerlink\" title=\"6、绘制多边型（六边形）\"></a>6、绘制多边型（六边形）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//绘制多边形</div><div class=\"line\">CGContextMoveToPoint(contextRef, 180, 500);</div><div class=\"line\">CGContextAddLineToPoint(contextRef, 100, 550);</div><div class=\"line\">CGContextAddLineToPoint(contextRef, 180, 600);</div><div class=\"line\">CGContextAddLineToPoint(contextRef, 260, 600);</div><div class=\"line\">CGContextAddLineToPoint(contextRef, 340, 550);</div><div class=\"line\">CGContextAddLineToPoint(contextRef, 260, 500);</div><div class=\"line\">CGContextAddLineToPoint(contextRef, 180, 500);</div><div class=\"line\">CGContextDrawPath(contextRef, kCGPathFillStroke);</div><div class=\"line\">//最后关闭它！</div><div class=\"line\">CGContextClosePath(contextRef);</div></pre></td></tr></table></figure>\n<p><strong>这里就不演示绘制图表了，其实过程都差不多，只是换一种绘制方法而已！<br>关于简单的图表绘制请参考上一篇，详细请点击：<a href=\"http://yangshebing.github.io/blog/2016/05/14/iostu-xing-hui-zhi-uibezierpathpian/\">iOS图形绘制UIBezierPath篇</a></strong></p>\n<p><strong>文中代码效果图：</strong></p>\n<p><img src=\"http://ww1.sinaimg.cn/mw690/7f266405jw1f3va3hd4i9j20ku12aq57.jpg\" alt=\"\"><br><strong>不要问我为什么画的这么丑，因为我是粗糙的程序员！随性</strong></p>\n<h4 id=\"参考博客地址：\"><a href=\"#参考博客地址：\" class=\"headerlink\" title=\"参考博客地址：\"></a>参考博客地址：</h4><ul>\n<li><a href = \"http://ghui.me/post/2016/04/ios-core-graphics/\">iOS绘图之用Core Graphics框架绘制常见图形（这篇是用Swift语言写的）</a></li>\n</ul>\n<p>转载请注明出处</p>"},{"layout":"post","title":"Swift2.2新特性","date":"2016-05-09T15:09:48.000Z","comments":1,"keywords":"Swift, Swift2.2, Swift2.2新特性","_content":"\n#### 1、编译期Swift版本检测\n\n```\n\n#if swift(>=3.0)\n    print(\"Running Swift 3.0 or later\")\n#else\n    print(\"Running Swift 2.2 or earlier\")\n#endif\n\n```\n\n它和Swift2中介绍过的`#available`表达式不同,#available表达式是运行时检查,`#if swift(>=3.0)... #else... #endif`是编译期检查。\n\n\n**一个警告:这个特性这次不可用,因为Swift2.1编译器并不知道`#if swift(>=2.2)`意味着什么。然而,一旦Swift3.0以及未来所有版本可用,Swift编译期版本检查将会是一个非常有用的工具。**\n<!--more-->\n\n#### 2、编译期选择器检查\n\n在Swift2.1,下面这段代码完全没有问题:\n\n```\n\noverride func viewDidLoad() {\n  super.viewDidLoad()\n  navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: \"addNewFireflyRefernce\")\n}\n\nfunc addNewFireflyReference() {\n   gratuitousReferences.append(\"We should start dealing in black-market beagles.\")\n}\n\n```\n\n\n上面这段代码在应用程序中会崩溃,因为导航栏按钮调用了一个方法`addNewFireflyRefernce`,方法名中的`Refrence`少了一个字母”e”.这类简单的单词拼写错误很容易造成bug,所以在Swift2.2中弃用了使用字符串作为选择器。使用新语法:`#selector`来取代它。\n\n使用`#selector`将会在编译期检查你的代码,确定你想调用的方法真实存在。甚至更好的是,如果方法不存在,你会得到一个编译错误。\n\n下面是通过`#selector`来重写之前的代码:\n\n```\noverride func viewDidLoad() {\n        super.viewDidLoad()\n        navigationItem.rightBarButtonItem =\n        UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: #selector(addNewFireflyReference))\n}\n\nfunc addNewFireflyReference() {\n  gratuitousReferences.append(\"Curse your sudden but inevitable betrayal!\")\n}\n\n```\n\n这里需要注意的:\n\nObjective-C Selectors(OC选择器)\n\n一个OC选择器是一种特指OC方法名的类型。在Swift里,OC选择器是通过Selector结构来表示的.你可以使用#selector表达式来构造一个选择器。例如`let mySelector = #selector(MyViewController.tappedButton)`,用一个直接引用一个OC方法作为子表达式。一个OC方法引用能被括号括起来,它能使用”as”操作符消除它与重载之间的歧义。例如`let anotherSelector = #selector(((UIView.insertSubview(_:at:)) as(UIView) ->(UIView, Int) ->Void))`。\n\n示例代码如下:为按钮添加事件\n\n```\n\nimport UIKit\nclass MyViewController: UIViewController {\n    let myButton = UIButton(frame: CGRect(x: 0, y: 0, width: 100, height: 50))\n\n    override init?(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) {\n        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)\n        let action = #selector(MyViewController.tappedButton)\n        myButton.addTarget(self, action: action, forControlEvents: .TouchUpInside)\n    }\n\n    func tappedButton(sender: UIButton!) {\n        print(\"tapped button\")\n    }\n\n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n    }\n}\n\n```\n\n<a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html\">官方文档入口</a>\n\n#### 3、更多的关键词作为参数标签\n\nSwift中有很多关键词，像`class`、`fund`、`let`和`public`这些都有其特殊意义，所以不能作为标识符使用。Swift中是允许你使用关键词作为参数标签的。如果你像下面代码一样把它们放在引号里面：\n\n```\n\nfunc visitCity(name: String, `in` state: String) {\n   print(\"I'm going to visit \\(name) in \\(state)\")\n}\n\nvisitCity(\"Nashville\", `in`: \"Tennessee\")\n\n```\n\nSwift2.2中除了`inout`、`var`、`let`之外，任何关键字都能被用作一个参数标签。如果你在代码中把关键字放在引号里，你将会得到一个Xcode的Fix-it警告，点击该警告便可自动移除引号。去掉引号的代码很可能是这样的：\n\n```\n\nfunc visitCity(name: String, in state: String) {\n  print(\"I'm going to visit \\(name) in \\(state)\")\n}\n\nvisitCity(\"Nashville\", in: \"Tennessee\")\n\n```\n\n#### 4、内置元组比较\n\n\nSwift2.2介绍了比较两个元组相等的能力。这意味着它将会检查元组中的每一个元素与另一个元组中的元素是否匹配，如果所有元素匹配，返回true。\n\n\n举个例子，下面的代码将会打印“不匹配”：\n\n```\n\nlet singer = (first: \"Taylor\", last: \"Swift\")\nlet alien = (first: \"Justin\", last: \"Bieber\")\n\nif singer == alien {\n   print(\"They match! That explains why you never see them together…\")\n} else {\n   print(\"No match.\")\n}\n\n```\n\n**Swift2.2元组的比较元素个数不能超过6个。**\n\n\n**警告：Swift2.2在检查平等性时将会忽略你的元素名，因此下面代码中的“singer”与”bird”会被认为是相等的：**\n\n```\n\nlet singer = (first: \"Taylor\", last: \"Swift\")\nlet bird = (name: \"Taylor\", breed: \"Swift\")\n\nif singer == bird {\n   print(\"This explains why she sings so well.\")\n} else {\n   print(\"No match.\")\n}\n\n```\n\n#### 5、元组的splat语法被弃用\n\n在Swift2.1之前，有可能会使用一个元组来填充一个函数的参数。因此，如果你有一个函数带了两个参数，你能用一个含有两个元素的元组来调用它，只要元组有正确的类型和元素名称，例如：\n\n```\n\nfunc describePerson(name: String, age: Int) {\n    print(\"\\(name) is \\(age) years old\")\n}\nlet person = (\"Malcolm Reynolds\", age: 49)\ndescribePerson(person)\n        \n```\n\n这种语法，被称为“元组splat语法”。这是不符合Swift的自身描述的语言习惯及可读性的风格。因此在Swift2.2中被弃用。\n\n#### 6、C语言风格的for循环被弃用\n\n\n即使Swift有很多种循环语法可选择，但是C语言风格的for循环仍然是语言中的一部分，偶尔会被使用。例如：\n\n```\n\nfor var i = 0; i < 10; i++ {\n    print(i)\n}\n\n```\n\n这种语法在Swift2.2中已经被弃用了，可能在Swift3.0中全部移除。\n\n如果你使用的是Xcode，你可能会得到一个Fix-it的警告，它将会把你C语言风格的for循环转换成现代的Swift。现在我们应该这样写：\n\n```\n\n for i in 0 ..< 10 {\n    print(i)\n }\n\n```\n\n然而，修复功能是被限制的，因此，有些事情需要你自己去做。例如，下面两个循环它将不会帮你修复它：\n\n```\n\nfor var i = 10; i > 0; i-- {\n   print(i)\n}\n\nfor var i = 0; i < 10; i += 2 {\n   print(i)\n}\n\n```\n\n第一种情况，你应该使用\"(1...10).reverse()\"创建一个反向范围。这个不能像之前一样写成\"i in 10…1”,这样写编译没有问题，但是在运行时会崩溃。第二种情况，你应该使用“stride(to:by:)”去累加2。因此，正确重写上面两个循环的方式如下所示：\n\n```\n\nfor i in (1...10).reverse() {\n    print(i)\n}\n\nfor i in 0.stride(to: 10, by: 2) {\n    print(i)\n}\n\n```\n\n#### 7、++和—-运算符被弃用\n\n\n如果你使用过C语言风格的for循环，肯定对++和——运算符并不陌生。在Swift3.0中，++和--运算符也被弃用了。例如像：`i++`,`i--`,`++i`,`--i`,`i = i++`这些都不能用了。取而代之的是:`i += 1`或`i -= 1`，像上面例子中的代码，Xcode也会提供Fix-it修复警告帮你修复代码。\n\n\n#### 8、var参数被弃用\n\n\nSwift2.2之前，如果你想在函数里面修改函数参数，可以把函数参数声明为var,例如：\n\n```\n\nfunc greet(var name: String) {\n    name = name.uppercaseString\n    print(\"Hello, \\(name)!\")\n}\n\nvar name = \"Taylor\"\ngreet(name)\nprint(\"After function, name is \\(name)\")\n\n```\n\n这样容易困惑，最后print()语句输出到底是“Taylor”还是”TAYLOR”呢？在inout关键字中存在更多的困惑：下面的例子中使用inout而不是使用var，然后添加一个”&”符号。便产生了这段代码：\n\n```\n\nfunc greet(inout name: String) {\n    name = name.uppercaseString\n    print(\"Hello, \\(name)!\")\n}\n\nvar name = \"Taylor\"\ngreet(&name)\nprint(\"After function, name is \\(name)\")\n\n```\n\n当程序运行时，var的例子与inout例子会产生不同的输出结果，因为改变var参数仅仅应用于函数内部，而改变inout参数则会直接影响到初始值。\n\n\n所以，在Swift2.2中，通过在函数参数中弃用var关键字来清楚这个困惑。在Swift3.0中将会被移除。如何你还想按照以前的习惯写，可以像下面这样：\n\n```\n\n func greet(name: String) {\n    let uppercaseName = name.uppercaseString\n    print(\"Hello, \\(uppercaseName)!\")\n }\n    \n```\n\n#### 9、重命名debug标识符\n\n\nSwift编译器在调试的时候自动提供了一些有用的符号，`__FILE__`会被替换成当前Swift文件名，`__LINE__`代表行数等等。在Swift2.2中，这些老的标识符被弃用，用`#file`,`#line`,`#column`,和`#function`取代。\n\n\n下面的例子中列出了新旧语法的区别：\n\n```\n\n func visitCity(name: String, in state: String) {\n        // old - deprecated!\n        print(\"This is on line \\(__LINE__) of \\(__FUNCTION__)\")\n\n        print(\"I'm going to visit \\(name) in \\(state)\")\n\n        // new - shiny!\n        print(\"This is on line \\(#line) of \\(#function)\")\n  }\n  \n```\n\n和其他的变化一样，Xcode会有Fix-it警告，来帮助你更新正确的代码。\n\n**本文内容来自网络，后续会持续更新完善。以上部分是我自己的学习与理解，欢迎一起学习交流！多多批评与指正！**\n\n**参考资料如下：**\n\n（1）<a href=\"https://swift.org/blog/swift-2-2-new-features/\">New Features in Swift 2.2</a>","source":"_posts/2016-05-09-swift2-dot-2xin-te-xing.markdown","raw":"---\nlayout: post\ntitle: \"Swift2.2新特性\"\ndate: 2016-05-09 23:09:48 +0800\ncomments: true\ntags: [iOS, Xcode, Swift, Swift2.2]\nkeywords: Swift, Swift2.2, Swift2.2新特性\ncategories: Swift\n---\n\n#### 1、编译期Swift版本检测\n\n```\n\n#if swift(>=3.0)\n    print(\"Running Swift 3.0 or later\")\n#else\n    print(\"Running Swift 2.2 or earlier\")\n#endif\n\n```\n\n它和Swift2中介绍过的`#available`表达式不同,#available表达式是运行时检查,`#if swift(>=3.0)... #else... #endif`是编译期检查。\n\n\n**一个警告:这个特性这次不可用,因为Swift2.1编译器并不知道`#if swift(>=2.2)`意味着什么。然而,一旦Swift3.0以及未来所有版本可用,Swift编译期版本检查将会是一个非常有用的工具。**\n<!--more-->\n\n#### 2、编译期选择器检查\n\n在Swift2.1,下面这段代码完全没有问题:\n\n```\n\noverride func viewDidLoad() {\n  super.viewDidLoad()\n  navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: \"addNewFireflyRefernce\")\n}\n\nfunc addNewFireflyReference() {\n   gratuitousReferences.append(\"We should start dealing in black-market beagles.\")\n}\n\n```\n\n\n上面这段代码在应用程序中会崩溃,因为导航栏按钮调用了一个方法`addNewFireflyRefernce`,方法名中的`Refrence`少了一个字母”e”.这类简单的单词拼写错误很容易造成bug,所以在Swift2.2中弃用了使用字符串作为选择器。使用新语法:`#selector`来取代它。\n\n使用`#selector`将会在编译期检查你的代码,确定你想调用的方法真实存在。甚至更好的是,如果方法不存在,你会得到一个编译错误。\n\n下面是通过`#selector`来重写之前的代码:\n\n```\noverride func viewDidLoad() {\n        super.viewDidLoad()\n        navigationItem.rightBarButtonItem =\n        UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: #selector(addNewFireflyReference))\n}\n\nfunc addNewFireflyReference() {\n  gratuitousReferences.append(\"Curse your sudden but inevitable betrayal!\")\n}\n\n```\n\n这里需要注意的:\n\nObjective-C Selectors(OC选择器)\n\n一个OC选择器是一种特指OC方法名的类型。在Swift里,OC选择器是通过Selector结构来表示的.你可以使用#selector表达式来构造一个选择器。例如`let mySelector = #selector(MyViewController.tappedButton)`,用一个直接引用一个OC方法作为子表达式。一个OC方法引用能被括号括起来,它能使用”as”操作符消除它与重载之间的歧义。例如`let anotherSelector = #selector(((UIView.insertSubview(_:at:)) as(UIView) ->(UIView, Int) ->Void))`。\n\n示例代码如下:为按钮添加事件\n\n```\n\nimport UIKit\nclass MyViewController: UIViewController {\n    let myButton = UIButton(frame: CGRect(x: 0, y: 0, width: 100, height: 50))\n\n    override init?(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) {\n        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)\n        let action = #selector(MyViewController.tappedButton)\n        myButton.addTarget(self, action: action, forControlEvents: .TouchUpInside)\n    }\n\n    func tappedButton(sender: UIButton!) {\n        print(\"tapped button\")\n    }\n\n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n    }\n}\n\n```\n\n<a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html\">官方文档入口</a>\n\n#### 3、更多的关键词作为参数标签\n\nSwift中有很多关键词，像`class`、`fund`、`let`和`public`这些都有其特殊意义，所以不能作为标识符使用。Swift中是允许你使用关键词作为参数标签的。如果你像下面代码一样把它们放在引号里面：\n\n```\n\nfunc visitCity(name: String, `in` state: String) {\n   print(\"I'm going to visit \\(name) in \\(state)\")\n}\n\nvisitCity(\"Nashville\", `in`: \"Tennessee\")\n\n```\n\nSwift2.2中除了`inout`、`var`、`let`之外，任何关键字都能被用作一个参数标签。如果你在代码中把关键字放在引号里，你将会得到一个Xcode的Fix-it警告，点击该警告便可自动移除引号。去掉引号的代码很可能是这样的：\n\n```\n\nfunc visitCity(name: String, in state: String) {\n  print(\"I'm going to visit \\(name) in \\(state)\")\n}\n\nvisitCity(\"Nashville\", in: \"Tennessee\")\n\n```\n\n#### 4、内置元组比较\n\n\nSwift2.2介绍了比较两个元组相等的能力。这意味着它将会检查元组中的每一个元素与另一个元组中的元素是否匹配，如果所有元素匹配，返回true。\n\n\n举个例子，下面的代码将会打印“不匹配”：\n\n```\n\nlet singer = (first: \"Taylor\", last: \"Swift\")\nlet alien = (first: \"Justin\", last: \"Bieber\")\n\nif singer == alien {\n   print(\"They match! That explains why you never see them together…\")\n} else {\n   print(\"No match.\")\n}\n\n```\n\n**Swift2.2元组的比较元素个数不能超过6个。**\n\n\n**警告：Swift2.2在检查平等性时将会忽略你的元素名，因此下面代码中的“singer”与”bird”会被认为是相等的：**\n\n```\n\nlet singer = (first: \"Taylor\", last: \"Swift\")\nlet bird = (name: \"Taylor\", breed: \"Swift\")\n\nif singer == bird {\n   print(\"This explains why she sings so well.\")\n} else {\n   print(\"No match.\")\n}\n\n```\n\n#### 5、元组的splat语法被弃用\n\n在Swift2.1之前，有可能会使用一个元组来填充一个函数的参数。因此，如果你有一个函数带了两个参数，你能用一个含有两个元素的元组来调用它，只要元组有正确的类型和元素名称，例如：\n\n```\n\nfunc describePerson(name: String, age: Int) {\n    print(\"\\(name) is \\(age) years old\")\n}\nlet person = (\"Malcolm Reynolds\", age: 49)\ndescribePerson(person)\n        \n```\n\n这种语法，被称为“元组splat语法”。这是不符合Swift的自身描述的语言习惯及可读性的风格。因此在Swift2.2中被弃用。\n\n#### 6、C语言风格的for循环被弃用\n\n\n即使Swift有很多种循环语法可选择，但是C语言风格的for循环仍然是语言中的一部分，偶尔会被使用。例如：\n\n```\n\nfor var i = 0; i < 10; i++ {\n    print(i)\n}\n\n```\n\n这种语法在Swift2.2中已经被弃用了，可能在Swift3.0中全部移除。\n\n如果你使用的是Xcode，你可能会得到一个Fix-it的警告，它将会把你C语言风格的for循环转换成现代的Swift。现在我们应该这样写：\n\n```\n\n for i in 0 ..< 10 {\n    print(i)\n }\n\n```\n\n然而，修复功能是被限制的，因此，有些事情需要你自己去做。例如，下面两个循环它将不会帮你修复它：\n\n```\n\nfor var i = 10; i > 0; i-- {\n   print(i)\n}\n\nfor var i = 0; i < 10; i += 2 {\n   print(i)\n}\n\n```\n\n第一种情况，你应该使用\"(1...10).reverse()\"创建一个反向范围。这个不能像之前一样写成\"i in 10…1”,这样写编译没有问题，但是在运行时会崩溃。第二种情况，你应该使用“stride(to:by:)”去累加2。因此，正确重写上面两个循环的方式如下所示：\n\n```\n\nfor i in (1...10).reverse() {\n    print(i)\n}\n\nfor i in 0.stride(to: 10, by: 2) {\n    print(i)\n}\n\n```\n\n#### 7、++和—-运算符被弃用\n\n\n如果你使用过C语言风格的for循环，肯定对++和——运算符并不陌生。在Swift3.0中，++和--运算符也被弃用了。例如像：`i++`,`i--`,`++i`,`--i`,`i = i++`这些都不能用了。取而代之的是:`i += 1`或`i -= 1`，像上面例子中的代码，Xcode也会提供Fix-it修复警告帮你修复代码。\n\n\n#### 8、var参数被弃用\n\n\nSwift2.2之前，如果你想在函数里面修改函数参数，可以把函数参数声明为var,例如：\n\n```\n\nfunc greet(var name: String) {\n    name = name.uppercaseString\n    print(\"Hello, \\(name)!\")\n}\n\nvar name = \"Taylor\"\ngreet(name)\nprint(\"After function, name is \\(name)\")\n\n```\n\n这样容易困惑，最后print()语句输出到底是“Taylor”还是”TAYLOR”呢？在inout关键字中存在更多的困惑：下面的例子中使用inout而不是使用var，然后添加一个”&”符号。便产生了这段代码：\n\n```\n\nfunc greet(inout name: String) {\n    name = name.uppercaseString\n    print(\"Hello, \\(name)!\")\n}\n\nvar name = \"Taylor\"\ngreet(&name)\nprint(\"After function, name is \\(name)\")\n\n```\n\n当程序运行时，var的例子与inout例子会产生不同的输出结果，因为改变var参数仅仅应用于函数内部，而改变inout参数则会直接影响到初始值。\n\n\n所以，在Swift2.2中，通过在函数参数中弃用var关键字来清楚这个困惑。在Swift3.0中将会被移除。如何你还想按照以前的习惯写，可以像下面这样：\n\n```\n\n func greet(name: String) {\n    let uppercaseName = name.uppercaseString\n    print(\"Hello, \\(uppercaseName)!\")\n }\n    \n```\n\n#### 9、重命名debug标识符\n\n\nSwift编译器在调试的时候自动提供了一些有用的符号，`__FILE__`会被替换成当前Swift文件名，`__LINE__`代表行数等等。在Swift2.2中，这些老的标识符被弃用，用`#file`,`#line`,`#column`,和`#function`取代。\n\n\n下面的例子中列出了新旧语法的区别：\n\n```\n\n func visitCity(name: String, in state: String) {\n        // old - deprecated!\n        print(\"This is on line \\(__LINE__) of \\(__FUNCTION__)\")\n\n        print(\"I'm going to visit \\(name) in \\(state)\")\n\n        // new - shiny!\n        print(\"This is on line \\(#line) of \\(#function)\")\n  }\n  \n```\n\n和其他的变化一样，Xcode会有Fix-it警告，来帮助你更新正确的代码。\n\n**本文内容来自网络，后续会持续更新完善。以上部分是我自己的学习与理解，欢迎一起学习交流！多多批评与指正！**\n\n**参考资料如下：**\n\n（1）<a href=\"https://swift.org/blog/swift-2-2-new-features/\">New Features in Swift 2.2</a>","slug":"swift2-dot-2xin-te-xing","published":1,"updated":"2016-09-10T05:18:22.000Z","_id":"ciswie9e20017e3u2j88j9oe0","photos":[],"link":"","content":"<h4 id=\"1、编译期Swift版本检测\"><a href=\"#1、编译期Swift版本检测\" class=\"headerlink\" title=\"1、编译期Swift版本检测\"></a>1、编译期Swift版本检测</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#if swift(&gt;=3.0)</div><div class=\"line\">    print(&quot;Running Swift 3.0 or later&quot;)</div><div class=\"line\">#else</div><div class=\"line\">    print(&quot;Running Swift 2.2 or earlier&quot;)</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n<p>它和Swift2中介绍过的<code>#available</code>表达式不同,#available表达式是运行时检查,<code>#if swift(&gt;=3.0)... #else... #endif</code>是编译期检查。</p>\n<p><strong>一个警告:这个特性这次不可用,因为Swift2.1编译器并不知道<code>#if swift(&gt;=2.2)</code>意味着什么。然而,一旦Swift3.0以及未来所有版本可用,Swift编译期版本检查将会是一个非常有用的工具。</strong><br><a id=\"more\"></a></p>\n<h4 id=\"2、编译期选择器检查\"><a href=\"#2、编译期选择器检查\" class=\"headerlink\" title=\"2、编译期选择器检查\"></a>2、编译期选择器检查</h4><p>在Swift2.1,下面这段代码完全没有问题:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">override func viewDidLoad() &#123;</div><div class=\"line\">  super.viewDidLoad()</div><div class=\"line\">  navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: &quot;addNewFireflyRefernce&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func addNewFireflyReference() &#123;</div><div class=\"line\">   gratuitousReferences.append(&quot;We should start dealing in black-market beagles.&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这段代码在应用程序中会崩溃,因为导航栏按钮调用了一个方法<code>addNewFireflyRefernce</code>,方法名中的<code>Refrence</code>少了一个字母”e”.这类简单的单词拼写错误很容易造成bug,所以在Swift2.2中弃用了使用字符串作为选择器。使用新语法:<code>#selector</code>来取代它。</p>\n<p>使用<code>#selector</code>将会在编译期检查你的代码,确定你想调用的方法真实存在。甚至更好的是,如果方法不存在,你会得到一个编译错误。</p>\n<p>下面是通过<code>#selector</code>来重写之前的代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">override func viewDidLoad() &#123;</div><div class=\"line\">        super.viewDidLoad()</div><div class=\"line\">        navigationItem.rightBarButtonItem =</div><div class=\"line\">        UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: #selector(addNewFireflyReference))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func addNewFireflyReference() &#123;</div><div class=\"line\">  gratuitousReferences.append(&quot;Curse your sudden but inevitable betrayal!&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里需要注意的:</p>\n<p>Objective-C Selectors(OC选择器)</p>\n<p>一个OC选择器是一种特指OC方法名的类型。在Swift里,OC选择器是通过Selector结构来表示的.你可以使用#selector表达式来构造一个选择器。例如<code>let mySelector = #selector(MyViewController.tappedButton)</code>,用一个直接引用一个OC方法作为子表达式。一个OC方法引用能被括号括起来,它能使用”as”操作符消除它与重载之间的歧义。例如<code>let anotherSelector = #selector(((UIView.insertSubview(_:at:)) as(UIView) -&gt;(UIView, Int) -&gt;Void))</code>。</p>\n<p>示例代码如下:为按钮添加事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">import UIKit</div><div class=\"line\">class MyViewController: UIViewController &#123;</div><div class=\"line\">    let myButton = UIButton(frame: CGRect(x: 0, y: 0, width: 100, height: 50))</div><div class=\"line\"></div><div class=\"line\">    override init?(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) &#123;</div><div class=\"line\">        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)</div><div class=\"line\">        let action = #selector(MyViewController.tappedButton)</div><div class=\"line\">        myButton.addTarget(self, action: action, forControlEvents: .TouchUpInside)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    func tappedButton(sender: UIButton!) &#123;</div><div class=\"line\">        print(&quot;tapped button&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    required init?(coder: NSCoder) &#123;</div><div class=\"line\">        super.init(coder: coder)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html\" target=\"_blank\" rel=\"external\">官方文档入口</a></p>\n<h4 id=\"3、更多的关键词作为参数标签\"><a href=\"#3、更多的关键词作为参数标签\" class=\"headerlink\" title=\"3、更多的关键词作为参数标签\"></a>3、更多的关键词作为参数标签</h4><p>Swift中有很多关键词，像<code>class</code>、<code>fund</code>、<code>let</code>和<code>public</code>这些都有其特殊意义，所以不能作为标识符使用。Swift中是允许你使用关键词作为参数标签的。如果你像下面代码一样把它们放在引号里面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">func visitCity(name: String, `in` state: String) &#123;</div><div class=\"line\">   print(&quot;I&apos;m going to visit \\(name) in \\(state)&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">visitCity(&quot;Nashville&quot;, `in`: &quot;Tennessee&quot;)</div></pre></td></tr></table></figure>\n<p>Swift2.2中除了<code>inout</code>、<code>var</code>、<code>let</code>之外，任何关键字都能被用作一个参数标签。如果你在代码中把关键字放在引号里，你将会得到一个Xcode的Fix-it警告，点击该警告便可自动移除引号。去掉引号的代码很可能是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">func visitCity(name: String, in state: String) &#123;</div><div class=\"line\">  print(&quot;I&apos;m going to visit \\(name) in \\(state)&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">visitCity(&quot;Nashville&quot;, in: &quot;Tennessee&quot;)</div></pre></td></tr></table></figure>\n<h4 id=\"4、内置元组比较\"><a href=\"#4、内置元组比较\" class=\"headerlink\" title=\"4、内置元组比较\"></a>4、内置元组比较</h4><p>Swift2.2介绍了比较两个元组相等的能力。这意味着它将会检查元组中的每一个元素与另一个元组中的元素是否匹配，如果所有元素匹配，返回true。</p>\n<p>举个例子，下面的代码将会打印“不匹配”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">let singer = (first: &quot;Taylor&quot;, last: &quot;Swift&quot;)</div><div class=\"line\">let alien = (first: &quot;Justin&quot;, last: &quot;Bieber&quot;)</div><div class=\"line\"></div><div class=\"line\">if singer == alien &#123;</div><div class=\"line\">   print(&quot;They match! That explains why you never see them together…&quot;)</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">   print(&quot;No match.&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>Swift2.2元组的比较元素个数不能超过6个。</strong></p>\n<p><strong>警告：Swift2.2在检查平等性时将会忽略你的元素名，因此下面代码中的“singer”与”bird”会被认为是相等的：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">let singer = (first: &quot;Taylor&quot;, last: &quot;Swift&quot;)</div><div class=\"line\">let bird = (name: &quot;Taylor&quot;, breed: &quot;Swift&quot;)</div><div class=\"line\"></div><div class=\"line\">if singer == bird &#123;</div><div class=\"line\">   print(&quot;This explains why she sings so well.&quot;)</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">   print(&quot;No match.&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"5、元组的splat语法被弃用\"><a href=\"#5、元组的splat语法被弃用\" class=\"headerlink\" title=\"5、元组的splat语法被弃用\"></a>5、元组的splat语法被弃用</h4><p>在Swift2.1之前，有可能会使用一个元组来填充一个函数的参数。因此，如果你有一个函数带了两个参数，你能用一个含有两个元素的元组来调用它，只要元组有正确的类型和元素名称，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">func describePerson(name: String, age: Int) &#123;</div><div class=\"line\">    print(&quot;\\(name) is \\(age) years old&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\">let person = (&quot;Malcolm Reynolds&quot;, age: 49)</div><div class=\"line\">describePerson(person)</div></pre></td></tr></table></figure>\n<p>这种语法，被称为“元组splat语法”。这是不符合Swift的自身描述的语言习惯及可读性的风格。因此在Swift2.2中被弃用。</p>\n<h4 id=\"6、C语言风格的for循环被弃用\"><a href=\"#6、C语言风格的for循环被弃用\" class=\"headerlink\" title=\"6、C语言风格的for循环被弃用\"></a>6、C语言风格的for循环被弃用</h4><p>即使Swift有很多种循环语法可选择，但是C语言风格的for循环仍然是语言中的一部分，偶尔会被使用。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">for var i = 0; i &lt; 10; i++ &#123;</div><div class=\"line\">    print(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种语法在Swift2.2中已经被弃用了，可能在Swift3.0中全部移除。</p>\n<p>如果你使用的是Xcode，你可能会得到一个Fix-it的警告，它将会把你C语言风格的for循环转换成现代的Swift。现在我们应该这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">for i in 0 ..&lt; 10 &#123;</div><div class=\"line\">   print(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然而，修复功能是被限制的，因此，有些事情需要你自己去做。例如，下面两个循环它将不会帮你修复它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">for var i = 10; i &gt; 0; i-- &#123;</div><div class=\"line\">   print(i)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">for var i = 0; i &lt; 10; i += 2 &#123;</div><div class=\"line\">   print(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一种情况，你应该使用”(1…10).reverse()”创建一个反向范围。这个不能像之前一样写成”i in 10…1”,这样写编译没有问题，但是在运行时会崩溃。第二种情况，你应该使用“stride(to:by:)”去累加2。因此，正确重写上面两个循环的方式如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">for i in (1...10).reverse() &#123;</div><div class=\"line\">    print(i)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">for i in 0.stride(to: 10, by: 2) &#123;</div><div class=\"line\">    print(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"7、-和—-运算符被弃用\"><a href=\"#7、-和—-运算符被弃用\" class=\"headerlink\" title=\"7、++和—-运算符被弃用\"></a>7、++和—-运算符被弃用</h4><p>如果你使用过C语言风格的for循环，肯定对++和——运算符并不陌生。在Swift3.0中，++和–运算符也被弃用了。例如像：<code>i++</code>,<code>i--</code>,<code>++i</code>,<code>--i</code>,<code>i = i++</code>这些都不能用了。取而代之的是:<code>i += 1</code>或<code>i -= 1</code>，像上面例子中的代码，Xcode也会提供Fix-it修复警告帮你修复代码。</p>\n<h4 id=\"8、var参数被弃用\"><a href=\"#8、var参数被弃用\" class=\"headerlink\" title=\"8、var参数被弃用\"></a>8、var参数被弃用</h4><p>Swift2.2之前，如果你想在函数里面修改函数参数，可以把函数参数声明为var,例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">func greet(var name: String) &#123;</div><div class=\"line\">    name = name.uppercaseString</div><div class=\"line\">    print(&quot;Hello, \\(name)!&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var name = &quot;Taylor&quot;</div><div class=\"line\">greet(name)</div><div class=\"line\">print(&quot;After function, name is \\(name)&quot;)</div></pre></td></tr></table></figure>\n<p>这样容易困惑，最后print()语句输出到底是“Taylor”还是”TAYLOR”呢？在inout关键字中存在更多的困惑：下面的例子中使用inout而不是使用var，然后添加一个”&amp;”符号。便产生了这段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">func greet(inout name: String) &#123;</div><div class=\"line\">    name = name.uppercaseString</div><div class=\"line\">    print(&quot;Hello, \\(name)!&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var name = &quot;Taylor&quot;</div><div class=\"line\">greet(&amp;name)</div><div class=\"line\">print(&quot;After function, name is \\(name)&quot;)</div></pre></td></tr></table></figure>\n<p>当程序运行时，var的例子与inout例子会产生不同的输出结果，因为改变var参数仅仅应用于函数内部，而改变inout参数则会直接影响到初始值。</p>\n<p>所以，在Swift2.2中，通过在函数参数中弃用var关键字来清楚这个困惑。在Swift3.0中将会被移除。如何你还想按照以前的习惯写，可以像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">func greet(name: String) &#123;</div><div class=\"line\">   let uppercaseName = name.uppercaseString</div><div class=\"line\">   print(&quot;Hello, \\(uppercaseName)!&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"9、重命名debug标识符\"><a href=\"#9、重命名debug标识符\" class=\"headerlink\" title=\"9、重命名debug标识符\"></a>9、重命名debug标识符</h4><p>Swift编译器在调试的时候自动提供了一些有用的符号，<code>__FILE__</code>会被替换成当前Swift文件名，<code>__LINE__</code>代表行数等等。在Swift2.2中，这些老的标识符被弃用，用<code>#file</code>,<code>#line</code>,<code>#column</code>,和<code>#function</code>取代。</p>\n<p>下面的例子中列出了新旧语法的区别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">func visitCity(name: String, in state: String) &#123;</div><div class=\"line\">       // old - deprecated!</div><div class=\"line\">       print(&quot;This is on line \\(__LINE__) of \\(__FUNCTION__)&quot;)</div><div class=\"line\"></div><div class=\"line\">       print(&quot;I&apos;m going to visit \\(name) in \\(state)&quot;)</div><div class=\"line\"></div><div class=\"line\">       // new - shiny!</div><div class=\"line\">       print(&quot;This is on line \\(#line) of \\(#function)&quot;)</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>和其他的变化一样，Xcode会有Fix-it警告，来帮助你更新正确的代码。</p>\n<p><strong>本文内容来自网络，后续会持续更新完善。以上部分是我自己的学习与理解，欢迎一起学习交流！多多批评与指正！</strong></p>\n<p><strong>参考资料如下：</strong></p>\n<p>（1）<a href=\"https://swift.org/blog/swift-2-2-new-features/\" target=\"_blank\" rel=\"external\">New Features in Swift 2.2</a></p>\n","excerpt":"<h4 id=\"1、编译期Swift版本检测\"><a href=\"#1、编译期Swift版本检测\" class=\"headerlink\" title=\"1、编译期Swift版本检测\"></a>1、编译期Swift版本检测</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#if swift(&gt;=3.0)</div><div class=\"line\">    print(&quot;Running Swift 3.0 or later&quot;)</div><div class=\"line\">#else</div><div class=\"line\">    print(&quot;Running Swift 2.2 or earlier&quot;)</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n<p>它和Swift2中介绍过的<code>#available</code>表达式不同,#available表达式是运行时检查,<code>#if swift(&gt;=3.0)... #else... #endif</code>是编译期检查。</p>\n<p><strong>一个警告:这个特性这次不可用,因为Swift2.1编译器并不知道<code>#if swift(&gt;=2.2)</code>意味着什么。然而,一旦Swift3.0以及未来所有版本可用,Swift编译期版本检查将会是一个非常有用的工具。</strong><br>","more":"</p>\n<h4 id=\"2、编译期选择器检查\"><a href=\"#2、编译期选择器检查\" class=\"headerlink\" title=\"2、编译期选择器检查\"></a>2、编译期选择器检查</h4><p>在Swift2.1,下面这段代码完全没有问题:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">override func viewDidLoad() &#123;</div><div class=\"line\">  super.viewDidLoad()</div><div class=\"line\">  navigationItem.rightBarButtonItem = UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: &quot;addNewFireflyRefernce&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func addNewFireflyReference() &#123;</div><div class=\"line\">   gratuitousReferences.append(&quot;We should start dealing in black-market beagles.&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这段代码在应用程序中会崩溃,因为导航栏按钮调用了一个方法<code>addNewFireflyRefernce</code>,方法名中的<code>Refrence</code>少了一个字母”e”.这类简单的单词拼写错误很容易造成bug,所以在Swift2.2中弃用了使用字符串作为选择器。使用新语法:<code>#selector</code>来取代它。</p>\n<p>使用<code>#selector</code>将会在编译期检查你的代码,确定你想调用的方法真实存在。甚至更好的是,如果方法不存在,你会得到一个编译错误。</p>\n<p>下面是通过<code>#selector</code>来重写之前的代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">override func viewDidLoad() &#123;</div><div class=\"line\">        super.viewDidLoad()</div><div class=\"line\">        navigationItem.rightBarButtonItem =</div><div class=\"line\">        UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: #selector(addNewFireflyReference))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func addNewFireflyReference() &#123;</div><div class=\"line\">  gratuitousReferences.append(&quot;Curse your sudden but inevitable betrayal!&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里需要注意的:</p>\n<p>Objective-C Selectors(OC选择器)</p>\n<p>一个OC选择器是一种特指OC方法名的类型。在Swift里,OC选择器是通过Selector结构来表示的.你可以使用#selector表达式来构造一个选择器。例如<code>let mySelector = #selector(MyViewController.tappedButton)</code>,用一个直接引用一个OC方法作为子表达式。一个OC方法引用能被括号括起来,它能使用”as”操作符消除它与重载之间的歧义。例如<code>let anotherSelector = #selector(((UIView.insertSubview(_:at:)) as(UIView) -&gt;(UIView, Int) -&gt;Void))</code>。</p>\n<p>示例代码如下:为按钮添加事件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">import UIKit</div><div class=\"line\">class MyViewController: UIViewController &#123;</div><div class=\"line\">    let myButton = UIButton(frame: CGRect(x: 0, y: 0, width: 100, height: 50))</div><div class=\"line\"></div><div class=\"line\">    override init?(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?) &#123;</div><div class=\"line\">        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)</div><div class=\"line\">        let action = #selector(MyViewController.tappedButton)</div><div class=\"line\">        myButton.addTarget(self, action: action, forControlEvents: .TouchUpInside)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    func tappedButton(sender: UIButton!) &#123;</div><div class=\"line\">        print(&quot;tapped button&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    required init?(coder: NSCoder) &#123;</div><div class=\"line\">        super.init(coder: coder)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html\">官方文档入口</a></p>\n<h4 id=\"3、更多的关键词作为参数标签\"><a href=\"#3、更多的关键词作为参数标签\" class=\"headerlink\" title=\"3、更多的关键词作为参数标签\"></a>3、更多的关键词作为参数标签</h4><p>Swift中有很多关键词，像<code>class</code>、<code>fund</code>、<code>let</code>和<code>public</code>这些都有其特殊意义，所以不能作为标识符使用。Swift中是允许你使用关键词作为参数标签的。如果你像下面代码一样把它们放在引号里面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">func visitCity(name: String, `in` state: String) &#123;</div><div class=\"line\">   print(&quot;I&apos;m going to visit \\(name) in \\(state)&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">visitCity(&quot;Nashville&quot;, `in`: &quot;Tennessee&quot;)</div></pre></td></tr></table></figure>\n<p>Swift2.2中除了<code>inout</code>、<code>var</code>、<code>let</code>之外，任何关键字都能被用作一个参数标签。如果你在代码中把关键字放在引号里，你将会得到一个Xcode的Fix-it警告，点击该警告便可自动移除引号。去掉引号的代码很可能是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">func visitCity(name: String, in state: String) &#123;</div><div class=\"line\">  print(&quot;I&apos;m going to visit \\(name) in \\(state)&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">visitCity(&quot;Nashville&quot;, in: &quot;Tennessee&quot;)</div></pre></td></tr></table></figure>\n<h4 id=\"4、内置元组比较\"><a href=\"#4、内置元组比较\" class=\"headerlink\" title=\"4、内置元组比较\"></a>4、内置元组比较</h4><p>Swift2.2介绍了比较两个元组相等的能力。这意味着它将会检查元组中的每一个元素与另一个元组中的元素是否匹配，如果所有元素匹配，返回true。</p>\n<p>举个例子，下面的代码将会打印“不匹配”：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">let singer = (first: &quot;Taylor&quot;, last: &quot;Swift&quot;)</div><div class=\"line\">let alien = (first: &quot;Justin&quot;, last: &quot;Bieber&quot;)</div><div class=\"line\"></div><div class=\"line\">if singer == alien &#123;</div><div class=\"line\">   print(&quot;They match! That explains why you never see them together…&quot;)</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">   print(&quot;No match.&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>Swift2.2元组的比较元素个数不能超过6个。</strong></p>\n<p><strong>警告：Swift2.2在检查平等性时将会忽略你的元素名，因此下面代码中的“singer”与”bird”会被认为是相等的：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">let singer = (first: &quot;Taylor&quot;, last: &quot;Swift&quot;)</div><div class=\"line\">let bird = (name: &quot;Taylor&quot;, breed: &quot;Swift&quot;)</div><div class=\"line\"></div><div class=\"line\">if singer == bird &#123;</div><div class=\"line\">   print(&quot;This explains why she sings so well.&quot;)</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">   print(&quot;No match.&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"5、元组的splat语法被弃用\"><a href=\"#5、元组的splat语法被弃用\" class=\"headerlink\" title=\"5、元组的splat语法被弃用\"></a>5、元组的splat语法被弃用</h4><p>在Swift2.1之前，有可能会使用一个元组来填充一个函数的参数。因此，如果你有一个函数带了两个参数，你能用一个含有两个元素的元组来调用它，只要元组有正确的类型和元素名称，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">func describePerson(name: String, age: Int) &#123;</div><div class=\"line\">    print(&quot;\\(name) is \\(age) years old&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\">let person = (&quot;Malcolm Reynolds&quot;, age: 49)</div><div class=\"line\">describePerson(person)</div></pre></td></tr></table></figure>\n<p>这种语法，被称为“元组splat语法”。这是不符合Swift的自身描述的语言习惯及可读性的风格。因此在Swift2.2中被弃用。</p>\n<h4 id=\"6、C语言风格的for循环被弃用\"><a href=\"#6、C语言风格的for循环被弃用\" class=\"headerlink\" title=\"6、C语言风格的for循环被弃用\"></a>6、C语言风格的for循环被弃用</h4><p>即使Swift有很多种循环语法可选择，但是C语言风格的for循环仍然是语言中的一部分，偶尔会被使用。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">for var i = 0; i &lt; 10; i++ &#123;</div><div class=\"line\">    print(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种语法在Swift2.2中已经被弃用了，可能在Swift3.0中全部移除。</p>\n<p>如果你使用的是Xcode，你可能会得到一个Fix-it的警告，它将会把你C语言风格的for循环转换成现代的Swift。现在我们应该这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">for i in 0 ..&lt; 10 &#123;</div><div class=\"line\">   print(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然而，修复功能是被限制的，因此，有些事情需要你自己去做。例如，下面两个循环它将不会帮你修复它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">for var i = 10; i &gt; 0; i-- &#123;</div><div class=\"line\">   print(i)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">for var i = 0; i &lt; 10; i += 2 &#123;</div><div class=\"line\">   print(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一种情况，你应该使用”(1…10).reverse()”创建一个反向范围。这个不能像之前一样写成”i in 10…1”,这样写编译没有问题，但是在运行时会崩溃。第二种情况，你应该使用“stride(to:by:)”去累加2。因此，正确重写上面两个循环的方式如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">for i in (1...10).reverse() &#123;</div><div class=\"line\">    print(i)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">for i in 0.stride(to: 10, by: 2) &#123;</div><div class=\"line\">    print(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"7、-和—-运算符被弃用\"><a href=\"#7、-和—-运算符被弃用\" class=\"headerlink\" title=\"7、++和—-运算符被弃用\"></a>7、++和—-运算符被弃用</h4><p>如果你使用过C语言风格的for循环，肯定对++和——运算符并不陌生。在Swift3.0中，++和–运算符也被弃用了。例如像：<code>i++</code>,<code>i--</code>,<code>++i</code>,<code>--i</code>,<code>i = i++</code>这些都不能用了。取而代之的是:<code>i += 1</code>或<code>i -= 1</code>，像上面例子中的代码，Xcode也会提供Fix-it修复警告帮你修复代码。</p>\n<h4 id=\"8、var参数被弃用\"><a href=\"#8、var参数被弃用\" class=\"headerlink\" title=\"8、var参数被弃用\"></a>8、var参数被弃用</h4><p>Swift2.2之前，如果你想在函数里面修改函数参数，可以把函数参数声明为var,例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">func greet(var name: String) &#123;</div><div class=\"line\">    name = name.uppercaseString</div><div class=\"line\">    print(&quot;Hello, \\(name)!&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var name = &quot;Taylor&quot;</div><div class=\"line\">greet(name)</div><div class=\"line\">print(&quot;After function, name is \\(name)&quot;)</div></pre></td></tr></table></figure>\n<p>这样容易困惑，最后print()语句输出到底是“Taylor”还是”TAYLOR”呢？在inout关键字中存在更多的困惑：下面的例子中使用inout而不是使用var，然后添加一个”&amp;”符号。便产生了这段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">func greet(inout name: String) &#123;</div><div class=\"line\">    name = name.uppercaseString</div><div class=\"line\">    print(&quot;Hello, \\(name)!&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var name = &quot;Taylor&quot;</div><div class=\"line\">greet(&amp;name)</div><div class=\"line\">print(&quot;After function, name is \\(name)&quot;)</div></pre></td></tr></table></figure>\n<p>当程序运行时，var的例子与inout例子会产生不同的输出结果，因为改变var参数仅仅应用于函数内部，而改变inout参数则会直接影响到初始值。</p>\n<p>所以，在Swift2.2中，通过在函数参数中弃用var关键字来清楚这个困惑。在Swift3.0中将会被移除。如何你还想按照以前的习惯写，可以像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">func greet(name: String) &#123;</div><div class=\"line\">   let uppercaseName = name.uppercaseString</div><div class=\"line\">   print(&quot;Hello, \\(uppercaseName)!&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"9、重命名debug标识符\"><a href=\"#9、重命名debug标识符\" class=\"headerlink\" title=\"9、重命名debug标识符\"></a>9、重命名debug标识符</h4><p>Swift编译器在调试的时候自动提供了一些有用的符号，<code>__FILE__</code>会被替换成当前Swift文件名，<code>__LINE__</code>代表行数等等。在Swift2.2中，这些老的标识符被弃用，用<code>#file</code>,<code>#line</code>,<code>#column</code>,和<code>#function</code>取代。</p>\n<p>下面的例子中列出了新旧语法的区别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">func visitCity(name: String, in state: String) &#123;</div><div class=\"line\">       // old - deprecated!</div><div class=\"line\">       print(&quot;This is on line \\(__LINE__) of \\(__FUNCTION__)&quot;)</div><div class=\"line\"></div><div class=\"line\">       print(&quot;I&apos;m going to visit \\(name) in \\(state)&quot;)</div><div class=\"line\"></div><div class=\"line\">       // new - shiny!</div><div class=\"line\">       print(&quot;This is on line \\(#line) of \\(#function)&quot;)</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>和其他的变化一样，Xcode会有Fix-it警告，来帮助你更新正确的代码。</p>\n<p><strong>本文内容来自网络，后续会持续更新完善。以上部分是我自己的学习与理解，欢迎一起学习交流！多多批评与指正！</strong></p>\n<p><strong>参考资料如下：</strong></p>\n<p>（1）<a href=\"https://swift.org/blog/swift-2-2-new-features/\">New Features in Swift 2.2</a></p>"},{"layout":"post","title":"iOS图形绘制UIBezierPath篇","date":"2016-05-14T13:55:19.000Z","comments":1,"keywords":"UIBezierPath, Quartz2D, 绘制图形","_content":"#### 1、绘制直线\n\n```\nUIBezierPath *line = [[UIBezierPath alloc] init];\n//设置线宽\nline.lineWidth = 3;\n[line moveToPoint:CGPointMake(50, 20)];\n[line addLineToPoint:CGPointMake(150, 20)];\n//设置绘制线条颜色，这个地方需要注意！UIBezierPath本身类中不包含设置颜色的属性，它是通过UIColor来直接设置。\n[[UIColor orangeColor] setStroke];\n/*\n*线条形状\n*kCGLineCapButt,   //不带端点\n*kCGLineCapRound,  //端点带圆角\n*kCGLineCapSquare  //端点是正方形\n*/\nline.lineCapStyle = kCGLineCapRound;\n[line stroke];\n\n```\n<!--more-->\n#### 2、绘制矩形\n\n* 直接通过UIRectFill绘制（不带边框）\n\n\n```\n\n[[UIColor blueColor] setFill];\nUIRectFill(CGRectMake(50, 30, 100, 40));\n    \n```\n\n* 使用UIBezierPath绘制（带边框）\n\n```\n\nUIBezierPath *rectangle = [UIBezierPath bezierPathWithRect:CGRectMake(50, 80, 80, 80)];\n//边框线宽\nrectangle.lineWidth = 3;\n//边框线颜色\n[[UIColor purpleColor] setStroke];\n/*\n*线条之间连接点形状\n*kCGLineJoinMiter,      //内斜接\n*kCGLineJoinRound,     //圆角\n*kCGLineJoinBevel      //外斜接\n*/\nrectangle.lineJoinStyle = kCGLineJoinRound;\n//绘制边框\n[rectangle stroke];\n//设置填充颜色\n[[UIColor yellowColor] setFill];\n//绘制矩形内部填充部分\n[rectangle fill];\n    \n```\n\n* 直接绘制带圆角的矩形（实心）：这里也是可以添加边框，具体设置同上\n\n```\n\nUIBezierPath *rectangleCorner = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 170, 80, 80) cornerRadius:4];\n[[UIColor brownColor] setFill];\n[rectangleCorner fill];\n    \n```\n\n* 绘制部分带圆角的矩形边框（空心）\n\n```\n\n/*\n*UIRectCorner:圆角位置\n*UIRectCornerTopLeft     = 1 << 0,     //左上角\n*UIRectCornerTopRight    = 1 << 1,     //右上角\n*UIRectCornerBottomLeft  = 1 << 2,     //左下角\n*UIRectCornerBottomRight = 1 << 3,     //右下角\n*UIRectCornerAllCorners        //所有角\n*\n*/\nrectangleCorner = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 260, 40, 40) byRoundingCorners:UIRectCornerTopLeft | UIRectCornerTopRight cornerRadii:CGSizeMake(4, 4)];\n[rectangleCorner stroke];\n    \n```\n\n#### 3、绘制圆形（绘制椭圆只需更改高宽即可）\n\n\n```\n\nUIBezierPath *circle = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 310, 80, 80)];\n[[UIColor blueColor] setStroke];\ncircle.lineWidth = 3;\n[circle stroke];\n[[UIColor redColor] setFill];\n[circle fill];\n\n```\n\n\n#### 4、绘制多边形:(这是正宗的三角形)\n\n```\n\nUIBezierPath *polygon = [UIBezierPath bezierPath];\n[polygon moveToPoint:CGPointMake(50, 390)];\n[polygon addLineToPoint:CGPointMake(30, 450)];\n[polygon addLineToPoint:CGPointMake(100, 450)];\n[[UIColor magentaColor] setFill];\n[polygon fill];\n\n```\n\n**啊，三角形不是多边形吗？不调戏各位看客了，还是来个正宗多边形，哈哈哈（六角形）**\n\n```\n\n[polygon moveToPoint:CGPointMake(50, 460)];\n[polygon addLineToPoint:CGPointMake(20, 500)];\n[polygon addLineToPoint:CGPointMake(50, 540)];\n[polygon addLineToPoint:CGPointMake(100, 540)];\n[polygon addLineToPoint:CGPointMake(130, 500)];\n[polygon addLineToPoint:CGPointMake(100, 460)];\n[[UIColor magentaColor] setFill];\n[polygon fill];\n    \n```\n\n#### 5、绘制弧线\n\n```\n\n//clockwise参数表示是否顺时针绘制\n//弧长计算公式：\nUIBezierPath *arcLine = [UIBezierPath bezierPathWithArcCenter:CGPointMake(160, 20) radius:50 startAngle:0 endAngle:90 *  M_PI / 180 clockwise:YES];\n//下面这种创建方式也是一样的\n//[arcLine addArcWithCenter:CGPointMake(160, 20) radius:50 startAngle:0 endAngle:90 * M_PI / 180 clockwise:YES];\narcLine.lineWidth = 3;\n[[UIColor grayColor] setStroke];\n[arcLine stroke];\n    \n```\n\n#### 6、绘制贝塞尔曲线\n\n```\n\nUIBezierPath *quadLine = [UIBezierPath bezierPath];\n[quadLine moveToPoint:CGPointMake(160, 80)];\n//带一个控制点\n//[quadLine addQuadCurveToPoint:CGPointMake(210, 120) controlPoint:CGPointMake(240, 90)];\n//带两个控制点\n[quadLine addCurveToPoint:CGPointMake(310, 80) controlPoint1:CGPointMake(210, 150) controlPoint2:CGPointMake(270, 150)];\n[[UIColor redColor] setStroke];\n[quadLine stroke];\n    \n```\n\n#### 7、绘制一个简单的曲线图(这个技术难度不高，项目中又常见，可以拿来练练手)\n\n```\n\n- (void)drawRect:(CGRect)rect {\n//绘制线条\n    UIBezierPath *grayLine = [UIBezierPath bezierPath];\n    grayLine.lineWidth = 1;\n    grayLine.lineCapStyle = kCGLineCapButt;\n    [[UIColor lightGrayColor] setStroke];\n    CGFloat x1 = 140;\n    CGFloat x2 = 360;\n    CGFloat y = 160;\n    //循环绘制7条横向线条\n    for (int i = 0; i < 7; i++) {\n        [self drawPathWithLine:grayLine movePoint:CGPointMake(x1, y + i * 20) toPoint:CGPointMake(x2, y + i * 20)];\n    }\n\n    //绘制竖线\n    [self drawPathWithLine:grayLine movePoint:CGPointMake(x1 + 5, y) toPoint:CGPointMake(x1 + 5, y + 6 * 20 + 5)];\n    [self drawPathWithLine:grayLine movePoint:CGPointMake(x2, y) toPoint:CGPointMake(x2, y + 6 * 20 + 5)];\n    //绘制圆点\n    UIBezierPath *circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1, y + 5 * 20 - 5, 10, 10)];\n    [[UIColor blueColor] setStroke];\n    UIBezierPath *blueLine = [UIBezierPath bezierPath];\n    blueLine.lineWidth = 2;\n    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x - 2.5, circleDot.currentPoint.y - 5) toPoint:CGPointMake(x1 + 40 + 2.5 , y + 1 * 20 + 5)];\n    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 40, y + 1 * 20 - 5, 10, 10)];\n    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x , circleDot.currentPoint.y + 2.5) toPoint:CGPointMake(x1 + 80 , y + 3 * 20 - 12.5)];\n    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 80, y + 3 * 20 - 15, 10, 10)];\n    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x , circleDot.currentPoint.y + 5) toPoint:CGPointMake(x1 + 120 , y + 4 * 20)];\n    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 120, y + 4 * 20, 10, 10)];\n    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x, circleDot.currentPoint.y - 5) toPoint:CGPointMake(x1 + 160 , y + 1 * 20 - 5)];\n    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 160, y + 1 * 20 - 15, 10, 10)];\n    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x , circleDot.currentPoint.y + 5) toPoint:CGPointMake(x1 + 200 , y + 6 * 20 - 15)];\n    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 200 - 2.5, y + 6 * 20 - 15, 10, 10)];\n}\n\n- (void)drawPathWithLine:(UIBezierPath *)line movePoint:(CGPoint)movePoint toPoint:(CGPoint)toPoint {\n    [line moveToPoint:movePoint];\n    [line addLineToPoint:toPoint];\n    [line stroke];\n}\n\n- (UIBezierPath *)drawCircleWithOvalInRect:(CGRect)frame {\n    UIBezierPath *circleDot = [UIBezierPath bezierPathWithOvalInRect:frame];\n    [[UIColor blueColor] setFill];\n    [circleDot fill];\n    return circleDot;\n}\n\n```\n\n**看客：博主，你代码写的太差了！我看不下去了！死菜鸡！**\n\n**博主：大哥，我已经尽力了！**\n\n**看客：这么菜，你还有脸写博客！你咋不上天呢？**\n\n**博主：那你咋不遁地！**\n\n#### 文中代码效果图：\n\n![](http://ww1.sinaimg.cn/mw690/7f266405jw1f3vbdc3656j20ku12adi4.jpg)\n**不要问我为什么画的这么丑，哥已经尽力了！**\n\n#### 参考博客地址： \n* <a href = \"http://ghui.me/post/2016/04/ios-bezierpath/\">iOS绘图之用UIKit框架绘制常见图形（这篇是用Swift语言写的）</a>\n\n转载请注明出处\n\n","source":"_posts/2016-05-14-iostu-xing-hui-zhi-uibezierpathpian.markdown","raw":"---\nlayout: post\ntitle: \"iOS图形绘制UIBezierPath篇\"\ndate: 2016-05-14 21:55:19 +0800\ncomments: true\ntags: [iOS9, Xcode7.3, Xcode, UIBezierPath, Quartz2D]\nkeywords: UIBezierPath, Quartz2D, 绘制图形\ncategories: Objective-C\n---\n#### 1、绘制直线\n\n```\nUIBezierPath *line = [[UIBezierPath alloc] init];\n//设置线宽\nline.lineWidth = 3;\n[line moveToPoint:CGPointMake(50, 20)];\n[line addLineToPoint:CGPointMake(150, 20)];\n//设置绘制线条颜色，这个地方需要注意！UIBezierPath本身类中不包含设置颜色的属性，它是通过UIColor来直接设置。\n[[UIColor orangeColor] setStroke];\n/*\n*线条形状\n*kCGLineCapButt,   //不带端点\n*kCGLineCapRound,  //端点带圆角\n*kCGLineCapSquare  //端点是正方形\n*/\nline.lineCapStyle = kCGLineCapRound;\n[line stroke];\n\n```\n<!--more-->\n#### 2、绘制矩形\n\n* 直接通过UIRectFill绘制（不带边框）\n\n\n```\n\n[[UIColor blueColor] setFill];\nUIRectFill(CGRectMake(50, 30, 100, 40));\n    \n```\n\n* 使用UIBezierPath绘制（带边框）\n\n```\n\nUIBezierPath *rectangle = [UIBezierPath bezierPathWithRect:CGRectMake(50, 80, 80, 80)];\n//边框线宽\nrectangle.lineWidth = 3;\n//边框线颜色\n[[UIColor purpleColor] setStroke];\n/*\n*线条之间连接点形状\n*kCGLineJoinMiter,      //内斜接\n*kCGLineJoinRound,     //圆角\n*kCGLineJoinBevel      //外斜接\n*/\nrectangle.lineJoinStyle = kCGLineJoinRound;\n//绘制边框\n[rectangle stroke];\n//设置填充颜色\n[[UIColor yellowColor] setFill];\n//绘制矩形内部填充部分\n[rectangle fill];\n    \n```\n\n* 直接绘制带圆角的矩形（实心）：这里也是可以添加边框，具体设置同上\n\n```\n\nUIBezierPath *rectangleCorner = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 170, 80, 80) cornerRadius:4];\n[[UIColor brownColor] setFill];\n[rectangleCorner fill];\n    \n```\n\n* 绘制部分带圆角的矩形边框（空心）\n\n```\n\n/*\n*UIRectCorner:圆角位置\n*UIRectCornerTopLeft     = 1 << 0,     //左上角\n*UIRectCornerTopRight    = 1 << 1,     //右上角\n*UIRectCornerBottomLeft  = 1 << 2,     //左下角\n*UIRectCornerBottomRight = 1 << 3,     //右下角\n*UIRectCornerAllCorners        //所有角\n*\n*/\nrectangleCorner = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 260, 40, 40) byRoundingCorners:UIRectCornerTopLeft | UIRectCornerTopRight cornerRadii:CGSizeMake(4, 4)];\n[rectangleCorner stroke];\n    \n```\n\n#### 3、绘制圆形（绘制椭圆只需更改高宽即可）\n\n\n```\n\nUIBezierPath *circle = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 310, 80, 80)];\n[[UIColor blueColor] setStroke];\ncircle.lineWidth = 3;\n[circle stroke];\n[[UIColor redColor] setFill];\n[circle fill];\n\n```\n\n\n#### 4、绘制多边形:(这是正宗的三角形)\n\n```\n\nUIBezierPath *polygon = [UIBezierPath bezierPath];\n[polygon moveToPoint:CGPointMake(50, 390)];\n[polygon addLineToPoint:CGPointMake(30, 450)];\n[polygon addLineToPoint:CGPointMake(100, 450)];\n[[UIColor magentaColor] setFill];\n[polygon fill];\n\n```\n\n**啊，三角形不是多边形吗？不调戏各位看客了，还是来个正宗多边形，哈哈哈（六角形）**\n\n```\n\n[polygon moveToPoint:CGPointMake(50, 460)];\n[polygon addLineToPoint:CGPointMake(20, 500)];\n[polygon addLineToPoint:CGPointMake(50, 540)];\n[polygon addLineToPoint:CGPointMake(100, 540)];\n[polygon addLineToPoint:CGPointMake(130, 500)];\n[polygon addLineToPoint:CGPointMake(100, 460)];\n[[UIColor magentaColor] setFill];\n[polygon fill];\n    \n```\n\n#### 5、绘制弧线\n\n```\n\n//clockwise参数表示是否顺时针绘制\n//弧长计算公式：\nUIBezierPath *arcLine = [UIBezierPath bezierPathWithArcCenter:CGPointMake(160, 20) radius:50 startAngle:0 endAngle:90 *  M_PI / 180 clockwise:YES];\n//下面这种创建方式也是一样的\n//[arcLine addArcWithCenter:CGPointMake(160, 20) radius:50 startAngle:0 endAngle:90 * M_PI / 180 clockwise:YES];\narcLine.lineWidth = 3;\n[[UIColor grayColor] setStroke];\n[arcLine stroke];\n    \n```\n\n#### 6、绘制贝塞尔曲线\n\n```\n\nUIBezierPath *quadLine = [UIBezierPath bezierPath];\n[quadLine moveToPoint:CGPointMake(160, 80)];\n//带一个控制点\n//[quadLine addQuadCurveToPoint:CGPointMake(210, 120) controlPoint:CGPointMake(240, 90)];\n//带两个控制点\n[quadLine addCurveToPoint:CGPointMake(310, 80) controlPoint1:CGPointMake(210, 150) controlPoint2:CGPointMake(270, 150)];\n[[UIColor redColor] setStroke];\n[quadLine stroke];\n    \n```\n\n#### 7、绘制一个简单的曲线图(这个技术难度不高，项目中又常见，可以拿来练练手)\n\n```\n\n- (void)drawRect:(CGRect)rect {\n//绘制线条\n    UIBezierPath *grayLine = [UIBezierPath bezierPath];\n    grayLine.lineWidth = 1;\n    grayLine.lineCapStyle = kCGLineCapButt;\n    [[UIColor lightGrayColor] setStroke];\n    CGFloat x1 = 140;\n    CGFloat x2 = 360;\n    CGFloat y = 160;\n    //循环绘制7条横向线条\n    for (int i = 0; i < 7; i++) {\n        [self drawPathWithLine:grayLine movePoint:CGPointMake(x1, y + i * 20) toPoint:CGPointMake(x2, y + i * 20)];\n    }\n\n    //绘制竖线\n    [self drawPathWithLine:grayLine movePoint:CGPointMake(x1 + 5, y) toPoint:CGPointMake(x1 + 5, y + 6 * 20 + 5)];\n    [self drawPathWithLine:grayLine movePoint:CGPointMake(x2, y) toPoint:CGPointMake(x2, y + 6 * 20 + 5)];\n    //绘制圆点\n    UIBezierPath *circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1, y + 5 * 20 - 5, 10, 10)];\n    [[UIColor blueColor] setStroke];\n    UIBezierPath *blueLine = [UIBezierPath bezierPath];\n    blueLine.lineWidth = 2;\n    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x - 2.5, circleDot.currentPoint.y - 5) toPoint:CGPointMake(x1 + 40 + 2.5 , y + 1 * 20 + 5)];\n    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 40, y + 1 * 20 - 5, 10, 10)];\n    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x , circleDot.currentPoint.y + 2.5) toPoint:CGPointMake(x1 + 80 , y + 3 * 20 - 12.5)];\n    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 80, y + 3 * 20 - 15, 10, 10)];\n    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x , circleDot.currentPoint.y + 5) toPoint:CGPointMake(x1 + 120 , y + 4 * 20)];\n    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 120, y + 4 * 20, 10, 10)];\n    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x, circleDot.currentPoint.y - 5) toPoint:CGPointMake(x1 + 160 , y + 1 * 20 - 5)];\n    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 160, y + 1 * 20 - 15, 10, 10)];\n    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x , circleDot.currentPoint.y + 5) toPoint:CGPointMake(x1 + 200 , y + 6 * 20 - 15)];\n    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 200 - 2.5, y + 6 * 20 - 15, 10, 10)];\n}\n\n- (void)drawPathWithLine:(UIBezierPath *)line movePoint:(CGPoint)movePoint toPoint:(CGPoint)toPoint {\n    [line moveToPoint:movePoint];\n    [line addLineToPoint:toPoint];\n    [line stroke];\n}\n\n- (UIBezierPath *)drawCircleWithOvalInRect:(CGRect)frame {\n    UIBezierPath *circleDot = [UIBezierPath bezierPathWithOvalInRect:frame];\n    [[UIColor blueColor] setFill];\n    [circleDot fill];\n    return circleDot;\n}\n\n```\n\n**看客：博主，你代码写的太差了！我看不下去了！死菜鸡！**\n\n**博主：大哥，我已经尽力了！**\n\n**看客：这么菜，你还有脸写博客！你咋不上天呢？**\n\n**博主：那你咋不遁地！**\n\n#### 文中代码效果图：\n\n![](http://ww1.sinaimg.cn/mw690/7f266405jw1f3vbdc3656j20ku12adi4.jpg)\n**不要问我为什么画的这么丑，哥已经尽力了！**\n\n#### 参考博客地址： \n* <a href = \"http://ghui.me/post/2016/04/ios-bezierpath/\">iOS绘图之用UIKit框架绘制常见图形（这篇是用Swift语言写的）</a>\n\n转载请注明出处\n\n","slug":"iostu-xing-hui-zhi-uibezierpathpian","published":1,"updated":"2016-09-10T05:18:35.000Z","_id":"ciswie9e5001ce3u2y2lmfsq1","photos":[],"link":"","content":"<h4 id=\"1、绘制直线\"><a href=\"#1、绘制直线\" class=\"headerlink\" title=\"1、绘制直线\"></a>1、绘制直线</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIBezierPath *line = [[UIBezierPath alloc] init];</div><div class=\"line\">//设置线宽</div><div class=\"line\">line.lineWidth = 3;</div><div class=\"line\">[line moveToPoint:CGPointMake(50, 20)];</div><div class=\"line\">[line addLineToPoint:CGPointMake(150, 20)];</div><div class=\"line\">//设置绘制线条颜色，这个地方需要注意！UIBezierPath本身类中不包含设置颜色的属性，它是通过UIColor来直接设置。</div><div class=\"line\">[[UIColor orangeColor] setStroke];</div><div class=\"line\">/*</div><div class=\"line\">*线条形状</div><div class=\"line\">*kCGLineCapButt,   //不带端点</div><div class=\"line\">*kCGLineCapRound,  //端点带圆角</div><div class=\"line\">*kCGLineCapSquare  //端点是正方形</div><div class=\"line\">*/</div><div class=\"line\">line.lineCapStyle = kCGLineCapRound;</div><div class=\"line\">[line stroke];</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h4 id=\"2、绘制矩形\"><a href=\"#2、绘制矩形\" class=\"headerlink\" title=\"2、绘制矩形\"></a>2、绘制矩形</h4><ul>\n<li>直接通过UIRectFill绘制（不带边框）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">[[UIColor blueColor] setFill];</div><div class=\"line\">UIRectFill(CGRectMake(50, 30, 100, 40));</div></pre></td></tr></table></figure>\n<ul>\n<li>使用UIBezierPath绘制（带边框）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">UIBezierPath *rectangle = [UIBezierPath bezierPathWithRect:CGRectMake(50, 80, 80, 80)];</div><div class=\"line\">//边框线宽</div><div class=\"line\">rectangle.lineWidth = 3;</div><div class=\"line\">//边框线颜色</div><div class=\"line\">[[UIColor purpleColor] setStroke];</div><div class=\"line\">/*</div><div class=\"line\">*线条之间连接点形状</div><div class=\"line\">*kCGLineJoinMiter,      //内斜接</div><div class=\"line\">*kCGLineJoinRound,     //圆角</div><div class=\"line\">*kCGLineJoinBevel      //外斜接</div><div class=\"line\">*/</div><div class=\"line\">rectangle.lineJoinStyle = kCGLineJoinRound;</div><div class=\"line\">//绘制边框</div><div class=\"line\">[rectangle stroke];</div><div class=\"line\">//设置填充颜色</div><div class=\"line\">[[UIColor yellowColor] setFill];</div><div class=\"line\">//绘制矩形内部填充部分</div><div class=\"line\">[rectangle fill];</div></pre></td></tr></table></figure>\n<ul>\n<li>直接绘制带圆角的矩形（实心）：这里也是可以添加边框，具体设置同上</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">UIBezierPath *rectangleCorner = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 170, 80, 80) cornerRadius:4];</div><div class=\"line\">[[UIColor brownColor] setFill];</div><div class=\"line\">[rectangleCorner fill];</div></pre></td></tr></table></figure>\n<ul>\n<li>绘制部分带圆角的矩形边框（空心）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\">*UIRectCorner:圆角位置</div><div class=\"line\">*UIRectCornerTopLeft     = 1 &lt;&lt; 0,     //左上角</div><div class=\"line\">*UIRectCornerTopRight    = 1 &lt;&lt; 1,     //右上角</div><div class=\"line\">*UIRectCornerBottomLeft  = 1 &lt;&lt; 2,     //左下角</div><div class=\"line\">*UIRectCornerBottomRight = 1 &lt;&lt; 3,     //右下角</div><div class=\"line\">*UIRectCornerAllCorners        //所有角</div><div class=\"line\">*</div><div class=\"line\">*/</div><div class=\"line\">rectangleCorner = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 260, 40, 40) byRoundingCorners:UIRectCornerTopLeft | UIRectCornerTopRight cornerRadii:CGSizeMake(4, 4)];</div><div class=\"line\">[rectangleCorner stroke];</div></pre></td></tr></table></figure>\n<h4 id=\"3、绘制圆形（绘制椭圆只需更改高宽即可）\"><a href=\"#3、绘制圆形（绘制椭圆只需更改高宽即可）\" class=\"headerlink\" title=\"3、绘制圆形（绘制椭圆只需更改高宽即可）\"></a>3、绘制圆形（绘制椭圆只需更改高宽即可）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">UIBezierPath *circle = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 310, 80, 80)];</div><div class=\"line\">[[UIColor blueColor] setStroke];</div><div class=\"line\">circle.lineWidth = 3;</div><div class=\"line\">[circle stroke];</div><div class=\"line\">[[UIColor redColor] setFill];</div><div class=\"line\">[circle fill];</div></pre></td></tr></table></figure>\n<h4 id=\"4、绘制多边形-这是正宗的三角形\"><a href=\"#4、绘制多边形-这是正宗的三角形\" class=\"headerlink\" title=\"4、绘制多边形:(这是正宗的三角形)\"></a>4、绘制多边形:(这是正宗的三角形)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">UIBezierPath *polygon = [UIBezierPath bezierPath];</div><div class=\"line\">[polygon moveToPoint:CGPointMake(50, 390)];</div><div class=\"line\">[polygon addLineToPoint:CGPointMake(30, 450)];</div><div class=\"line\">[polygon addLineToPoint:CGPointMake(100, 450)];</div><div class=\"line\">[[UIColor magentaColor] setFill];</div><div class=\"line\">[polygon fill];</div></pre></td></tr></table></figure>\n<p><strong>啊，三角形不是多边形吗？不调戏各位看客了，还是来个正宗多边形，哈哈哈（六角形）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">[polygon moveToPoint:CGPointMake(50, 460)];</div><div class=\"line\">[polygon addLineToPoint:CGPointMake(20, 500)];</div><div class=\"line\">[polygon addLineToPoint:CGPointMake(50, 540)];</div><div class=\"line\">[polygon addLineToPoint:CGPointMake(100, 540)];</div><div class=\"line\">[polygon addLineToPoint:CGPointMake(130, 500)];</div><div class=\"line\">[polygon addLineToPoint:CGPointMake(100, 460)];</div><div class=\"line\">[[UIColor magentaColor] setFill];</div><div class=\"line\">[polygon fill];</div></pre></td></tr></table></figure>\n<h4 id=\"5、绘制弧线\"><a href=\"#5、绘制弧线\" class=\"headerlink\" title=\"5、绘制弧线\"></a>5、绘制弧线</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//clockwise参数表示是否顺时针绘制</div><div class=\"line\">//弧长计算公式：</div><div class=\"line\">UIBezierPath *arcLine = [UIBezierPath bezierPathWithArcCenter:CGPointMake(160, 20) radius:50 startAngle:0 endAngle:90 *  M_PI / 180 clockwise:YES];</div><div class=\"line\">//下面这种创建方式也是一样的</div><div class=\"line\">//[arcLine addArcWithCenter:CGPointMake(160, 20) radius:50 startAngle:0 endAngle:90 * M_PI / 180 clockwise:YES];</div><div class=\"line\">arcLine.lineWidth = 3;</div><div class=\"line\">[[UIColor grayColor] setStroke];</div><div class=\"line\">[arcLine stroke];</div></pre></td></tr></table></figure>\n<h4 id=\"6、绘制贝塞尔曲线\"><a href=\"#6、绘制贝塞尔曲线\" class=\"headerlink\" title=\"6、绘制贝塞尔曲线\"></a>6、绘制贝塞尔曲线</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">UIBezierPath *quadLine = [UIBezierPath bezierPath];</div><div class=\"line\">[quadLine moveToPoint:CGPointMake(160, 80)];</div><div class=\"line\">//带一个控制点</div><div class=\"line\">//[quadLine addQuadCurveToPoint:CGPointMake(210, 120) controlPoint:CGPointMake(240, 90)];</div><div class=\"line\">//带两个控制点</div><div class=\"line\">[quadLine addCurveToPoint:CGPointMake(310, 80) controlPoint1:CGPointMake(210, 150) controlPoint2:CGPointMake(270, 150)];</div><div class=\"line\">[[UIColor redColor] setStroke];</div><div class=\"line\">[quadLine stroke];</div></pre></td></tr></table></figure>\n<h4 id=\"7、绘制一个简单的曲线图-这个技术难度不高，项目中又常见，可以拿来练练手\"><a href=\"#7、绘制一个简单的曲线图-这个技术难度不高，项目中又常见，可以拿来练练手\" class=\"headerlink\" title=\"7、绘制一个简单的曲线图(这个技术难度不高，项目中又常见，可以拿来练练手)\"></a>7、绘制一个简单的曲线图(这个技术难度不高，项目中又常见，可以拿来练练手)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- (void)drawRect:(CGRect)rect &#123;</div><div class=\"line\">//绘制线条</div><div class=\"line\">    UIBezierPath *grayLine = [UIBezierPath bezierPath];</div><div class=\"line\">    grayLine.lineWidth = 1;</div><div class=\"line\">    grayLine.lineCapStyle = kCGLineCapButt;</div><div class=\"line\">    [[UIColor lightGrayColor] setStroke];</div><div class=\"line\">    CGFloat x1 = 140;</div><div class=\"line\">    CGFloat x2 = 360;</div><div class=\"line\">    CGFloat y = 160;</div><div class=\"line\">    //循环绘制7条横向线条</div><div class=\"line\">    for (int i = 0; i &lt; 7; i++) &#123;</div><div class=\"line\">        [self drawPathWithLine:grayLine movePoint:CGPointMake(x1, y + i * 20) toPoint:CGPointMake(x2, y + i * 20)];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //绘制竖线</div><div class=\"line\">    [self drawPathWithLine:grayLine movePoint:CGPointMake(x1 + 5, y) toPoint:CGPointMake(x1 + 5, y + 6 * 20 + 5)];</div><div class=\"line\">    [self drawPathWithLine:grayLine movePoint:CGPointMake(x2, y) toPoint:CGPointMake(x2, y + 6 * 20 + 5)];</div><div class=\"line\">    //绘制圆点</div><div class=\"line\">    UIBezierPath *circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1, y + 5 * 20 - 5, 10, 10)];</div><div class=\"line\">    [[UIColor blueColor] setStroke];</div><div class=\"line\">    UIBezierPath *blueLine = [UIBezierPath bezierPath];</div><div class=\"line\">    blueLine.lineWidth = 2;</div><div class=\"line\">    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x - 2.5, circleDot.currentPoint.y - 5) toPoint:CGPointMake(x1 + 40 + 2.5 , y + 1 * 20 + 5)];</div><div class=\"line\">    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 40, y + 1 * 20 - 5, 10, 10)];</div><div class=\"line\">    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x , circleDot.currentPoint.y + 2.5) toPoint:CGPointMake(x1 + 80 , y + 3 * 20 - 12.5)];</div><div class=\"line\">    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 80, y + 3 * 20 - 15, 10, 10)];</div><div class=\"line\">    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x , circleDot.currentPoint.y + 5) toPoint:CGPointMake(x1 + 120 , y + 4 * 20)];</div><div class=\"line\">    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 120, y + 4 * 20, 10, 10)];</div><div class=\"line\">    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x, circleDot.currentPoint.y - 5) toPoint:CGPointMake(x1 + 160 , y + 1 * 20 - 5)];</div><div class=\"line\">    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 160, y + 1 * 20 - 15, 10, 10)];</div><div class=\"line\">    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x , circleDot.currentPoint.y + 5) toPoint:CGPointMake(x1 + 200 , y + 6 * 20 - 15)];</div><div class=\"line\">    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 200 - 2.5, y + 6 * 20 - 15, 10, 10)];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)drawPathWithLine:(UIBezierPath *)line movePoint:(CGPoint)movePoint toPoint:(CGPoint)toPoint &#123;</div><div class=\"line\">    [line moveToPoint:movePoint];</div><div class=\"line\">    [line addLineToPoint:toPoint];</div><div class=\"line\">    [line stroke];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIBezierPath *)drawCircleWithOvalInRect:(CGRect)frame &#123;</div><div class=\"line\">    UIBezierPath *circleDot = [UIBezierPath bezierPathWithOvalInRect:frame];</div><div class=\"line\">    [[UIColor blueColor] setFill];</div><div class=\"line\">    [circleDot fill];</div><div class=\"line\">    return circleDot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>看客：博主，你代码写的太差了！我看不下去了！死菜鸡！</strong></p>\n<p><strong>博主：大哥，我已经尽力了！</strong></p>\n<p><strong>看客：这么菜，你还有脸写博客！你咋不上天呢？</strong></p>\n<p><strong>博主：那你咋不遁地！</strong></p>\n<h4 id=\"文中代码效果图：\"><a href=\"#文中代码效果图：\" class=\"headerlink\" title=\"文中代码效果图：\"></a>文中代码效果图：</h4><p><img src=\"http://ww1.sinaimg.cn/mw690/7f266405jw1f3vbdc3656j20ku12adi4.jpg\" alt=\"\"><br><strong>不要问我为什么画的这么丑，哥已经尽力了！</strong></p>\n<h4 id=\"参考博客地址：\"><a href=\"#参考博客地址：\" class=\"headerlink\" title=\"参考博客地址：\"></a>参考博客地址：</h4><ul>\n<li><a href=\"http://ghui.me/post/2016/04/ios-bezierpath/\" target=\"_blank\" rel=\"external\">iOS绘图之用UIKit框架绘制常见图形（这篇是用Swift语言写的）</a></li>\n</ul>\n<p>转载请注明出处</p>\n","excerpt":"<h4 id=\"1、绘制直线\"><a href=\"#1、绘制直线\" class=\"headerlink\" title=\"1、绘制直线\"></a>1、绘制直线</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIBezierPath *line = [[UIBezierPath alloc] init];</div><div class=\"line\">//设置线宽</div><div class=\"line\">line.lineWidth = 3;</div><div class=\"line\">[line moveToPoint:CGPointMake(50, 20)];</div><div class=\"line\">[line addLineToPoint:CGPointMake(150, 20)];</div><div class=\"line\">//设置绘制线条颜色，这个地方需要注意！UIBezierPath本身类中不包含设置颜色的属性，它是通过UIColor来直接设置。</div><div class=\"line\">[[UIColor orangeColor] setStroke];</div><div class=\"line\">/*</div><div class=\"line\">*线条形状</div><div class=\"line\">*kCGLineCapButt,   //不带端点</div><div class=\"line\">*kCGLineCapRound,  //端点带圆角</div><div class=\"line\">*kCGLineCapSquare  //端点是正方形</div><div class=\"line\">*/</div><div class=\"line\">line.lineCapStyle = kCGLineCapRound;</div><div class=\"line\">[line stroke];</div></pre></td></tr></table></figure>","more":"<h4 id=\"2、绘制矩形\"><a href=\"#2、绘制矩形\" class=\"headerlink\" title=\"2、绘制矩形\"></a>2、绘制矩形</h4><ul>\n<li>直接通过UIRectFill绘制（不带边框）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">[[UIColor blueColor] setFill];</div><div class=\"line\">UIRectFill(CGRectMake(50, 30, 100, 40));</div></pre></td></tr></table></figure>\n<ul>\n<li>使用UIBezierPath绘制（带边框）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">UIBezierPath *rectangle = [UIBezierPath bezierPathWithRect:CGRectMake(50, 80, 80, 80)];</div><div class=\"line\">//边框线宽</div><div class=\"line\">rectangle.lineWidth = 3;</div><div class=\"line\">//边框线颜色</div><div class=\"line\">[[UIColor purpleColor] setStroke];</div><div class=\"line\">/*</div><div class=\"line\">*线条之间连接点形状</div><div class=\"line\">*kCGLineJoinMiter,      //内斜接</div><div class=\"line\">*kCGLineJoinRound,     //圆角</div><div class=\"line\">*kCGLineJoinBevel      //外斜接</div><div class=\"line\">*/</div><div class=\"line\">rectangle.lineJoinStyle = kCGLineJoinRound;</div><div class=\"line\">//绘制边框</div><div class=\"line\">[rectangle stroke];</div><div class=\"line\">//设置填充颜色</div><div class=\"line\">[[UIColor yellowColor] setFill];</div><div class=\"line\">//绘制矩形内部填充部分</div><div class=\"line\">[rectangle fill];</div></pre></td></tr></table></figure>\n<ul>\n<li>直接绘制带圆角的矩形（实心）：这里也是可以添加边框，具体设置同上</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">UIBezierPath *rectangleCorner = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 170, 80, 80) cornerRadius:4];</div><div class=\"line\">[[UIColor brownColor] setFill];</div><div class=\"line\">[rectangleCorner fill];</div></pre></td></tr></table></figure>\n<ul>\n<li>绘制部分带圆角的矩形边框（空心）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\">*UIRectCorner:圆角位置</div><div class=\"line\">*UIRectCornerTopLeft     = 1 &lt;&lt; 0,     //左上角</div><div class=\"line\">*UIRectCornerTopRight    = 1 &lt;&lt; 1,     //右上角</div><div class=\"line\">*UIRectCornerBottomLeft  = 1 &lt;&lt; 2,     //左下角</div><div class=\"line\">*UIRectCornerBottomRight = 1 &lt;&lt; 3,     //右下角</div><div class=\"line\">*UIRectCornerAllCorners        //所有角</div><div class=\"line\">*</div><div class=\"line\">*/</div><div class=\"line\">rectangleCorner = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 260, 40, 40) byRoundingCorners:UIRectCornerTopLeft | UIRectCornerTopRight cornerRadii:CGSizeMake(4, 4)];</div><div class=\"line\">[rectangleCorner stroke];</div></pre></td></tr></table></figure>\n<h4 id=\"3、绘制圆形（绘制椭圆只需更改高宽即可）\"><a href=\"#3、绘制圆形（绘制椭圆只需更改高宽即可）\" class=\"headerlink\" title=\"3、绘制圆形（绘制椭圆只需更改高宽即可）\"></a>3、绘制圆形（绘制椭圆只需更改高宽即可）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">UIBezierPath *circle = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 310, 80, 80)];</div><div class=\"line\">[[UIColor blueColor] setStroke];</div><div class=\"line\">circle.lineWidth = 3;</div><div class=\"line\">[circle stroke];</div><div class=\"line\">[[UIColor redColor] setFill];</div><div class=\"line\">[circle fill];</div></pre></td></tr></table></figure>\n<h4 id=\"4、绘制多边形-这是正宗的三角形\"><a href=\"#4、绘制多边形-这是正宗的三角形\" class=\"headerlink\" title=\"4、绘制多边形:(这是正宗的三角形)\"></a>4、绘制多边形:(这是正宗的三角形)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">UIBezierPath *polygon = [UIBezierPath bezierPath];</div><div class=\"line\">[polygon moveToPoint:CGPointMake(50, 390)];</div><div class=\"line\">[polygon addLineToPoint:CGPointMake(30, 450)];</div><div class=\"line\">[polygon addLineToPoint:CGPointMake(100, 450)];</div><div class=\"line\">[[UIColor magentaColor] setFill];</div><div class=\"line\">[polygon fill];</div></pre></td></tr></table></figure>\n<p><strong>啊，三角形不是多边形吗？不调戏各位看客了，还是来个正宗多边形，哈哈哈（六角形）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">[polygon moveToPoint:CGPointMake(50, 460)];</div><div class=\"line\">[polygon addLineToPoint:CGPointMake(20, 500)];</div><div class=\"line\">[polygon addLineToPoint:CGPointMake(50, 540)];</div><div class=\"line\">[polygon addLineToPoint:CGPointMake(100, 540)];</div><div class=\"line\">[polygon addLineToPoint:CGPointMake(130, 500)];</div><div class=\"line\">[polygon addLineToPoint:CGPointMake(100, 460)];</div><div class=\"line\">[[UIColor magentaColor] setFill];</div><div class=\"line\">[polygon fill];</div></pre></td></tr></table></figure>\n<h4 id=\"5、绘制弧线\"><a href=\"#5、绘制弧线\" class=\"headerlink\" title=\"5、绘制弧线\"></a>5、绘制弧线</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//clockwise参数表示是否顺时针绘制</div><div class=\"line\">//弧长计算公式：</div><div class=\"line\">UIBezierPath *arcLine = [UIBezierPath bezierPathWithArcCenter:CGPointMake(160, 20) radius:50 startAngle:0 endAngle:90 *  M_PI / 180 clockwise:YES];</div><div class=\"line\">//下面这种创建方式也是一样的</div><div class=\"line\">//[arcLine addArcWithCenter:CGPointMake(160, 20) radius:50 startAngle:0 endAngle:90 * M_PI / 180 clockwise:YES];</div><div class=\"line\">arcLine.lineWidth = 3;</div><div class=\"line\">[[UIColor grayColor] setStroke];</div><div class=\"line\">[arcLine stroke];</div></pre></td></tr></table></figure>\n<h4 id=\"6、绘制贝塞尔曲线\"><a href=\"#6、绘制贝塞尔曲线\" class=\"headerlink\" title=\"6、绘制贝塞尔曲线\"></a>6、绘制贝塞尔曲线</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">UIBezierPath *quadLine = [UIBezierPath bezierPath];</div><div class=\"line\">[quadLine moveToPoint:CGPointMake(160, 80)];</div><div class=\"line\">//带一个控制点</div><div class=\"line\">//[quadLine addQuadCurveToPoint:CGPointMake(210, 120) controlPoint:CGPointMake(240, 90)];</div><div class=\"line\">//带两个控制点</div><div class=\"line\">[quadLine addCurveToPoint:CGPointMake(310, 80) controlPoint1:CGPointMake(210, 150) controlPoint2:CGPointMake(270, 150)];</div><div class=\"line\">[[UIColor redColor] setStroke];</div><div class=\"line\">[quadLine stroke];</div></pre></td></tr></table></figure>\n<h4 id=\"7、绘制一个简单的曲线图-这个技术难度不高，项目中又常见，可以拿来练练手\"><a href=\"#7、绘制一个简单的曲线图-这个技术难度不高，项目中又常见，可以拿来练练手\" class=\"headerlink\" title=\"7、绘制一个简单的曲线图(这个技术难度不高，项目中又常见，可以拿来练练手)\"></a>7、绘制一个简单的曲线图(这个技术难度不高，项目中又常见，可以拿来练练手)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- (void)drawRect:(CGRect)rect &#123;</div><div class=\"line\">//绘制线条</div><div class=\"line\">    UIBezierPath *grayLine = [UIBezierPath bezierPath];</div><div class=\"line\">    grayLine.lineWidth = 1;</div><div class=\"line\">    grayLine.lineCapStyle = kCGLineCapButt;</div><div class=\"line\">    [[UIColor lightGrayColor] setStroke];</div><div class=\"line\">    CGFloat x1 = 140;</div><div class=\"line\">    CGFloat x2 = 360;</div><div class=\"line\">    CGFloat y = 160;</div><div class=\"line\">    //循环绘制7条横向线条</div><div class=\"line\">    for (int i = 0; i &lt; 7; i++) &#123;</div><div class=\"line\">        [self drawPathWithLine:grayLine movePoint:CGPointMake(x1, y + i * 20) toPoint:CGPointMake(x2, y + i * 20)];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //绘制竖线</div><div class=\"line\">    [self drawPathWithLine:grayLine movePoint:CGPointMake(x1 + 5, y) toPoint:CGPointMake(x1 + 5, y + 6 * 20 + 5)];</div><div class=\"line\">    [self drawPathWithLine:grayLine movePoint:CGPointMake(x2, y) toPoint:CGPointMake(x2, y + 6 * 20 + 5)];</div><div class=\"line\">    //绘制圆点</div><div class=\"line\">    UIBezierPath *circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1, y + 5 * 20 - 5, 10, 10)];</div><div class=\"line\">    [[UIColor blueColor] setStroke];</div><div class=\"line\">    UIBezierPath *blueLine = [UIBezierPath bezierPath];</div><div class=\"line\">    blueLine.lineWidth = 2;</div><div class=\"line\">    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x - 2.5, circleDot.currentPoint.y - 5) toPoint:CGPointMake(x1 + 40 + 2.5 , y + 1 * 20 + 5)];</div><div class=\"line\">    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 40, y + 1 * 20 - 5, 10, 10)];</div><div class=\"line\">    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x , circleDot.currentPoint.y + 2.5) toPoint:CGPointMake(x1 + 80 , y + 3 * 20 - 12.5)];</div><div class=\"line\">    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 80, y + 3 * 20 - 15, 10, 10)];</div><div class=\"line\">    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x , circleDot.currentPoint.y + 5) toPoint:CGPointMake(x1 + 120 , y + 4 * 20)];</div><div class=\"line\">    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 120, y + 4 * 20, 10, 10)];</div><div class=\"line\">    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x, circleDot.currentPoint.y - 5) toPoint:CGPointMake(x1 + 160 , y + 1 * 20 - 5)];</div><div class=\"line\">    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 160, y + 1 * 20 - 15, 10, 10)];</div><div class=\"line\">    [self drawPathWithLine:blueLine movePoint:CGPointMake(circleDot.currentPoint.x , circleDot.currentPoint.y + 5) toPoint:CGPointMake(x1 + 200 , y + 6 * 20 - 15)];</div><div class=\"line\">    circleDot = [self drawCircleWithOvalInRect:CGRectMake(x1 + 200 - 2.5, y + 6 * 20 - 15, 10, 10)];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)drawPathWithLine:(UIBezierPath *)line movePoint:(CGPoint)movePoint toPoint:(CGPoint)toPoint &#123;</div><div class=\"line\">    [line moveToPoint:movePoint];</div><div class=\"line\">    [line addLineToPoint:toPoint];</div><div class=\"line\">    [line stroke];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIBezierPath *)drawCircleWithOvalInRect:(CGRect)frame &#123;</div><div class=\"line\">    UIBezierPath *circleDot = [UIBezierPath bezierPathWithOvalInRect:frame];</div><div class=\"line\">    [[UIColor blueColor] setFill];</div><div class=\"line\">    [circleDot fill];</div><div class=\"line\">    return circleDot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>看客：博主，你代码写的太差了！我看不下去了！死菜鸡！</strong></p>\n<p><strong>博主：大哥，我已经尽力了！</strong></p>\n<p><strong>看客：这么菜，你还有脸写博客！你咋不上天呢？</strong></p>\n<p><strong>博主：那你咋不遁地！</strong></p>\n<h4 id=\"文中代码效果图：\"><a href=\"#文中代码效果图：\" class=\"headerlink\" title=\"文中代码效果图：\"></a>文中代码效果图：</h4><p><img src=\"http://ww1.sinaimg.cn/mw690/7f266405jw1f3vbdc3656j20ku12adi4.jpg\" alt=\"\"><br><strong>不要问我为什么画的这么丑，哥已经尽力了！</strong></p>\n<h4 id=\"参考博客地址：\"><a href=\"#参考博客地址：\" class=\"headerlink\" title=\"参考博客地址：\"></a>参考博客地址：</h4><ul>\n<li><a href = \"http://ghui.me/post/2016/04/ios-bezierpath/\">iOS绘图之用UIKit框架绘制常见图形（这篇是用Swift语言写的）</a></li>\n</ul>\n<p>转载请注明出处</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ciswie9bz0000e3u2ysvu3uno","category_id":"ciswie9cb0003e3u2mq1xwk38","_id":"ciswie9cq000ae3u2zquvouzt"},{"post_id":"ciswie9c50001e3u23qsy7wya","category_id":"ciswie9cn0008e3u2wt2h5r9y","_id":"ciswie9d3000ge3u24hvra3z5"},{"post_id":"ciswie9cq000be3u2gz6jx9l9","category_id":"ciswie9cn0008e3u2wt2h5r9y","_id":"ciswie9d5000ke3u27ruh7woc"},{"post_id":"ciswie9cy000ee3u2w8lf47sv","category_id":"ciswie9cb0003e3u2mq1xwk38","_id":"ciswie9d9000ne3u2tb048ddg"},{"post_id":"ciswie9cb0004e3u2aowy3tdi","category_id":"ciswie9cn0008e3u2wt2h5r9y","_id":"ciswie9dd000se3u28onflkt8"},{"post_id":"ciswie9d1000fe3u21bcenr6e","category_id":"ciswie9cb0003e3u2mq1xwk38","_id":"ciswie9dg000ve3u2ohqcljq6"},{"post_id":"ciswie9cd0005e3u21c8u1bym","category_id":"ciswie9cn0008e3u2wt2h5r9y","_id":"ciswie9dx000ze3u2hz74slk6"},{"post_id":"ciswie9d7000me3u27inh99nn","category_id":"ciswie9cb0003e3u2mq1xwk38","_id":"ciswie9dz0011e3u2fn4z7ssl"},{"post_id":"ciswie9e00014e3u26om3dq7o","category_id":"ciswie9cn0008e3u2wt2h5r9y","_id":"ciswie9e7001fe3u2cte7vpxg"},{"post_id":"ciswie9e20017e3u2j88j9oe0","category_id":"ciswie9cb0003e3u2mq1xwk38","_id":"ciswie9e8001je3u2qevbh1es"},{"post_id":"ciswie9e5001ce3u2y2lmfsq1","category_id":"ciswie9cn0008e3u2wt2h5r9y","_id":"ciswie9e8001me3u2epwaqvp6"},{"post_id":"ciswie9db000re3u29wie234t","category_id":"ciswie9e4001ae3u2qlu5ct4e","_id":"ciswie9e9001oe3u2nf8c5o4f"},{"post_id":"ciswie9dd000ue3u2cz4x0duq","category_id":"ciswie9e4001ae3u2qlu5ct4e","_id":"ciswie9ea001re3u2tcgwlqrb"},{"post_id":"ciswie9dv000ye3u23cjv9pdj","category_id":"ciswie9e4001ae3u2qlu5ct4e","_id":"ciswie9ea001te3u2xcuk86vu"},{"post_id":"ciswie9co0009e3u2qokc92en","category_id":"ciswie9e4001ae3u2qlu5ct4e","_id":"ciswnsjdo0000msu2xxt1y3jq"},{"post_id":"ciswie9d4000je3u2y1hz70im","category_id":"ciswie9e4001ae3u2qlu5ct4e","_id":"ciswnulyf0001msu2fs8tfqpg"},{"post_id":"ciswie9cm0007e3u280pwhiyi","category_id":"ciswie9e4001ae3u2qlu5ct4e","_id":"ciswnvbwz0002msu22ieuk5xt"},{"post_id":"ciswie9dx0010e3u283e71vtt","category_id":"ciswie9e4001ae3u2qlu5ct4e","_id":"ciswnvvin0003msu2k8nyg9s8"}],"PostTag":[{"post_id":"ciswie9bz0000e3u2ysvu3uno","tag_id":"ciswie9c80002e3u26a9bnub0","_id":"ciswie9d5000le3u2cqgu2nrp"},{"post_id":"ciswie9bz0000e3u2ysvu3uno","tag_id":"ciswie9cl0006e3u25zqg90ce","_id":"ciswie9d9000oe3u2ps69mqwh"},{"post_id":"ciswie9bz0000e3u2ysvu3uno","tag_id":"ciswie9cu000ce3u2vlbsq1x2","_id":"ciswie9dd000te3u2wa2msykn"},{"post_id":"ciswie9c50001e3u23qsy7wya","tag_id":"ciswie9c80002e3u26a9bnub0","_id":"ciswie9e20016e3u24ekzebxc"},{"post_id":"ciswie9c50001e3u23qsy7wya","tag_id":"ciswie9cl0006e3u25zqg90ce","_id":"ciswie9e40019e3u2yuugewrt"},{"post_id":"ciswie9c50001e3u23qsy7wya","tag_id":"ciswie9dh000we3u2vwdg5cx0","_id":"ciswie9e7001ee3u2zuiojowo"},{"post_id":"ciswie9cb0004e3u2aowy3tdi","tag_id":"ciswie9c80002e3u26a9bnub0","_id":"ciswie9e9001ne3u2mxstrtwy"},{"post_id":"ciswie9cb0004e3u2aowy3tdi","tag_id":"ciswie9cl0006e3u25zqg90ce","_id":"ciswie9e9001pe3u2xc4407rs"},{"post_id":"ciswie9cb0004e3u2aowy3tdi","tag_id":"ciswie9dh000we3u2vwdg5cx0","_id":"ciswie9ea001se3u2v4c8b73j"},{"post_id":"ciswie9cd0005e3u21c8u1bym","tag_id":"ciswie9e8001ke3u2qykxtl51","_id":"ciswie9ee001we3u2qnxakzed"},{"post_id":"ciswie9cd0005e3u21c8u1bym","tag_id":"ciswie9e9001qe3u2difvay9e","_id":"ciswie9ee001xe3u2306a1lxo"},{"post_id":"ciswie9cd0005e3u21c8u1bym","tag_id":"ciswie9ec001ue3u2ibsq153i","_id":"ciswie9ee001ze3u2doyu895u"},{"post_id":"ciswie9cm0007e3u280pwhiyi","tag_id":"ciswie9c80002e3u26a9bnub0","_id":"ciswie9ef0021e3u2xae49tlv"},{"post_id":"ciswie9cm0007e3u280pwhiyi","tag_id":"ciswie9ee001ve3u2tx1mndwz","_id":"ciswie9ef0022e3u2lphn3vrp"},{"post_id":"ciswie9cm0007e3u280pwhiyi","tag_id":"ciswie9ee001ye3u2u5kui492","_id":"ciswie9ef0024e3u2yqg45rdw"},{"post_id":"ciswie9co0009e3u2qokc92en","tag_id":"ciswie9e8001ke3u2qykxtl51","_id":"ciswie9eg0027e3u2hlpf3bhe"},{"post_id":"ciswie9co0009e3u2qokc92en","tag_id":"ciswie9e9001qe3u2difvay9e","_id":"ciswie9eh0028e3u2dv7t1wh4"},{"post_id":"ciswie9co0009e3u2qokc92en","tag_id":"ciswie9ec001ue3u2ibsq153i","_id":"ciswie9eh002ae3u2hcpn52bh"},{"post_id":"ciswie9cq000be3u2gz6jx9l9","tag_id":"ciswie9c80002e3u26a9bnub0","_id":"ciswie9ei002be3u2fd1cnn3l"},{"post_id":"ciswie9cq000be3u2gz6jx9l9","tag_id":"ciswie9cl0006e3u25zqg90ce","_id":"ciswie9ei002de3u2ebkmoooz"},{"post_id":"ciswie9cq000be3u2gz6jx9l9","tag_id":"ciswie9dh000we3u2vwdg5cx0","_id":"ciswie9ej002ee3u2jnga6qo1"},{"post_id":"ciswie9cy000ee3u2w8lf47sv","tag_id":"ciswie9c80002e3u26a9bnub0","_id":"ciswie9ej002he3u28tgpmm7y"},{"post_id":"ciswie9cy000ee3u2w8lf47sv","tag_id":"ciswie9ee001ve3u2tx1mndwz","_id":"ciswie9ej002ie3u2f0jr6xpq"},{"post_id":"ciswie9cy000ee3u2w8lf47sv","tag_id":"ciswie9cu000ce3u2vlbsq1x2","_id":"ciswie9ek002ke3u2ff8rhtyl"},{"post_id":"ciswie9cy000ee3u2w8lf47sv","tag_id":"ciswie9ei002ce3u2k3nihz13","_id":"ciswie9ek002le3u2xkd0tlpc"},{"post_id":"ciswie9cy000ee3u2w8lf47sv","tag_id":"ciswie9ej002fe3u23ja7p4gp","_id":"ciswie9ek002ne3u2vsziy11q"},{"post_id":"ciswie9d1000fe3u21bcenr6e","tag_id":"ciswie9c80002e3u26a9bnub0","_id":"ciswie9el002se3u2vlgwnm4q"},{"post_id":"ciswie9d1000fe3u21bcenr6e","tag_id":"ciswie9ee001ve3u2tx1mndwz","_id":"ciswie9el002te3u279harhv7"},{"post_id":"ciswie9d1000fe3u21bcenr6e","tag_id":"ciswie9cu000ce3u2vlbsq1x2","_id":"ciswie9el002ve3u2axud3t4u"},{"post_id":"ciswie9d1000fe3u21bcenr6e","tag_id":"ciswie9ek002je3u205a08f2x","_id":"ciswie9el002we3u2qk3026qq"},{"post_id":"ciswie9d1000fe3u21bcenr6e","tag_id":"ciswie9ek002me3u297q80rt8","_id":"ciswie9el002ye3u2i71j1oeq"},{"post_id":"ciswie9d1000fe3u21bcenr6e","tag_id":"ciswie9ek002oe3u24kjo83hk","_id":"ciswie9em002ze3u2cct772d0"},{"post_id":"ciswie9d1000fe3u21bcenr6e","tag_id":"ciswie9ek002pe3u2yw1v1w14","_id":"ciswie9em0031e3u2gwwb2by7"},{"post_id":"ciswie9d1000fe3u21bcenr6e","tag_id":"ciswie9ek002qe3u2nykq0tdz","_id":"ciswie9en0032e3u2zvitke64"},{"post_id":"ciswie9d4000je3u2y1hz70im","tag_id":"ciswie9el002re3u2071ly3zt","_id":"ciswie9eo0034e3u2t4xjt1pl"},{"post_id":"ciswie9d4000je3u2y1hz70im","tag_id":"ciswie9el002ue3u2zgu9mf2r","_id":"ciswie9eo0035e3u22vie6fxc"},{"post_id":"ciswie9d4000je3u2y1hz70im","tag_id":"ciswie9el002xe3u2ftrbds5d","_id":"ciswie9ep0037e3u29g0sd3nr"},{"post_id":"ciswie9d4000je3u2y1hz70im","tag_id":"ciswie9em0030e3u2mw8rvy6e","_id":"ciswie9ep0038e3u2l61ef2qm"},{"post_id":"ciswie9d7000me3u27inh99nn","tag_id":"ciswie9c80002e3u26a9bnub0","_id":"ciswie9ep003ae3u27x0t01dz"},{"post_id":"ciswie9d7000me3u27inh99nn","tag_id":"ciswie9ee001ve3u2tx1mndwz","_id":"ciswie9ep003be3u2bgxyp31y"},{"post_id":"ciswie9d7000me3u27inh99nn","tag_id":"ciswie9cu000ce3u2vlbsq1x2","_id":"ciswie9eq003de3u23zdst8hy"},{"post_id":"ciswie9db000re3u29wie234t","tag_id":"ciswie9c80002e3u26a9bnub0","_id":"ciswie9eq003ee3u2934z6why"},{"post_id":"ciswie9db000re3u29wie234t","tag_id":"ciswie9cl0006e3u25zqg90ce","_id":"ciswie9eq003ge3u26tr31br3"},{"post_id":"ciswie9db000re3u29wie234t","tag_id":"ciswie9eo0036e3u2kybf2m6m","_id":"ciswie9eq003he3u26k1ciovs"},{"post_id":"ciswie9dd000ue3u2cz4x0duq","tag_id":"ciswie9c80002e3u26a9bnub0","_id":"ciswie9er003je3u2m1x2ur9n"},{"post_id":"ciswie9dd000ue3u2cz4x0duq","tag_id":"ciswie9cl0006e3u25zqg90ce","_id":"ciswie9er003ke3u2gmep8shv"},{"post_id":"ciswie9dd000ue3u2cz4x0duq","tag_id":"ciswie9ep0039e3u2pwg33w6r","_id":"ciswie9er003le3u22zjbvf14"},{"post_id":"ciswie9dv000ye3u23cjv9pdj","tag_id":"ciswie9c80002e3u26a9bnub0","_id":"ciswie9es003ne3u2spu8xyc8"},{"post_id":"ciswie9dv000ye3u23cjv9pdj","tag_id":"ciswie9cl0006e3u25zqg90ce","_id":"ciswie9es003oe3u2eukn6zsv"},{"post_id":"ciswie9dv000ye3u23cjv9pdj","tag_id":"ciswie9ep0039e3u2pwg33w6r","_id":"ciswie9et003qe3u2rsge9he3"},{"post_id":"ciswie9dx0010e3u283e71vtt","tag_id":"ciswie9c80002e3u26a9bnub0","_id":"ciswie9ev003se3u2s8mzncz5"},{"post_id":"ciswie9dx0010e3u283e71vtt","tag_id":"ciswie9eq003fe3u26cznmc7h","_id":"ciswie9ev003te3u2spg0gp4n"},{"post_id":"ciswie9dx0010e3u283e71vtt","tag_id":"ciswie9eq003ie3u259716drx","_id":"ciswie9ev003ve3u2ktfr4w35"},{"post_id":"ciswie9dx0010e3u283e71vtt","tag_id":"ciswie9er003me3u2qah2kcq3","_id":"ciswie9ev003we3u2shzilqqa"},{"post_id":"ciswie9dx0010e3u283e71vtt","tag_id":"ciswie9ee001ve3u2tx1mndwz","_id":"ciswie9ev003ye3u2838lpyly"},{"post_id":"ciswie9e00014e3u26om3dq7o","tag_id":"ciswie9e8001ke3u2qykxtl51","_id":"ciswie9ew0042e3u2an9yaaxm"},{"post_id":"ciswie9e00014e3u26om3dq7o","tag_id":"ciswie9ev003ue3u2x3ki8n9w","_id":"ciswie9ew0043e3u2fjauwpfp"},{"post_id":"ciswie9e00014e3u26om3dq7o","tag_id":"ciswie9ee001ve3u2tx1mndwz","_id":"ciswie9ew0045e3u2rus0s3oc"},{"post_id":"ciswie9e00014e3u26om3dq7o","tag_id":"ciswie9ev003ze3u2bfij3461","_id":"ciswie9ew0046e3u2lfrlw223"},{"post_id":"ciswie9e00014e3u26om3dq7o","tag_id":"ciswie9ew0040e3u2jmh9ji2r","_id":"ciswie9ex0048e3u2rfhrxegj"},{"post_id":"ciswie9e20017e3u2j88j9oe0","tag_id":"ciswie9c80002e3u26a9bnub0","_id":"ciswie9ex0049e3u2mw8ftah2"},{"post_id":"ciswie9e20017e3u2j88j9oe0","tag_id":"ciswie9ee001ve3u2tx1mndwz","_id":"ciswie9ey004be3u2olj5gtab"},{"post_id":"ciswie9e20017e3u2j88j9oe0","tag_id":"ciswie9cu000ce3u2vlbsq1x2","_id":"ciswie9ey004ce3u2xqzdz7yr"},{"post_id":"ciswie9e20017e3u2j88j9oe0","tag_id":"ciswie9ew0044e3u2iub9q6z1","_id":"ciswie9ez004ee3u21usxlb61"},{"post_id":"ciswie9e5001ce3u2y2lmfsq1","tag_id":"ciswie9e8001ke3u2qykxtl51","_id":"ciswie9f1004he3u2eofsq5k0"},{"post_id":"ciswie9e5001ce3u2y2lmfsq1","tag_id":"ciswie9ev003ue3u2x3ki8n9w","_id":"ciswie9f1004ie3u2xlxqmbll"},{"post_id":"ciswie9e5001ce3u2y2lmfsq1","tag_id":"ciswie9ee001ve3u2tx1mndwz","_id":"ciswie9f1004je3u2vakhz65y"},{"post_id":"ciswie9e5001ce3u2y2lmfsq1","tag_id":"ciswie9ez004fe3u2v2fsw9z1","_id":"ciswie9f1004ke3u237johv62"},{"post_id":"ciswie9e5001ce3u2y2lmfsq1","tag_id":"ciswie9ew0040e3u2jmh9ji2r","_id":"ciswie9f1004le3u2mcyuqcmh"}],"Tag":[{"name":"iOS","_id":"ciswie9c80002e3u26a9bnub0"},{"name":"xcode","_id":"ciswie9cl0006e3u25zqg90ce"},{"name":"Swift","_id":"ciswie9cu000ce3u2vlbsq1x2"},{"name":"Objective-C","_id":"ciswie9dh000we3u2vwdg5cx0"},{"name":"iOS9","_id":"ciswie9e8001ke3u2qykxtl51"},{"name":"Xcode7.1","_id":"ciswie9e9001qe3u2difvay9e"},{"name":"UICollectionView","_id":"ciswie9ec001ue3u2ibsq153i"},{"name":"Xcode","_id":"ciswie9ee001ve3u2tx1mndwz"},{"name":"octopress","_id":"ciswie9ee001ye3u2u5kui492"},{"name":"UITableView","_id":"ciswie9ei002ce3u2k3nihz13"},{"name":"UITableViewCell","_id":"ciswie9ej002fe3u23ja7p4gp"},{"name":"ARC","_id":"ciswie9ek002je3u205a08f2x"},{"name":"内存管理","_id":"ciswie9ek002me3u297q80rt8"},{"name":"循环引用","_id":"ciswie9ek002oe3u24kjo83hk"},{"name":"Block","_id":"ciswie9ek002pe3u2yw1v1w14"},{"name":"Delegate","_id":"ciswie9ek002qe3u2nykq0tdz"},{"name":"年终总结","_id":"ciswie9el002re3u2071ly3zt"},{"name":"Plan","_id":"ciswie9el002ue3u2zgu9mf2r"},{"name":"Summary","_id":"ciswie9el002xe3u2ftrbds5d"},{"name":"计划","_id":"ciswie9em0030e3u2mw8rvy6e"},{"name":"面试","_id":"ciswie9eo0036e3u2kybf2m6m"},{"name":"iOS面试","_id":"ciswie9ep0039e3u2pwg33w6r"},{"name":"React Native","_id":"ciswie9eq003fe3u26cznmc7h"},{"name":"Node.js","_id":"ciswie9eq003ie3u259716drx"},{"name":"Hybrid","_id":"ciswie9er003me3u2qah2kcq3"},{"name":"Xcode7.3","_id":"ciswie9ev003ue3u2x3ki8n9w"},{"name":"CoreGraphics","_id":"ciswie9ev003ze3u2bfij3461"},{"name":"Quartz2D","_id":"ciswie9ew0040e3u2jmh9ji2r"},{"name":"Swift2.2","_id":"ciswie9ew0044e3u2iub9q6z1"},{"name":"UIBezierPath","_id":"ciswie9ez004fe3u2v2fsw9z1"}]}}