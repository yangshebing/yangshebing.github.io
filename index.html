
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>杨社兵的技术博客</title>
  <meta name="author" content="杨社兵">

  
  <meta name="description" content="iOS面试中熟悉常见算法 1、 对以下一组数据进行降序排序（冒泡排序）。“24，17，85，13，9，54，76，45，5，63” ">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://yangshebing.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="杨社兵的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">杨社兵的技术博客</a></h1>
  
    <h2>业精于勤荒于嬉，行成于思毁于随.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="yangshebing.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">我的博客</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
  <li><a href="http://weibo.com/yangshebing" target="_blank">新浪微博</a></li>
  <li><a href="/about">关于我</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-chang-jian-suan-fa/">iOS面试题系列之常见算法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-04-24T23:59:06+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>11:59 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>iOS面试中熟悉常见算法</h4>

<p>1、    对以下一组数据进行降序排序（冒泡排序）。“24，17，85，13，9，54，76，45，5，63”</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-chang-jian-suan-fa/">阅读全篇...</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-uiji-chu/">iOS面试题系列之UI相关</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-04-24T23:58:39+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>11:58 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1、    简述app启动周期。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>打开应用程序，它先会执行main函数，再执行UIApplicationMain函数。初始化UIApplication，设置代理对象，开启事件循环，调用代理方法进行事件处理。首先会调用application:didFinishLaunchingWithOptions:代理方法。接下来会调用applicationDidBecomeActive:代理方法。监听系统事件，结束程序。当程序正常退出UIApplicationMain函数才会返回。监听系统事件：锁屏后app会调用：applicationWillResignActive:代理方法。然后接着调用applicationDidEnterBackground:方法。解锁后app会调用：applicationWillEnterForeground:代理方法。接着调用applicationDidBecomeActive代理方法。杀死进程会调用：applicationWillTerminate:代理方法。接听电话：先调用applicationWillResignActive:代理方法。挂断电话后会直接进入应用调：applicationDidBecomeActive:代理方法。出现内存警告会调用：applicationDidReceiveMemoryWarning:代理方法
</span></code></pre></td></tr></table></div></figure>


<p>2、    简单的说说UIApplication的作用及继承关系。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（1）UIApplication是继承UIResponder的。UIApplication是整个应用程序的核心。每一个程序在运行期必须有UIApplication(或子类)的一个实例（有且只有一个），通过[UIApplication shareApplication]可以得到这个单例实例。（2）UIApplication帮助管理应用程序的生命周期，通过delegate来履行任务。（3）UIApplication可以接收事件，把所有用户事件都放入队列，逐个处理。它会发送当前事件给一个合适的目标控件进行处理。他还将部分事件转给delegate对象来处理。delegate可以处理的事件包括：应用程序的生命周期事件（如程序启动与关闭）、系统事件（如来电）。
</span></code></pre></td></tr></table></div></figure>


<p>3、    简述推送消息原理。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（1）应用程序注册接收远程通知的时候，系统会发送请求到APNS服务器。APNS服务器收到请求后会根据请求所带的key值生成一个独一无二的deviceToken。然后APNS服务器会把deviceToken包装成NSData对象发送到对应请求的App上。接下来APP把deviceToken发送给我们自己的服务器（Provider）。服务器接收到deviceToken后进行存储等相关处理。服务器会把推送给用户的消息发送至APNS服务器，最后APNS服务器再发送通知给app。（2）有关于deviceToken变化问题：重新安装或卸载应用程序，deviceToken不会发生变化。系统升级deviceToken可能会发生变化。抹掉所有内容和设置，重置设备后，deviceToken会变化（3）注册远程通知方法注册远程通知：一般在app启动完成的时候注册远程通知，注册方法一般在didFinishLaunchingWithOptions：代理方法中处理注册远程通知回调方法：注册成功会回调didRegisterForRometoNotificationsWithDeviceToken:其中的deviceToken参数就是APNS服务器返回的token。注册失败会回调didFailToRegisterForRemoteNotificationsWithError:（4）处理接收到的远程通知消息程序启动时，app从Terminate状态进入Foreground状态时，会根据didFinishLaunchingWithOptions:代理方法中的luanchOptions参数来获取userInfo。判断是否有推送消息。方式如下：   // userInfo为收到远程通知的内容NSDictionary*userInfo=launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey];if (userInfo) {   // 有推送的消息，处理推送的消息  }如果app处于Background状态时，只有用户点击了通知消息才会调用didReceiveRemoteNotification:，如果当前app处于Foreground状态，会直接调用该方法。
</span></code></pre></td></tr></table></div></figure>


<p>4、    简单说下UITableView、UIButton、UIWindow控件的继承关系。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（1）UITableView的继承关系：UITableView继承UIScrollView。UIScrollView继承UIView。UIView继承UIResponder。UIResponder继承NSObject。（2）UIButton的继承关系：UIButton继承UIControl，UIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。（3）UIWindow继承UIView。
</span></code></pre></td></tr></table></div></figure>


<p>5、    UIView与UIButton有什么区别？UISwitch呢？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIView继承自UIResponder，它能响应某个动作。UIButton继承UIControl。它不仅可以响应某个动作，还能为某个对象添加对应的动作加以响应。UIButton也能实现UISwitch的功能，它们的区别是分发的事件不一样。
</span></code></pre></td></tr></table></div></figure>


<p>6、    简述UIControl的继承关系，它用来做什么？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIControl继承UIView。UIView继承UIResponder，UIResponder继承NSObject。它能为某个特定对象添加事件。能进行事件分发。
</span></code></pre></td></tr></table></div></figure>


<p>7、    简述UIViewController中view的生命周期。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>先调用loadView方法，再调用viewDidLoad方法，调用viewWillAppear方法，调用viewWillLayoutSubviews方法，调用viewDidLayoutSubviews方法，再调用viewDidApper方法。控制器消失的时候先调用viewWillDisappear方法，再调用viewDidDisapper方法。最后调用dealloc方法。当出现内存警告的时候会调用didReceiveMemoryWarning方法。
</span></code></pre></td></tr></table></div></figure>


<p>8、    简述UITableView的代理方法调用顺序。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>先调用numberOfSectionsInTableView:方法，numberOfRowsInSection:heightForRowAtIndexPath:cellForRowAtIndexPath:
</span></code></pre></td></tr></table></div></figure>


<p>9、    你在用CollectionView的时候有没有遇到什么问题？问题是怎么解决的？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>刷新的时候会闪烁。在刷新的时候会默认附加一个隐式的fade动画。可以通过取消动画来达到取消闪烁的目的。
</span></code></pre></td></tr></table></div></figure>


<p>10、   简述UIResponder类的作用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIResponder类主要是为那些需要响应并处理事件的对象定义了一组接口。这些事件包括：触摸事件、运动事件、远程控制事件（如耳机控制音视频播放）。当用户触发某一事件时，UIKit会创建一个UIEvent事件对象，事件对象会加入到一个FIFO先进先出的队列中。UIApplication对象处理事件时，会从队列头部取出一个事件对象进行分发。
</span></code></pre></td></tr></table></div></figure>


<p>11、   如何监听View的触摸事件？事件如何传递？简述视图的响应者链。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>可以通过View类的touchesBegan、touchesMoved、touchesEnded、touchesCancelled方法监听视图的触摸。当触摸一个视图对象时，系统会捕捉此事件，并给这个事件创建一个UIEvent对象，将此对象加入当前应用程序的事件队列中，然后由UIApplication对象从队列中取出来进行事件分发，首先会分发给UIWindow对象，然后由UIWindow对象分发给触摸的视图对象，即第一响应者对象。响应者链：当事件交给第一响应者处理，如果第一响应者不处理，事件就会沿着响应者链向上传递，交给下一个响应者。一般来说，第一响应者是一个视图对象或者是其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象，然后是它的父视图对象，以此类推，直到顶层视图。接下来会沿着顶层视图到UIWindow对象，再到UIApplication对象。如果整个过程都没有响应这个事件，该事件就会被丢弃，一般情况下，在响应者链中只要有对象处理事件，事件就会停止传递。有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。
</span></code></pre></td></tr></table></div></figure>


<p>12、   CALayer与UIView有什么区别？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（1）UIView是iOS系统中界面元素的继承。所有的界面元素都继承自它，他本身完全是由CoreAnimation来实现的。它真正的绘图部分，是由一个叫CALayer的类来管理。UIView本身更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，如frame,bounds等，实际上内部都是在访问它所包含的CALayer的相关属性。（2）UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示。（3）UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer。（4）CALayer坐标系统与UIView有点不一样，它多了一个anchorPoint的属性。（5）UIView的layer树形在系统内部，被系统维护着三份copy。逻辑树，动画树，显示树。（6）CALayer默认修改属性支持隐式动画（7）View可以接受并处理事件，Layer不可以。
</span></code></pre></td></tr></table></div></figure>


<p>13、   如何优化UITableView?</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（1）复用单元格（2）使用不透明的视图，单元格中少使用动画。（3）图片使用异步加载，设置图片加载的并发数。（4）滑动时不加载图片，停止滑动时再加载。（5）图片和文字可以直接drawRect（6）如果cell是动态行高，计算缓存单元格高度（7）尽量少reloadData，只reloadRowsAtIndexPaths（8）cell高度固定直接用rowHeight属性设置高度。
</span><span class='line'></span></code></pre></td></tr></table></div></figure>


<p>14、   简述加载到控制器上的根视图创建与加载时机。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>视图控制器的根视图加载是在UIViewController的loadView方法中。当视图控制中的loadView方法被调用时，会先通过NSBundle加载，通过控制器的类名作为xib文件名加载xib文件，如果存在，加载View为根视图，如果不存在，则自动创建一个View作为根视图。
</span><span class='line'></span></code></pre></td></tr></table></div></figure>


<p>15、   简述UITableView中cell的复用机制。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UITableView会创建屏幕显示单元格个数（N）+1个单元格，当滑动到第N+2个单元格时就会复用第1个单元格。UITableView中还有单元格复用池的概念。当tableView调用初始化单元格协议方法获取单元格时，它会根据你设定的reuse identifier先去复用池中查找可用的复用单元格，找到则复用该单元格，没找到这创建一个新的单元格对象。
</span></code></pre></td></tr></table></div></figure>


<p><strong>本文内容中部分来自网络，后续会持续更新完善。欢迎一起学习交流！</strong></p>

<p><strong>如需转载，请注明出处</strong></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/04/24/iosmian-shi-ti-zhi-objective-cji-chu/">iOS面试题系列之Objective-C基础</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-04-24T23:58:04+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>11:58 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/01/21/react-native-ios-kai-fa-huan-jing-da-jian/">React Native iOS 开发环境搭建</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-21T01:07:09+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>1:07 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>一、React Native基础环境搭建</h4>

<p>1、安装<a href="http://brew.sh">Homebrew</a></p>

<p>打开终端输入：
<code>
ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
</code></p>

<p>2、安装<a href="https://github.com/creationix/nvm#installation">nvm</a>方法</p>

<p>通过脚本安装方式，在终端执行：
<code>
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.1/install.sh | bash
</code></p>

<p>激活nvm,在安装脚本执行完之后，在终端执行:
<code>
. ~/.nvm/nvm.sh
</code></p>

<p>nvm其他安装方式详见<a href="https://github.com/creationix/nvm#installation">安装向导</a></p>

<p>3、默认安装最新版本的Node.js并且设置好命令行的环境变量
<code>
nvm install node &amp;&amp; nvm alias default node
</code></p>

<p>可以输入node命令启动Node.js环境，npm(node package manager)文档传送门:<a href="https://docs.npmjs.com">&ldquo;点击此处&rdquo;</a></p>

<p>4、安装watchman</p>

<p>在终端输入：
<code>
brew install watchman
</code></p>

<p>到此处React Native基础环境搭建基本完成，推荐经常运行<code>brew update &amp;&amp; brew upgrade</code>命令保持你的程序是最新的。</p>

<h4>二、iOS开发环境</h4>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/01/21/react-native-ios-kai-fa-huan-jing-da-jian/">阅读全篇...</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/01/15/swiftnei-cun-guan-li-(arc)zhi-xun-huan-yin-yong/">Swift内存管理（ARC）之循环引用</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-15T01:37:31+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>1:37 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Swift中是采用自动引用计数(ARC，AutomaticReferenceCounting)机制来对内存进行管理的。</p>

<h4>一、简述ARC如何工作：</h4>

<p>每当你每创建一个新的对象，它便会分配一块内存来存储该对象的相关信息。当你不再需要这个对象的时候，它就会自动释放这个对象，避免它再占用内存空间。当然，如果该对象只要至少存在一个引用就不会被释放。另外，你如果访问了一个已经被释放的对象，则很有可能会出现崩溃（野指针）。
拿《The Swift Programming Language》里面的例子来套一下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//创建一个Cat类，自带常量name属性
</span><span class='line'>class Cat {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) {
</span><span class='line'>    //初始化name属性
</span><span class='line'>        self.name = name;
</span><span class='line'>        print("\(name) 对象已经被初始化")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(name) 对象释放成功！")
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/01/15/swiftnei-cun-guan-li-(arc)zhi-xun-huan-yin-yong/">阅读全篇...</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/01/04/swiftzhong-uitableviewde-yong-fa-zi-ding-yi-uitableviewhe-uitableviewcell/">Swift中UITableView的用法(自定义UITableView和UITableViewCell)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-04T21:23:33+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>9:23 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一、自定义表视图（UITableView）</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/01/04/swiftzhong-uitableviewde-yong-fa-zi-ding-yi-uitableviewhe-uitableviewcell/">阅读全篇...</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/01/02/ioskai-fa-zhi-ji-chu-kong-jian-(swiftban-)/">iOS开发之基础控件（Swift版）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-02T11:08:19+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2016</span></span> <span class='time'>11:08 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>  1、文本（UILabel）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  let titleLabel = UILabel(frame: CGRectMake(0, 0, view.frame.size.width, view.frame.size.height))
</span><span class='line'>        //设置titleLabel的文本对齐方式：左：.Left, 中:.Center, 右:.Right
</span><span class='line'>        titleLabel.textAlignment = .Center
</span><span class='line'>        //设置titleLabel的文本颜色
</span><span class='line'>        titleLabel.textColor = UIColor.lightGrayColor()
</span><span class='line'>        //设置titleLabel文字的字体为系统字体，大小为15
</span><span class='line'>        titleLabel.font = UIFont.systemFontOfSize(15)
</span><span class='line'>        //设置titleLabel文字的字体为"Helvetica", 大小为15
</span><span class='line'>        titleLabel.font = UIFont(name: "Helvetica", size: 15)
</span><span class='line'>        titleLabel.text = "心灵鸡汤，每天一起干"
</span><span class='line'>        //titleLabel字体大小自适应宽度，根据指定宽度titleLabel自动调整字体显示大小
</span><span class='line'>        titleLabel.adjustsFontSizeToFitWidth = true
</span><span class='line'>        //指定titleLabel的显示行数，0代表自动折行
</span><span class='line'>        titleLabel.numberOfLines = 1
</span><span class='line'>        //获取系统所有字体名称
</span><span class='line'>        let fontFamily = UIFont.familyNames()
</span><span class='line'>        print(fontFamily)
</span><span class='line'>        view.addSubview(titleLabel)</span></code></pre></td></tr></table></div></figure>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/01/02/ioskai-fa-zhi-ji-chu-kong-jian-(swiftban-)/">阅读全篇...</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/01/01/2015nian-zhong-zong-jie/">2015年终总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-01T13:26:26+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>1:26 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>总结：</h4>

<p>回首过去一年，好像没有什么能说出口的成绩，专业没啥进步。在公司做了两款App，上半年主要开发的是一款叫“在线等”的手机应用，这是一款解决人们选择困难症的应用，经过重重困难，最终上线。没啥成绩可言。下半年主要研发的是一款叫“斗图神器”的应用，由于Android版早就开发好了，所以iOS版开发起来就快很多了。总的来说成绩还不错，其中也有点小波折。</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/01/01/2015nian-zhong-zong-jie/">阅读全篇...</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/16/ios-ffmpegbian-yi-ji-kxmovie,-iframeextractordiao-shi-xiang-jie-(wu-zhang-ai-yue-du-,jue-dui-shi-ni-xiang-yao-de-)/">iOS FFmpeg编译及kxmovie、iFrameExtractor调试详解（无障碍阅读，绝对是你想要的）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-16T01:44:27+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:44 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>特此声明：本文是通过网上收集整理加上自己亲自实验得来的。感谢所有网上分享的辛勤劳动者，本文仅供iOS学习使用。在学习的过程中，如果有问题或者不清楚的地方，欢迎留言，我们共同探讨互相学习。欢迎批评指正。</strong></p>

<p><strong>如需转载，请注明出处：<a href = "http://blog.csdn.net/yangshebing21/article/details/43986913"><a href="http://blog.csdn.net/yangshebing21/article/details/43986913">http://blog.csdn.net/yangshebing21/article/details/43986913</a></a></strong></p>

<h4>开发环境：最新 ffmpeg-2.5.4/iOS SDK8.1/Xcode6.1/OS X Yosemite版本10.10.2</h4>

<h3>一、编译ffmpeg库</h3>

<h4>编译调试ffmpeg库的步骤：</h4>

<p><strong>开发环境：ffmpeg-2.5.4/Xcode6.1</strong></p>

<h4>（一）、下载ffmpeg源码：</h4>

<p>请点击此链接<a href = "http://ffmpeg.org/download.html"><a href="http://ffmpeg.org/download.html">http://ffmpeg.org/download.html</a></a></p>

<p> <font color = "red"><b>注：我的ffmpeg-2.5.4是解压放至Desktop的</b></font></p>

<h4>（二）、调试编译ffmpeg源码</h4>

<p> 1、安装yasm:
 </div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/11/16/ios-ffmpegbian-yi-ji-kxmovie,-iframeextractordiao-shi-xiang-jie-(wu-zhang-ai-yue-du-,jue-dui-shi-ni-xiang-yao-de-)/">阅读全篇...</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/03/waterflow/">UICollectionView（纯代码方式）实现带上下拉刷新的瀑布流式（WaterFlow）布局</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-03T22:40:32+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>10:40 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>瀑布流（WaterFlow）是项目开发过程中的常见布局，有关于瀑布流（WaterFlow）的实现方式：在UICollectionView未出现之前，瀑布流的实现多半是采用UIScrollView或是UITableView。对于我们这种用惯了表视图的人来说，UICollectionView倒略显陌生。有关于UICollectionView的介绍我就不一一赘述，因为一两句话也很难说清楚。网上有很多优秀的文章专门对其进行了一系列的解说，另有苹果官方文档可以查阅。本文主要是介绍如何采用纯代码的方式利用UICollectionView实现带上下拉刷新的瀑布流式（WaterFlow）布局。废话少说，直接入题。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/11/03/waterflow/">阅读全篇...</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-chang-jian-suan-fa/">iOS面试题系列之常见算法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/24/iosmian-shi-ti-xi-lie-zhi-uiji-chu/">iOS面试题系列之UI相关</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/24/iosmian-shi-ti-zhi-objective-cji-chu/">iOS面试题系列之Objective-C基础</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/21/react-native-ios-kai-fa-huan-jing-da-jian/">React Native iOS 开发环境搭建</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/15/swiftnei-cun-guan-li-(arc)zhi-xun-huan-yin-yong/">Swift内存管理（ARC）之循环引用</a>
      </li>
    
  </ul>
</section>
<section>
 <h1>iOS开发</h1>
 <ul id="categories">
  <li class='category'><a href='/blog/categories/objective-c/'>objective-c (4)</a></li>
<li class='category'><a href='/blog/categories/others/'>others (7)</a></li>
<li class='category'><a href='/blog/categories/swift/'>swift (4)</a></li>

 </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - 杨社兵 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <span class="credit">, 感谢 <a href="http://gitcafe.com/signup?invited_by=yangshebing" target="_blank">GitCafe</a> 为本站提供存储空间</span>

  	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?be50b7d5e40e390ecfdd9cc1a14fe0e6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
</p>

</footer>
  











</body>
</html>
